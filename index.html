<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realm Tycoon</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Local Fonts -->
    <style>
        @font-face {
            font-family: 'Cinzel';
            font-weight: 400;
            font-style: normal;
            font-display: swap;
            src: url('fonts/Cinzel-Regular.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Cinzel';
            font-weight: 600;
            font-style: normal;
            font-display: swap;
            src: url('fonts/Cinzel-SemiBold.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Cinzel';
            font-weight: 800;
            font-style: normal;
            font-display: swap;
            src: url('fonts/Cinzel-ExtraBold.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Crimson Pro';
            font-weight: 400;
            font-style: normal;
            font-display: swap;
            src: url('fonts/CrimsonPro-Regular.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Crimson Pro';
            font-weight: 600;
            font-style: normal;
            font-display: swap;
            src: url('fonts/CrimsonPro-SemiBold.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Crimson Pro';
            font-weight: 700;
            font-style: normal;
            font-display: swap;
            src: url('fonts/CrimsonPro-Bold.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Crimson Pro';
            font-weight: 400;
            font-style: italic;
            font-display: swap;
            src: url('fonts/CrimsonPro-Italic.ttf') format('truetype');
        }
    </style>

    <style>
        /* CSS Variables - Dark Fantasy Theme */
        :root {
            /* Backgrounds */
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a2e;
            --bg-panel: rgba(18, 18, 26, 0.85); /* For glassmorphism if needed */
            --bg-overlay: rgba(10, 10, 15, 0.8);

            /* Accents */
            --accent-gold: #d4a017;
            --accent-gold-bright: #f0c040;
            --accent-purple: #6a0dad;
            --accent-crimson: #8b0000;
            --accent-success: #00ff88;
            --accent-warning: #ffaa00;
            --accent-danger: #ff4444;
            --accent-info: #00ccff;

            /* Text Colors */
            --text-primary: #e8e6e3;
            --text-secondary: #8a8a9a;
            --text-muted: #5e5e6e;

            /* Rarities */
            --rarity-common: #9d9d9d;
            --rarity-uncommon: #1eff00;
            --rarity-rare: #0070dd;
            --rarity-epic: #a335ee;
            --rarity-legendary: #ff8000;
            --rarity-mythic: #ff0000;

            /* Fonts */
            --font-display: 'Cinzel', serif;
            --font-body: 'Crimson Pro', serif;

            /* Borders & Shadows */
            --border-subtle: 1px solid #2a2a3a;
            --shadow-base: 0 4px 6px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 10px rgba(212, 160, 23, 0.3);

            /* Dimensions */
            --top-bar-h: 50px;
            --bottom-bar-h: 40px;
            --left-panel-w: 220px;
            --right-panel-w: 280px;

            /* Grid & Virtual Scroller */
            --grid-item-width: 100px;
            --grid-item-height: 120px;
            --grid-gap: 12px;

            /* Transitions */
            --transition-smooth: 0.3s ease;
        }

        /* Base Resets */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 16px;
            line-height: 1.5;
            overflow: hidden; /* Prevent body scroll, handle in panels */
            /* Add an atmospheric background image if desired later, for now dark color is fine. */
            background-image: radial-gradient(circle at center, #151520 0%, #0a0a0f 100%);
        }

        button {
            cursor: pointer;
            font-family: var(--font-display);
            border: var(--border-subtle);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 4px;
            transition: var(--transition-smooth);
            text-transform: uppercase;
            font-size: 0.9rem;
            font-weight: 600;
        }
        button:hover { background: #252540; border-color: var(--accent-gold); box-shadow: var(--shadow-glow); }
        button:disabled { opacity: 0.5; cursor: not-allowed; border-color: #333; }

        input {
            font-family: var(--font-body);
            background: var(--bg-primary);
            border: var(--border-subtle);
            color: var(--text-primary);
            padding: 8px;
            border-radius: 4px;
            outline: none;
        }
        input:focus { border-color: var(--accent-gold); }

        /* Typography */
        h1, h2, h3, h4, h5, h6 { font-family: var(--font-display); font-weight: 600; margin-bottom: 0.5rem; }
        .text-gold { color: var(--accent-gold); }
        .text-mythic { color: var(--rarity-mythic); text-shadow: 0 0 5px rgba(255,0,0,0.8); }

        /* Layout Structure */
        #game-container {
            display: grid;
            grid-template-areas: 
                "top"
                "main"
                "bottom";
            grid-template-columns: 1fr;
            grid-template-rows: var(--top-bar-h) 1fr auto;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #top-bar { grid-area: top; background: var(--bg-panel); backdrop-filter: blur(10px); border-bottom: var(--border-subtle); display: flex; justify-content: space-between; align-items: center; padding: 0 20px; z-index: 10;}
        #main-content { grid-area: main; background: var(--bg-primary); overflow-y: auto; padding: 20px; position: relative; }
        #bottom-nav { 
            grid-area: bottom; 
            background: var(--bg-panel); 
            backdrop-filter: blur(15px); 
            border-top: var(--border-subtle); 
            display: flex; 
            justify-content: space-around; 
            align-items: center; 
            z-index: 100;
        }
        
        #bottom-bar {
            grid-area: bottom;
            background: linear-gradient(to top, rgba(20, 20, 30, 0.95), rgba(10, 10, 15, 0.9));
            border-top: 2px solid var(--accent-gold);
            padding: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
        }

        .nav-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 5px;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 12px;
            transition: all 0.3s;
            color: var(--text-secondary);
            min-width: 80px;
            font-family: var(--font-display);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .nav-item .icon { font-size: 1.6rem; transition: transform 0.3s; }
        .nav-item:hover { background: rgba(212, 160, 23, 0.1); color: var(--accent-gold); }
        .nav-item:hover .icon { transform: translateY(-3px); }
        .nav-item.active {
            color: var(--accent-gold);
            background: rgba(212, 160, 23, 0.15);
            box-shadow: inset 0 0 10px rgba(212, 160, 23, 0.2);
        }

        .nav-icon {
            font-size: 1.6rem;
        }

        #main-view {
            grid-area: main;
            overflow-y: auto;
            padding: 30px;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a0f 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .view-section {
            width: 100%;
            max-width: 1000px;
            animation: fadeIn 0.4s ease-out;
        }

        .view-section.hidden {
            display: none !important;
        }

        #bottom-bar.expanded {
            height: auto;
        }
        #chat-messages { flex: 1; overflow-y: auto; padding: 10px 0; display: flex; flex-direction: column; gap: 8px; font-size: 0.9rem;}
        .msg-time { color: var(--text-muted); font-size: 0.75rem; margin-right: 5px;}
        .msg-author { font-weight: bold; margin-right: 5px; cursor: pointer; color: var(--accent-gold); }
        .msg-author:hover { text-decoration: underline; }
        #chat-input-area { display: flex; gap: 10px; padding-bottom: 10px; }
        #chat-input-area input { flex:1; }
        .resources-container { display: flex; gap: 20px; align-items: center; }
        .resource-item { display: flex; align-items: center; gap: 6px; font-weight: 600; font-family: var(--font-display); }
        .resource-item img, .resource-item span.icon { font-size: 1.2rem; }

        /* General Utilities */
        .hidden { display: none !important; }
        .card { background: var(--bg-tertiary); border: var(--border-subtle); padding: 15px; border-radius: 8px; box-shadow: var(--shadow-base); }
        .flex-between { display: flex; justify-content: space-between; align-items: center; }
        
        /* Modal System */
        #modal-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg-overlay);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
            opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #modal-container.active { opacity: 1; visibility: visible; }
        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-gold);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), 0 0 15px rgba(212, 160, 23, 0.2);
            max-width: 850px;
            width: 90%;
            position: relative;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        #modal-container.active .modal-content { transform: translateY(0); }
        .modal-close { position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 1.5rem; color: var(--text-secondary); padding: 0; }
        .modal-close:hover { color: var(--text-primary); background: none; border: none; box-shadow: none; }

        /* Upgrade Modal Styles */
        .upgrade-modal-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .upgrade-modal-title {
            text-align: center;
            font-family: var(--font-display);
            font-size: 1.5rem;
            color: var(--accent-gold);
            margin-bottom: 10px;
        }

        .upgrade-compare-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 25px;
            align-items: center;
            margin: 25px 0;
        }

        .upgrade-box {
            background: var(--bg-secondary);
            border: 2px solid #444;
            border-radius: 12px;
            padding: 25px;
            min-height: 200px;
        }

        .upgrade-box.current {
            border-color: var(--text-secondary);
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.8), rgba(20, 20, 30, 0.9));
        }

        .upgrade-box.next {
            border-color: var(--accent-gold);
            background: linear-gradient(135deg, rgba(40, 35, 20, 0.8), rgba(30, 25, 15, 0.9));
            box-shadow: 0 0 20px rgba(212, 160, 23, 0.2);
        }

        .upgrade-box-title {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .upgrade-box.current .upgrade-box-title {
            color: var(--text-secondary);
        }

        .upgrade-box.next .upgrade-box-title {
            color: var(--accent-gold);
        }

        .upgrade-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.9rem;
        }

        .upgrade-stat-row:last-child {
            border-bottom: none;
        }

        .upgrade-stat-label {
            color: var(--text-secondary);
        }

        .upgrade-stat-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        .upgrade-box.next .upgrade-stat-value {
            color: var(--accent-gold);
        }

        .upgrade-stat-increase {
            color: var(--rarity-uncommon);
            font-weight: 700;
        }

        .upgrade-arrow {
            font-size: 2.5rem;
            color: var(--accent-gold);
            text-align: center;
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        @keyframes arrowPulse {
            0%, 100% { transform: translateX(0); opacity: 1; }
            50% { transform: translateX(5px); opacity: 0.7; }
        }

        .upgrade-cost-section {
            background: var(--bg-primary);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .upgrade-cost-title {
            font-family: var(--font-display);
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .upgrade-cost-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 0.95rem;
        }

        .upgrade-cost-item.can-afford {
            color: var(--text-primary);
        }

        .upgrade-cost-item.cannot-afford {
            color: var(--rarity-mythic);
        }

        .upgrade-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .upgrade-actions button {
            flex: 1;
            padding: 15px;
            font-size: 1.1rem;
        }

        .btn-upgrade-confirm {
            background: var(--accent-gold) !important;
            color: black !important;
            font-weight: 700;
        }

        .btn-upgrade-confirm:hover {
            background: var(--accent-gold-bright) !important;
            box-shadow: 0 0 20px rgba(212, 160, 23, 0.5);
        }

        /* Toast Container */
        #toast-container { position: fixed; top: 60px; right: 20px; z-index: 1100; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: var(--bg-tertiary); border-left: 4px solid var(--accent-gold); padding: 12px 20px; border-radius: 4px; color: var(--text-primary); box-shadow: var(--shadow-base); animation: slideInX 0.3s ease forwards; min-width: 250px;}
        .toast.success { border-color: var(--rarity-uncommon); }
        .toast.error { border-color: var(--rarity-mythic); }
        .toast.rare { border-color: var(--rarity-legendary); font-weight: bold; }
        
        @keyframes slideInX { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Chest Opening Animations */
        @keyframes chestShake {
            0%, 100% { transform: rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: rotate(-10deg); }
            20%, 40%, 60%, 80% { transform: rotate(10deg); }
        }

        @keyframes chestGlow {
            0%, 100% { filter: drop-shadow(0 0 20px currentColor); transform: scale(1); }
            50% { filter: drop-shadow(0 0 50px currentColor); transform: scale(1.1); }
        }

        @keyframes rewardFadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes rarityPulse {
            0%, 100% { box-shadow: 0 0 10px currentColor; }
            50% { box-shadow: 0 0 30px currentColor, 0 0 50px currentColor; }
        }

        .chest-shake {
            animation: chestShake 0.5s ease-in-out;
        }

        .chest-opening-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 500px;
            margin: 0 auto;
        }

        .chest-opening-header {
            margin-bottom: 30px;
        }

        .chest-opening-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .chest-visual {
            animation: chestGlow 1s ease-in-out infinite;
            margin-bottom: 30px;
        }

        .chest-visual.legendary {
            filter: drop-shadow(0 0 50px #ffd700) hue-rotate(20deg);
            animation: chestGlow 0.8s ease-in-out infinite;
        }

        .chest-progress-bar {
            width: 100%;
            height: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid #444;
            margin-bottom: 15px;
        }

        .chest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-gold-bright));
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--accent-gold);
        }

        .chest-status-text {
            color: var(--text-secondary);
            font-size: 1rem;
            font-family: var(--font-display);
        }

        .chest-opened-header {
            font-family: var(--font-display);
            font-size: 1.8rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 25px;
            animation: rewardFadeIn 0.5s ease forwards;
        }

        .chest-rewards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            width: 100%;
            margin-bottom: 20px;
        }

        .chest-reward-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid #444;
            animation: rewardFadeIn 0.5s ease forwards;
            opacity: 0;
            min-width: 80px;
        }

        .chest-reward-item .reward-icon {
            font-size: 1.8rem;
            margin-bottom: 6px;
        }

        .chest-reward-item .reward-amount {
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 0.95rem;
            margin-bottom: 3px;
        }

        .chest-reward-item .reward-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .chest-items-section {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            width: 100%;
            padding: 15px;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid #444;
            margin-top: 10px;
        }

        .chest-item-card {
            background: var(--bg-tertiary);
            border: 2px solid;
            border-radius: 8px;
            padding: 12px;
            width: 120px;
            text-align: center;
            animation: rewardFadeIn 0.5s ease forwards;
            opacity: 0;
            position: relative;
        }

        .chest-item-card .item-rarity-badge {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-family: var(--font-display);
            font-weight: 700;
            color: white;
            text-transform: uppercase;
        }

        .chest-item-card .item-icon {
            font-size: 2rem;
            margin: 8px 0 5px;
        }

        .chest-item-card .item-name {
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 0.8rem;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chest-item-card .item-type {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .chest-actions {
            width: 100%;
            margin-top: 20px;
        }

        .chest-details-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .chest-details-icon {
            animation: chestGlow 2s ease-in-out infinite;
        }

        .chest-details-actions {
            display: flex;
            gap: 15px;
            width: 100%;
            margin-top: 20px;
        }

        .fade-in {
            animation: rewardFadeIn 0.5s ease forwards;
        }

        /* Crafting Reveal Animations */
        @keyframes pulseGlow { 0% { box-shadow: 0 0 10px rgba(255,255,255,0.2); } 50% { box-shadow: 0 0 30px rgba(255,255,255,0.5); } 100% { box-shadow: 0 0 10px rgba(255,255,255,0.2); } }
        @keyframes revealShake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        @keyframes scaleUpReveal { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
        
        .craft-reveal-container { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 300px; text-align: center; }
        .craft-silhoutte { width: 120px; height: 160px; background: #000; border-radius: 8px; margin: 20px auto; animation: pulseGlow 1.5s infinite; border: 2px dashed #444; }
        .craft-reveal-item { animation: scaleUpReveal 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .crafting-progress-bar { width: 100%; height: 8px; background: var(--bg-primary); border-radius: 4px; overflow: hidden; margin-top: 10px; border: var(--border-subtle); }
        .crafting-progress-fill { height: 100%; background: var(--accent-gold); width: 0%; transition: width 1s linear; }

        /* Procedural Pattern Item Card (Inventory Style) */
        .item-card {
            border: 2px solid #444; border-radius: 6px; overflow: hidden; position: relative; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s; background: var(--bg-tertiary); display:flex; flex-direction:column;
        }
        .item-card:hover { transform: translateY(-4px); box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .item-card-pattern { height: 80px; width: 100%; display: flex; justify-content: center; align-items: center; font-size: 2.5rem; text-shadow: 2px 2px 5px rgba(0,0,0,0.8); }
        .item-card-body { padding: 8px; font-size: 0.85rem; }
        .item-card-title { font-family: var(--font-display); font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px;}
        .mythic-glow { animation: pulseGlow 2s infinite alternate; border-color: var(--rarity-mythic) !important;}

        /* Enchanting Animations */
        @keyframes enchantSuccess { 0% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.2); filter: brightness(2) drop-shadow(0 0 20px var(--accent-gold-bright)); } 100% { transform: scale(1); filter: brightness(1); } }
        @keyframes enchantFail { 0% { transform: translateX(0); filter: grayscale(0); } 20%, 60% { transform: translateX(-10px); } 40%, 80% { transform: translateX(10px); } 100% { transform: translateX(0); filter: grayscale(0.8) drop-shadow(0 0 10px red); } }
        @keyframes enchantDestroy { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.5) rotate(15deg); filter: contrast(2) hue-rotate(90deg); opacity: 0.8; } 100% { transform: scale(0); opacity: 0; } }

        .anim-enchant-success { animation: enchantSuccess 1.5s ease; }
        .anim-enchant-fail { animation: enchantFail 1s ease; }
        .anim-enchant-destroy { animation: enchantDestroy 1.5s ease forwards; }

        /* Floating Damage Numbers */
        @keyframes floatUp { from { transform: translateY(0) scale(1); opacity: 1; } to { transform: translateY(-70px) scale(1.3); opacity: 0; } }
        .damage-float { position: absolute; font-family: var(--font-display); font-weight: 800; pointer-events: none; animation: floatUp 0.9s ease-out forwards; z-index: 50; text-shadow: 2px 2px 4px rgba(0,0,0,0.9); }
        .damage-float.normal { color: #fff; font-size: 1.4rem; }
        .damage-float.crit { color: var(--accent-gold-bright); font-size: 2rem; }
        .damage-float.power { color: var(--rarity-mythic); font-size: 2.4rem; }

        /* Screen Shake & Hero Damage Flash */
        @keyframes screenShake { 0%,100% { transform:translateX(0); } 20% { transform:translateX(-6px); } 40% { transform:translateX(6px); } 60% { transform:translateX(-4px); } 80% { transform:translateX(4px); } }
        .screen-shake { animation: screenShake 0.35s ease-out; }
        @keyframes redEdgeFlash { 0% { opacity:0; } 30% { opacity:0.55; } 100% { opacity:0; } }
        #hero-damage-flash { position:fixed; top:0;left:0;width:100%;height:100%; background:radial-gradient(circle at center, transparent 35%, rgba(220,0,0,0.4) 100%); pointer-events:none; z-index:998; opacity:0; animation:none; }
        #hero-damage-flash.flash { animation: redEdgeFlash 0.5s ease forwards; }

        /* Achievement Toast */
        .toast.achievement { border-color: var(--accent-gold-bright); background: rgba(212,160,23,0.15); font-size: 1rem; font-weight: bold; min-width: 300px; }

        /* Power Strike Screen Flash */
        @keyframes screenFlash { 0% { opacity: 0; } 30% { opacity: 0.4; } 100% { opacity: 0; } }
        #power-flash { position: fixed; top:0; left:0; width:100%; height:100%; background: var(--rarity-mythic); pointer-events: none; z-index: 999; opacity: 0; animation: none; }
        #power-flash.flash { animation: screenFlash 0.4s ease forwards; }

        /* === TURN-BASED BATTLE ANIMATIONS === */
        @keyframes turnSlideIn { from { opacity:0; transform:translateX(-50%) scale(0.5); } to { opacity:1; transform:translateX(-50%) scale(1); } }
        @keyframes turnSlideOut { from { opacity:1; transform:translateX(-50%) scale(1); } to { opacity:0; transform:translateX(-50%) scale(1.4); } }
        .turn-indicator-overlay {
            position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            font-family:var(--font-display); font-size:1.6rem; font-weight:800;
            padding:12px 35px; border-radius:10px; z-index:100; pointer-events:none;
            animation: turnSlideIn 0.3s ease-out forwards; white-space:nowrap;
        }
        .turn-indicator-overlay.player { color:#fff; background:rgba(0,180,70,0.9); border:2px solid var(--accent-success); text-shadow: 0 0 10px rgba(0,255,136,0.8); box-shadow: 0 0 30px rgba(0,255,136,0.5); }
        .turn-indicator-overlay.enemy  { color:#fff; background:rgba(180,0,0,0.9); border:2px solid var(--accent-danger);  text-shadow: 0 0 10px rgba(255,68,68,0.8); box-shadow: 0 0 30px rgba(255,68,68,0.5); }
        .turn-indicator-overlay.fade-out { animation: turnSlideOut 0.3s ease-in forwards; }

        @keyframes heroHitFlash { 0%,100% { filter:none; } 30% { filter: brightness(2.5) saturate(0) sepia(1) hue-rotate(300deg); } 60% { filter: brightness(1.5); } }
        .hero-hit-flash { animation: heroHitFlash 0.45s ease-out; }

        @keyframes enemyLunge { 0% { transform:scale(1) translateX(0); } 40% { transform:scale(1.25) translateX(28px); } 100% { transform:scale(1) translateX(0); } }
        .enemy-lunge { animation: enemyLunge 0.5s ease-in-out; }

        @keyframes shieldAura { 0%,100% { box-shadow:0 0 0 transparent; } 50% { box-shadow:0 0 22px 8px rgba(0,150,255,0.55); } }
        .defending-aura { animation: shieldAura 1s ease-in-out infinite; border:2px solid #00ccff !important; background:rgba(0,100,255,0.1) !important; }

        .combat-btn.locked { opacity:0.38; pointer-events:none !important; cursor:not-allowed; }
        .diff-nightmare { border-color: var(--rarity-mythic); background: rgba(139,0,0,0.1); }

        /* Equipment Slot Styles */
        .equip-slot { border: 2px dashed #444; border-radius: 6px; padding: 10px; text-align: center; min-height: 70px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: border-color 0.2s; }
        .equip-slot:hover { border-color: var(--accent-gold); }
        .equip-slot.filled { border-style: solid; background: var(--bg-primary); }

        /* ===========================
           NEW COMBAT UI STYLES
           =========================== */
        .combat-arena {
            background: linear-gradient(to bottom, #1a0a0f, #0a0a0f);
            border: 2px solid var(--accent-crimson);
            border-radius: 16px;
            padding: 25px;
            max-width: 900px;
            margin: 0 auto;
            box-shadow: inset 0 0 50px rgba(139, 0, 0, 0.3), 0 0 30px rgba(0,0,0,0.8), 0 0 60px rgba(139, 0, 0, 0.2);
        }

        .combat-header {
            text-align: center;
            margin-bottom: 20px;
        }

        /* Battle Field Layout - Side by Side */
        .battle-field {
            display: grid;
            grid-template-columns: 1fr 120px 1fr;
            gap: 15px;
            align-items: stretch;
            margin-bottom: 20px;
        }

        /* Player & Enemy Panels */
        .player-panel, .enemy-panel {
            background: linear-gradient(to bottom, rgba(20, 20, 30, 0.9), rgba(10, 10, 15, 0.95));
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .player-panel {
            border: 2px solid rgba(0, 200, 100, 0.4);
            box-shadow: 0 0 20px rgba(0, 200, 100, 0.2), inset 0 0 30px rgba(0, 100, 50, 0.1);
        }

        .player-panel:hover {
            border-color: rgba(0, 255, 136, 0.6);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3), inset 0 0 40px rgba(0, 150, 75, 0.15);
        }

        .enemy-panel {
            border: 2px solid rgba(255, 50, 50, 0.4);
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.2), inset 0 0 30px rgba(100, 0, 0, 0.1);
        }

        .enemy-panel:hover {
            border-color: rgba(255, 100, 100, 0.6);
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.3), inset 0 0 40px rgba(150, 0, 0, 0.15);
        }

        /* VS Zone - Center */
        .vs-zone {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .vs-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(212, 160, 23, 0.3) 0%, rgba(139, 0, 0, 0.5) 70%);
            border: 3px solid var(--accent-gold);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-display);
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent-gold);
            text-shadow: 0 0 10px rgba(212, 160, 23, 0.8);
            box-shadow: 0 0 30px rgba(212, 160, 23, 0.5), inset 0 0 20px rgba(212, 160, 23, 0.3);
            animation: vsPulse 2s ease-in-out infinite;
        }

        @keyframes vsPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(212, 160, 23, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 50px rgba(212, 160, 23, 0.8); }
        }

        .vs-turn-indicator {
            margin-top: 10px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Character/Enemy Display */
        .character-display {
            text-align: center;
            margin: 15px 0;
            position: relative;
        }

        .character-sprite {
            font-size: 5rem;
            filter: drop-shadow(0 0 15px currentColor);
            transition: all 0.3s ease;
            display: inline-block;
        }

        .player-panel .character-sprite {
            color: rgba(0, 255, 136, 0.5);
        }

        .enemy-panel .character-sprite {
            color: rgba(255, 50, 50, 0.5);
            filter: drop-shadow(0 0 20px rgba(255, 0, 0, 0.6));
        }

        .character-name {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: 700;
            margin: 10px 0 5px;
            color: var(--accent-gold);
        }

        .character-level {
            display: inline-block;
            background: rgba(212, 160, 23, 0.15);
            border: 1px solid var(--accent-gold);
            border-radius: 8px;
            padding: 2px 10px;
            font-size: 0.8rem;
            color: var(--accent-gold);
            font-family: var(--font-display);
        }

        .enemy-ability-icon {
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 2rem;
            cursor: help;
            filter: drop-shadow(0 0 10px rgba(255, 170, 0, 0.6));
            animation: abilityGlow 1.5s ease-in-out infinite;
        }

        @keyframes abilityGlow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(255, 170, 0, 0.6)); }
            50% { filter: drop-shadow(0 0 20px rgba(255, 170, 0, 1)); }
        }

        /* Stats Panel */
        .stats-panel {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            border: 1px solid #333;
        }

        .stats-row {
            display: flex;
            justify-content: space-around;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-icon {
            font-size: 1.1rem;
        }

        /* Equipment Display */
        .equipment-display {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 10px;
            font-size: 1.2rem;
        }

        .equip-item {
            width: 32px;
            height: 32px;
            background: rgba(212, 160, 23, 0.1);
            border: 1px solid rgba(212, 160, 23, 0.3);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
        }

        /* Health Bars */
        .health-bar-container {
            width: 100%;
            height: 28px;
            background: var(--bg-primary);
            border-radius: 14px;
            overflow: hidden;
            border: 2px solid #444;
            position: relative;
            margin: 10px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }

        .health-bar-fill {
            height: 100%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .health-bar-fill.enemy-hp {
            background: linear-gradient(to right, #8b0000, #ff4444, #ff6666);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.6);
        }

        .health-bar-fill.hero-hp {
            background: linear-gradient(to right, #006600, #00cc44, #00ff88);
            box-shadow: 0 0 15px rgba(0, 204, 68, 0.6);
        }

        .health-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: var(--font-display);
            font-size: 0.85rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.5);
            z-index: 2;
            white-space: nowrap;
        }

        /* Combat Actions */
        .combat-actions {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .combat-btn {
            padding: 14px 8px;
            border-radius: 10px;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .combat-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.15), transparent);
            transform: rotate(45deg);
            transition: left 0.5s ease;
        }

        .combat-btn:hover::before {
            left: 100%;
        }

        .combat-btn small {
            display: block;
            margin-top: 4px;
            font-size: 0.65rem;
            opacity: 0.75;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Attack Type Buttons */
        .btn-quick {
            background: linear-gradient(to bottom, #0066aa, #004477);
            border: 2px solid #00ccff;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 150, 255, 0.4);
        }
        .btn-quick:hover { 
            background: linear-gradient(to bottom, #0088cc, #0066aa); 
            box-shadow: 0 6px 20px rgba(0, 180, 255, 0.6); 
            transform: translateY(-2px); 
        }

        .btn-normal {
            background: linear-gradient(to bottom, #6a1b9a, #4a1478);
            border: 2px solid #ab47bc;
            color: white;
            box-shadow: 0 4px 15px rgba(150, 50, 200, 0.4);
        }
        .btn-normal:hover { 
            background: linear-gradient(to bottom, #8e24aa, #6a1b9a); 
            box-shadow: 0 6px 20px rgba(170, 50, 200, 0.6); 
            transform: translateY(-2px); 
        }

        .btn-heavy {
            background: linear-gradient(to bottom, #c62828, #8e1a1a);
            border: 2px solid #ef5350;
            color: white;
            box-shadow: 0 4px 15px rgba(255, 50, 50, 0.4);
        }
        .btn-heavy:hover { 
            background: linear-gradient(to bottom, #d32f2f, #c62828); 
            box-shadow: 0 6px 20px rgba(255, 80, 80, 0.6); 
            transform: translateY(-2px); 
        }

        .btn-defend {
            background: linear-gradient(to bottom, #1b5e20, #0d3d12);
            border: 2px solid #4caf50;
            color: white;
            box-shadow: 0 4px 15px rgba(50, 200, 50, 0.4);
        }
        .btn-defend:hover {
            background: linear-gradient(to bottom, #2e7d32, #1b5e20);
            box-shadow: 0 6px 20px rgba(80, 220, 80, 0.6);
            transform: translateY(-2px);
        }

        .btn-flee {
            background: linear-gradient(to bottom, #424242, #212121);
            border: 2px solid #757575;
            color: #bdbdbd;
            box-shadow: 0 4px 15px rgba(100, 100, 100, 0.3);
        }
        .btn-flee:hover {
            background: linear-gradient(to bottom, #616161, #424242);
            box-shadow: 0 6px 20px rgba(150, 150, 150, 0.5);
            transform: translateY(-2px);
            color: white;
        }

        /* Combat Log */
        .combat-log {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            max-height: 140px;
            overflow-y: auto;
            font-size: 0.85rem;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        .combat-log-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(50, 50, 50, 0.5);
        }

        .combat-log-entry:last-child {
            border-bottom: none;
        }

        .log-crit { color: var(--accent-gold-bright); font-weight: bold; text-shadow: 0 0 8px rgba(255, 200, 50, 0.5); }
        .log-power { color: var(--rarity-mythic); font-weight: bold; text-shadow: 0 0 10px rgba(255, 0, 0, 0.6); }
        .log-damage { color: #ff6666; }
        .log-heal { color: var(--accent-success); }
        .log-info { color: var(--text-secondary); }
        .log-turn { color: var(--accent-gold); font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }

        /* ===========================
           NEW INVENTORY UI STYLES
           =========================== */
        .inventory-container {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--accent-gold);
        }

        .inventory-title {
            font-family: var(--font-display);
            font-size: 1.5rem;
            color: var(--accent-gold);
        }

        .inventory-count {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .inventory-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .inv-tab {
            padding: 10px 20px;
            border-radius: 8px;
            background: var(--bg-secondary);
            border: 1px solid #444;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-display);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .inv-tab:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .inv-tab.active {
            background: var(--accent-gold);
            color: black;
            border-color: var(--accent-gold-bright);
            box-shadow: 0 0 15px rgba(212, 160, 23, 0.4);
        }

        .inventory-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 8px 15px;
            background: var(--bg-tertiary);
            border: 1px solid #444;
            border-radius: 6px;
            color: var(--text-primary);
            font-family: var(--font-body);
            cursor: pointer;
            outline: none;
        }

        .filter-select:focus {
            border-color: var(--accent-gold);
        }

        .inventory-grid {
            display: grid;
            /* FIX #23: Use CSS variable for consistent item width with VirtualScroller */
            grid-template-columns: repeat(auto-fill, minmax(var(--grid-item-width), 1fr));
            gap: var(--grid-gap);
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid #333;
            min-height: 400px;
        }

        .inv-item-card {
            aspect-ratio: 1;
            border: 2px solid #444;
            border-radius: 8px;
            background: var(--bg-tertiary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .inv-item-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.05), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .inv-item-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .inv-item-card:hover::before {
            opacity: 1;
        }

        .inv-item-card.common { border-color: var(--rarity-common); }
        .inv-item-card.uncommon { border-color: var(--rarity-uncommon); box-shadow: 0 0 10px rgba(30, 255, 0, 0.2); }
        .inv-item-card.rare { border-color: var(--rarity-rare); box-shadow: 0 0 15px rgba(0, 112, 221, 0.3); }
        .inv-item-card.epic { border-color: var(--rarity-epic); box-shadow: 0 0 20px rgba(163, 53, 238, 0.4); }
        .inv-item-card.legendary { border-color: var(--rarity-legendary); box-shadow: 0 0 25px rgba(255, 128, 0, 0.5); }
        .inv-item-card.mythic { 
            border-color: var(--rarity-mythic); 
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: mythicPulse 2s infinite alternate;
        }

        @keyframes mythicPulse {
            from { box-shadow: 0 0 20px rgba(255, 0, 0, 0.4); }
            to { box-shadow: 0 0 40px rgba(255, 0, 0, 0.8); }
        }

        .inv-item-icon {
            font-size: 2.5rem;
            margin-bottom: 5px;
            z-index: 1;
        }

        .inv-item-enchant {
            font-family: var(--font-display);
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent-gold);
            z-index: 1;
        }

        .inv-item-rarity {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 0.6rem;
            text-transform: uppercase;
            opacity: 0.7;
            z-index: 1;
        }

        /* Selected item in enchant view */
        .selected-item {
            box-shadow: 0 0 20px rgba(212, 160, 23, 0.6) !important;
            transform: translateY(-6px) !important;
        }

        .inventory-action-bar {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid #444;
        }

        .inv-action-btn {
            flex: 1;
            padding: 12px;
            border-radius: 6px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-equip { background: var(--accent-success); color: black; border: 2px solid #00ff88; }
        .btn-equip:hover { background: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.5); }

        .btn-details { background: var(--accent-info); color: black; border: 2px solid #00ccff; }
        .btn-details:hover { background: var(--accent-info); box-shadow: 0 0 15px rgba(0, 204, 255, 0.5); }

        .btn-sell { background: var(--accent-gold); color: black; border: 2px solid var(--accent-gold-bright); }
        .btn-sell:hover { background: var(--accent-gold-bright); box-shadow: 0 0 15px rgba(240, 192, 64, 0.5); }

        .btn-discard { background: var(--bg-tertiary); color: var(--text-secondary); border: 2px solid #444; }
        .btn-discard:hover { background: #333; border-color: #666; }

        /* ===========================
           NEW ENCHANT UI STYLES
           =========================== */
        .enchant-chamber {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }

        .enchant-item-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(to bottom, #1a1a2e, #0a0a0f);
            border: 2px solid var(--accent-purple);
            border-radius: 12px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .enchant-item-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(106, 13, 173, 0.2), transparent);
            animation: enchantRotate 10s linear infinite;
        }

        @keyframes enchantRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .enchant-item-card {
            position: relative;
            z-index: 1;
            display: inline-block;
            animation: enchantFloat 3s ease-in-out infinite;
        }

        @keyframes enchantFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        .enchant-progress-track {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid #444;
        }

        .enchant-level-node {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-weight: bold;
            font-size: 0.9rem;
            position: relative;
        }

        .enchant-level-node.completed {
            background: var(--accent-success);
            border-color: var(--accent-success);
            color: black;
        }

        .enchant-level-node.current {
            background: var(--accent-gold);
            border-color: var(--accent-gold-bright);
            color: black;
            box-shadow: 0 0 20px rgba(212, 160, 23, 0.6);
            animation: pulseGlow 1s infinite alternate;
        }

        .enchant-level-node.locked {
            opacity: 0.4;
        }

        .enchant-level-line {
            flex: 1;
            height: 3px;
            background: #444;
            margin: 0 5px;
        }

        .enchant-level-line.completed {
            background: var(--accent-success);
        }

        .enchant-stats {
            background: var(--bg-secondary);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .enchant-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .enchant-stat-row:last-child {
            border-bottom: none;
        }

        .enchant-chance {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .enchant-chance.high { color: var(--accent-success); }
        .enchant-chance.medium { color: var(--accent-warning); }
        .enchant-chance.low { color: var(--accent-danger); }

        .enchant-cost {
            color: var(--accent-gold);
        }

        .enchant-risk {
            background: rgba(139, 0, 0, 0.2);
            border-left: 3px solid var(--accent-danger);
            padding: 10px 15px;
            border-radius: 4px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .enchant-risk-title {
            color: var(--accent-danger);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .enchant-protection {
            background: rgba(0, 204, 255, 0.1);
            border: 1px solid var(--accent-info);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .enchant-protection-title {
            color: var(--accent-info);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .enchant-protection-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .btn-enchant {
            width: 100%;
            padding: 18px;
            font-size: 1.2rem;
            background: linear-gradient(to bottom, var(--accent-purple), #4a0a6e);
            border: 2px solid var(--accent-purple);
            color: white;
            border-radius: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(106, 13, 173, 0.4);
            transition: all 0.3s ease;
        }

        .btn-enchant:hover:not(:disabled) {
            background: linear-gradient(to bottom, #8a2be2, var(--accent-purple));
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.6);
            transform: translateY(-2px);
        }

        .btn-enchant:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .enchant-history {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid #333;
        }

        .enchant-history-title {
            font-family: var(--font-display);
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .enchant-history-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .enchant-history-entry {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #222;
            font-size: 0.85rem;
        }

        .enchant-history-entry:last-child {
            border-bottom: none;
        }

        .enchant-success-entry { color: var(--accent-success); }
        .enchant-fail-entry { color: var(--accent-danger); }

        /* Slide-in Panel */
        .slide-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .slide-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .slide-panel {
            position: fixed;
            top: 0;
            right: -500px;
            width: 450px;
            max-width: 90vw;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 2px solid var(--accent-gold);
            z-index: 1000;
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            box-shadow: -10px 0 50px rgba(0, 0, 0, 0.8);
        }

        .slide-panel.active {
            right: 0;
        }

        .slide-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            background: var(--bg-tertiary);
        }

        .slide-panel-title {
            font-family: var(--font-display);
            font-size: 1.3rem;
            color: var(--accent-gold);
        }

        .slide-panel-close {
            background: none;
            border: none;
            font-size: 2rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .slide-panel-close:hover {
            color: var(--text-primary);
            background: none;
            box-shadow: none;
        }

        .slide-panel-content {
            padding: 20px;
        }

        /* Nav Badge */
        .nav-badge {
            position: absolute;
            top: 5px;
            right: 10px;
            background: var(--accent-danger);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
            pointer-events: none;
        }

        .nav-item {
            position: relative;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .combat-actions {
                grid-template-columns: 1fr 1fr;
            }
            
            .btn-attack {
                grid-column: 1 / -1;
            }

            .inventory-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
            }

            .inv-item-icon {
                font-size: 2rem;
            }

            .enchant-progress-track {
                overflow-x: auto;
            }
        }

        /* Quest Items */
        .quest-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-radius: 6px; background: var(--bg-secondary); margin-bottom: 8px; border-left: 3px solid #444; }
        .quest-item.done { border-left-color: var(--rarity-uncommon); opacity: 0.7; }
        .quest-item.active { border-left-color: var(--accent-gold); }

        /* Leaderboard */
        .lb-row { display: flex; align-items: center; gap: 10px; padding: 8px 12px; border-bottom: var(--border-subtle); font-size: 0.9rem; }
        .lb-row.me { background: rgba(212,160,23,0.1); border-radius: 4px; }
        .lb-rank { font-family: var(--font-display); font-weight: bold; min-width: 30px; }
        .lb-tabs { display: flex; gap: 5px; margin-bottom: 15px; }
        .lb-tab { padding: 6px 14px; border-radius: 4px; cursor: pointer; font-size: 0.85rem; }
        .lb-tab.active { background: var(--accent-gold); color: black; }

        /* Visual Town Simulation Styles */
        .town-map {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 20px;
            position: relative;
            background: linear-gradient(to bottom, #1a2a1a, #0a1a0f); /* Subtle grass tint */
            border-radius: 12px;
            border: 2px solid #2a4a2a;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
            min-height: 400px;
        }

        .town-building {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 20px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .town-building:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: var(--accent-gold);
            box-shadow: 0 10px 25px rgba(212, 160, 23, 0.3);
            background: rgba(30, 30, 30, 0.8);
        }

        .town-building::before {
            content: ''; position: absolute; top:0; left:0; right:0; height: 30%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.05), transparent);
            pointer-events: none;
        }

        .b-icon { font-size: 3.5rem; margin-bottom: 15px; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.8)); transition: transform 0.3s; }
        .town-building:hover .b-icon { transform: scale(1.1); }
        
        .b-name { font-family: var(--font-display); font-size: 1.1rem; color: var(--text-primary); font-weight: bold; margin-bottom: 5px; z-index: 1;}
        .b-level { font-size: 0.85rem; color: var(--accent-gold); background: rgba(0,0,0,0.8); padding: 3px 10px; border-radius: 12px; border: 1px solid var(--accent-gold); z-index: 1;}

        /* Visual Building Upgrades (Level Tiers) */
        .tier-1 { border-bottom: 4px solid #888; }
        .tier-2 { border-bottom: 4px solid var(--rarity-uncommon); }
        .tier-3 { border-bottom: 4px solid var(--rarity-rare); }
        .tier-4 { border-bottom: 4px solid var(--rarity-epic); }
        .tier-5 { border-bottom: 5px solid var(--rarity-mythic); box-shadow: inset 0 0 20px rgba(255,0,0,0.2); }

        /* Category Selection Styles */
        .category-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            padding: 20px;
            margin-top: 20px;
        }

        .category-card {
            position: relative;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.9), rgba(15, 15, 25, 0.95));
            border: 2px solid #444;
            border-radius: 16px;
            padding: 30px 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            min-height: 220px;
        }

        .category-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at top right, rgba(255,255,255,0.08), transparent 60%);
            pointer-events: none;
            opacity: 0.5;
        }

        .category-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: currentColor;
            opacity: 0.7;
        }

        .category-card:hover {
            transform: translateY(-8px) scale(1.03);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), 0 0 30px rgba(212, 160, 23, 0.2);
            background: linear-gradient(135deg, rgba(35, 35, 50, 0.95), rgba(20, 20, 35, 0.98));
        }

        .category-icon {
            font-size: 4.5rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 5px 10px rgba(0,0,0,0.8));
            transition: transform 0.3s;
        }

        .category-card:hover .category-icon {
            transform: scale(1.15) rotate(5deg);
        }

        .category-name {
            font-family: var(--font-display);
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .category-desc {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .category-count {
            font-size: 0.85rem;
            color: var(--accent-gold);
            background: rgba(212, 160, 23, 0.15);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid rgba(212, 160, 23, 0.4);
            font-family: var(--font-display);
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Responsive constraints */
        @media (max-width: 1024px) {
            #game-container { grid-template-columns: 1fr; grid-template-areas: "top" "main" "bottom"; }
            #right-panel { display: none; } /* Handle toggle later */
        }
        @media (max-width: 768px) {
            .town-map { grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 10px; }
        }

        /* === FLOATING CHAT BUTTON (FAB) === */
        .chat-fab {
            position: fixed;
            bottom: 80px;
            right: 25px;
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-bright));
            border: 3px solid #fff;
            box-shadow: 0 4px 20px rgba(212, 160, 23, 0.5), 0 0 30px rgba(212, 160, 23, 0.3);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            z-index: 998;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: fabPulse 2s ease-in-out infinite;
        }

        .chat-fab:hover {
            transform: scale(1.15);
            box-shadow: 0 6px 30px rgba(212, 160, 23, 0.7), 0 0 40px rgba(212, 160, 23, 0.5);
            animation: none;
        }

        .chat-fab:active {
            transform: scale(0.95);
        }

        @keyframes fabPulse {
            0%, 100% { box-shadow: 0 4px 20px rgba(212, 160, 23, 0.5), 0 0 30px rgba(212, 160, 23, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(212, 160, 23, 0.7), 0 0 45px rgba(212, 160, 23, 0.5); }
        }

        .chat-fab-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--accent-danger);
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
            padding: 3px 7px;
            border-radius: 10px;
            min-width: 22px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
            border: 2px solid #fff;
        }

        /* Dev Mode Indicator */
        .dev-mode-indicator {
            position: fixed;
            top: 60px;
            left: 10px;
            background: linear-gradient(135deg, var(--rarity-mythic), #8b0000);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-family: var(--font-display);
            font-size: 0.85rem;
            font-weight: 700;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(255, 0, 0, 0.5), 0 0 15px rgba(255, 0, 0, 0.3);
            border: 2px solid rgba(255, 100, 100, 0.5);
            animation: devPulse 2s ease-in-out infinite;
            cursor: pointer;
        }

        .dev-mode-indicator:hover {
            transform: scale(1.05);
        }

        @keyframes devPulse {
            0%, 100% { box-shadow: 0 4px 20px rgba(255, 0, 0, 0.5), 0 0 15px rgba(255, 0, 0, 0.3); }
            50% { box-shadow: 0 4px 30px rgba(255, 0, 0, 0.8), 0 0 25px rgba(255, 0, 0, 0.5); }
        }

        /* === CHAT SIDE PANEL === */
        .chat-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 998;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .chat-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .chat-side-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 400px;
            max-width: 90vw;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 3px solid var(--accent-gold);
            z-index: 999;
            transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: -10px 0 50px rgba(0, 0, 0, 0.8), -5px 0 30px rgba(212, 160, 23, 0.3);
            display: flex;
            flex-direction: column;
        }

        .chat-side-panel.active {
            right: 0;
        }

        .chat-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: linear-gradient(to right, var(--bg-tertiary), var(--bg-secondary));
            border-bottom: 2px solid var(--accent-gold);
        }

        .chat-panel-title {
            font-family: var(--font-display);
            font-size: 1.3rem;
            color: var(--accent-gold);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-panel-close {
            background: none;
            border: none;
            font-size: 2rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .chat-panel-close:hover {
            background: rgba(212, 160, 23, 0.15);
            color: var(--accent-gold);
            transform: rotate(90deg);
        }

        .chat-panel-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
        }

        .chat-panel-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-panel-messages::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        .chat-panel-messages::-webkit-scrollbar-thumb {
            background: var(--accent-gold);
            border-radius: 4px;
        }

        .chat-panel-input {
            padding: 15px;
            background: var(--bg-tertiary);
            border-top: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-channel-select {
            display: flex;
            gap: 8px;
        }

        .chat-channel-btn {
            flex: 1;
            padding: 8px 15px;
            border-radius: 6px;
            background: var(--bg-primary);
            border: 1px solid #444;
            color: var(--text-secondary);
            cursor: pointer;
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .chat-channel-btn.active {
            background: var(--accent-gold);
            color: black;
            border-color: var(--accent-gold);
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
        }

        .chat-input-row input {
            flex: 1;
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #444;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 0.9rem;
        }

        .chat-input-row input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .chat-send-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-bright));
            color: black;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            font-family: var(--font-display);
            text-transform: uppercase;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(212, 160, 23, 0.5);
        }

        .chat-send-btn:active {
            transform: scale(0.95);
        }

        /* Chat Message Styles */
        .chat-message {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: rgba(30, 30, 40, 0.6);
            border-radius: 8px;
            border-left: 3px solid #444;
            animation: slideInLeft 0.3s ease;
        }

        .chat-message.system {
            border-left-color: var(--accent-gold);
            background: rgba(212, 160, 23, 0.1);
        }

        .chat-message.trade {
            border-left-color: var(--accent-info);
        }

        @keyframes slideInLeft {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .chat-msg-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .chat-msg-author {
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--accent-gold);
            font-size: 0.85rem;
        }

        .chat-msg-time {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .chat-msg-text {
            color: var(--text-primary);
            font-size: 0.9rem;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .chat-empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .chat-fab {
                bottom: 70px;
                right: 15px;
                width: 55px;
                height: 55px;
                font-size: 1.5rem;
            }

            .chat-side-panel {
                width: 85vw;
                right: -85vw;
            }
        }
    </style>
</head>
<body>

    <div id="game-container" class="hidden">
        <!-- TOP BAR -->
        <header id="top-bar" role="banner">
            <h2 class="text-gold" style="margin-bottom:0; cursor:pointer;" onclick="UI.switchView('town')" aria-label="Realm Tycoon Ana Sayfa">Realm Tycoon</h2>

            <div class="resources-container" id="top-resources" style="display: flex; gap: 20px; align-items: center;" role="list" aria-label="Kaynaklar">
                <div class="resource-item" title="Gold" role="listitem"><span class="icon"></span> <span id="res-gold" class="text-gold">0</span></div>
                <div class="resource-item" title="Iron" role="listitem"><span class="icon"></span> <span id="res-iron">0</span></div>
                <div class="resource-item" title="Wood" role="listitem"><span class="icon"></span> <span id="res-wood">0</span></div>
                <div class="resource-item" title="Crystal" role="listitem"><span class="icon"></span> <span id="res-crystal">0</span></div>
                <div class="resource-item" title="Gems" role="listitem"><span class="icon"></span> <span id="res-gems" class="text-gold">0</span></div>
                <div class="resource-item" title="Kahraman Can  Sava dnda 15sn'de 1 HP regen" id="hero-hp-resource" style="border-left:1px solid #333; padding-left:12px; margin-left:4px;" role="listitem">
                    <span class="icon"></span>
                    <span id="hero-hp-topbar" style="color:var(--accent-danger);">100/100</span>
                </div>
            </div>

            <div style="display:flex; gap:15px; align-items:center; margin-right:15px;">
                <div id="level-display" style="text-align:right;" aria-label="Seviye ve Tecrbe">
                    <div style="font-family:var(--font-display); font-weight:bold; color:var(--accent-gold); font-size:0.9rem;">
                        <span id="player-level">1</span>. Seviye
                    </div>
                    <div style="width:120px; height:6px; background:#333; border-radius:3px; overflow:hidden; margin-top:2px;" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Tecrbe ubuu">
                        <div id="xp-progress" style="height:100%; background:linear-gradient(to right, var(--accent-gold), var(--accent-gold-bright)); width:0%; transition:width 0.3s;"></div>
                    </div>
                    <div style="font-size:0.65rem; color:var(--text-secondary);"><span id="xp-current">0</span>/<span id="xp-required">100</span> XP</div>
                </div>
            </div>

            <div style="display:flex; gap:15px; align-items:center;">
                <div id="player-profile-summary" style="font-weight:bold; cursor:pointer" class="text-gold" onclick="UI.showSettings()" role="button" tabindex="0" aria-label="Oyuncu profili ve ayarlar">PlayerName</div>
                <button id="btn-settings" class="btn-icon" onclick="UI.showSettings()" style="background:none; border:none; font-size:1.2rem; cursor:pointer;" aria-label="Ayarlar"></button>
            </div>
        </header>

        <!-- MAIN VIEW AREA -->
        <main id="main-view" role="main" aria-label="Ana Oyun Alan">
            <!-- Town Hub -->
            <div id="view-town" class="view-section">
                <h1 id="view-title" class="text-gold" style="text-align: center; margin-bottom: 20px; font-size: 2.2rem;">Kingdom Overview</h1>
                <div id="view-container">
                    <!-- Dynamic content -->
                </div>
            </div>

            <!-- Full Inventory -->
            <div id="view-inventory" class="view-section hidden">
                <div class="inventory-container">
                    <div class="inventory-header">
                        <span class="inventory-title"> Srt antas</span>
                        <span class="inventory-count" id="inventory-count-display">0/100</span>
                    </div>

                    <!-- Category Tabs -->
                    <div class="inventory-tabs">
                        <button class="inv-tab active" onclick="InventorySystem.setFilter('all')">Tm</button>
                        <button class="inv-tab" onclick="InventorySystem.setFilter('weapon')"> Silahlar</button>
                        <button class="inv-tab" onclick="InventorySystem.setFilter('armor')"> Zrhlar</button>
                        <button class="inv-tab" onclick="InventorySystem.setFilter('ring')"> Yzkler</button>
                        <button class="inv-tab" onclick="InventorySystem.setFilter('amulet')"> Tlsmlar</button>
                    </div>

                    <!-- Filters -->
                    <div class="inventory-filters">
                        <select class="filter-select" onchange="InventorySystem.setSort(this.value)">
                            <option value="newest">En Yeni</option>
                            <option value="rarity">Nadirlie Gre</option>
                            <option value="enchant">By Seviyesi</option>
                        </select>
                    </div>

                    <!-- Item Grid -->
                    <div id="inventory-grid-full" class="inventory-grid">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>

            <!-- Hero/Stats Sanctum -->
            <div id="view-hero" class="view-section hidden">
                <h1 class="text-gold" style="text-align: center; margin-bottom: 30px; font-size: 2.2rem;">Kahraman Mabedi</h1>
                <div id="hero-view-content" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                    <!-- Dynamic content -->
                </div>
            </div>
        </main>

        <!-- BOTTOM NAVIGATION -->
        <footer id="bottom-bar" role="contentinfo">
            <!-- Navigation Icons -->
            <nav class="nav-bar" role="navigation" aria-label="Ana Navigasyon">
                <div class="nav-item active" onclick="UI.switchView('town')" id="nav-town" role="button" tabindex="0" aria-label="Harita grnmne git">
                    <span class="nav-icon"></span>
                    <span class="nav-label">Harita</span>
                </div>
                <div class="nav-item" onclick="UI.switchView('inventory')" id="nav-inventory" role="button" tabindex="0" aria-label="Envanter grnmne git">
                    <span class="nav-icon"></span>
                    <span class="nav-label">Envanter</span>
                    <span class="nav-badge" id="nav-badge-inventory" style="display:none;" aria-label="Yeni eya bildirimi">0</span>
                </div>
                <div class="nav-item" onclick="UI.switchView('hero')" id="nav-hero" role="button" tabindex="0" aria-label="Kahraman grnmne git">
                    <span class="nav-icon"></span>
                    <span class="nav-label">Kahraman</span>
                </div>
                <div class="nav-item" onclick="MarketplaceSystem.openMarket()" id="nav-market" role="button" tabindex="0" aria-label="Pazar grnmne git">
                    <span class="nav-icon"></span>
                    <span class="nav-label">Pazar</span>
                </div>
            </nav>
        </footer>
    </div>

    <!-- MODAL -->
    <div id="modal-container">
        <div class="modal-content" id="modal-body">
            <!-- Modal inner content injected here -->
        </div>
    </div>

    <!-- TOASTS -->
    <div id="toast-container"></div>
    <!-- Power Strike Flash Overlay -->
    <div id="power-flash"></div>
    <!-- Hero Damage Flash Overlay -->
    <div id="hero-damage-flash"></div>

    <!-- CHAT FLOATING BUTTON -->
    <button id="chat-fab" class="chat-fab" onclick="ChatSystem.togglePanel()" title="Sohbet (C)" aria-label="Sohbet penceresini a veya kapat" aria-expanded="false">
        
        <span id="chat-fab-badge" class="chat-fab-badge" style="display:none;" aria-label="Okunmam mesaj says">0</span>
    </button>

    <!-- CHAT SIDE PANEL -->
    <div id="chat-panel-overlay" class="chat-panel-overlay" onclick="ChatSystem.togglePanel()" aria-hidden="true"></div>
    <div id="chat-side-panel" class="chat-side-panel" role="dialog" aria-modal="true" aria-labelledby="chat-panel-title" aria-label="Sohbet penceresi">
        <div class="chat-panel-header">
            <div class="chat-panel-title" id="chat-panel-title">
                 Sohbet
            </div>
            <button class="chat-panel-close" onclick="ChatSystem.togglePanel()" title="Kapat" aria-label="Sohbet penceresini kapat"></button>
        </div>
        <div id="chat-panel-messages" class="chat-panel-messages" role="log" aria-label="Sohbet mesajlar">
            <!-- Messages will be injected here -->
        </div>
        <div class="chat-panel-input">
            <div class="chat-channel-select" role="group" aria-label="Sohbet kanal seimi">
                <button class="chat-channel-btn active" onclick="ChatSystem.setChannel('Global', this)" aria-label="Global kanal">Global</button>
                <button class="chat-channel-btn" onclick="ChatSystem.setChannel('Trade', this)" aria-label="Trade kanal">Trade</button>
            </div>
            <div class="chat-input-row">
                <input type="text" id="chat-panel-input-text" placeholder="Mesaj yaz... (Enter)" onkeyup="if(event.key==='Enter') ChatSystem.debouncedSendMessage()" aria-label="Sohbet mesaj yaz">
                <button class="chat-send-btn" onclick="ChatSystem.sendMessage()" aria-label="Mesaj gnder">Gnder</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK Setup -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, deleteDoc, updateDoc, collection, getDocs, onSnapshot, query, orderBy, limit, where, runTransaction } from "https://www.gstatic.com/firebasejs/10.10.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyA3DCjL351ezkYpFy4QsBmVz7RR296ltzk",
            authDomain: "realm-tycoon.firebaseapp.com",
            projectId: "realm-tycoon",
            storageBucket: "realm-tycoon.firebasestorage.app",
            messagingSenderId: "1075977992909",
            appId: "1:1075977992909:web:b4ee69734e4febf6644784",
            measurementId: "G-SCJ1K0HKG9"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Expose Firebase tools to global scope for our vanilla JS systems to use
        window.FB = {
            auth,
            db,
            doc,
            setDoc,
            getDoc,
            deleteDoc,
            updateDoc,
            collection,
            getDocs,
            onSnapshot,
            query,
            orderBy,
            limit,
            where,
            runTransaction,
            signInAnonymously,
            onAuthStateChanged,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut
        };

        console.log(' Firebase initialized');
    </script>

    <!-- Dev Mode System -->
    <script>
        const DevMode = {
            enabled: false,
            config: {},

            // Check if running in development environment
            isDevelopment() {
                return window.location.hostname === 'localhost' || 
                       window.location.hostname === '127.0.0.1' ||
                       window.location.hostname === '' ||
                       (typeof window.location.protocol === 'string' && 
                        window.location.protocol === 'file:');
            },

            init() {
                // SECURITY FIX: DevMode only works in development environment
                if (!this.isDevelopment()) {
                    console.log('%c DevMode disabled in production', 'color: #ff4444; font-size: 12px;');
                    this.enabled = false;
                    return;
                }

                const params = new URLSearchParams(window.location.search);
                this.enabled = params.get('dev') === 'true' || params.get('dev') === '1';

                if(this.enabled) {
                    this.config = {
                        gold: parseInt(params.get('gold') || '0'),
                        iron: parseInt(params.get('iron') || '0'),
                        wood: parseInt(params.get('wood') || '0'),
                        crystal: parseInt(params.get('crystal') || '0'),
                        gems: parseInt(params.get('gems') || '0'),
                        chests: parseInt(params.get('chests') || '0'),
                        chest_common: parseInt(params.get('chest_common') || '0'),
                        chest_uncommon: parseInt(params.get('chest_uncommon') || '0'),
                        chest_legendary: parseInt(params.get('chest_legendary') || '0'),
                        level: parseInt(params.get('level') || '0'),
                        godmode: params.get('godmode') === '1' || params.get('godmode') === 'true',
                        instantwin: params.get('instantwin') === '1' || params.get('instantwin') === 'true'
                    };

                    console.log('%c DEV MODE ACTIVE', 'color: #ff4444; font-size: 16px; font-weight: bold;', this.config);
                    this.showIndicator();
                }
            },

            showIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'dev-mode-indicator';
                indicator.innerHTML = ' DEV MODE';
                indicator.title = 'Dev Mode aktif! URL parametreleri ile ayarland.';
                indicator.onclick = () => this.showConfig();
                document.body.appendChild(indicator);
            },

            showConfig() {
                let msg = 'Dev Mode Ayarlar:\n\n';
                for(const [key, value] of Object.entries(this.config)) {
                    if(value > 0 || value === true) {
                        msg += `${key}: ${value}\n`;
                    }
                }
                alert(msg);
            },

            apply() {
                if(!this.enabled) return;

                // Wait for game state to be ready
                setTimeout(() => {
                    // Apply resources
                    if(this.config.gold > 0 && gameState.player) {
                        SecuritySys.addGold(this.config.gold);
                    }
                    if(this.config.iron > 0 && gameState.player) {
                        gameState.player.iron += this.config.iron;
                    }
                    if(this.config.wood > 0 && gameState.player) {
                        gameState.player.wood += this.config.wood;
                    }
                    if(this.config.crystal > 0 && gameState.player) {
                        gameState.player.crystal += this.config.crystal;
                    }
                    if(this.config.gems > 0 && gameState.player) {
                        gameState.player.gems = (gameState.player.gems || 0) + this.config.gems;
                    }

                    // Apply building levels
                    if(this.config.level > 0 && gameState.buildings) {
                        for(const key of Object.keys(gameState.buildings)) {
                            gameState.buildings[key].level = this.config.level;
                        }
                    }

                    // Add chests
                    this.addChests();

                    // Update UI
                    if(PlayerSystem && PlayerSystem.updateUI) {
                        PlayerSystem.updateUI();
                    }
                    if(PlayerSystem && PlayerSystem.save) {
                        PlayerSystem.save();
                    }
                }, 500);
            },

            addChests() {
                if(!ChestSystem) return;

                // Add random chests - loot generated at open time
                for(let i = 0; i < this.config.chests; i++) {
                    const chestTier = ChestSystem.determineChestTier();
                    ChestSystem.addChestToInventory(chestTier);
                }

                // Add specific tier chests
                for(let i = 0; i < this.config.chest_common; i++) {
                    ChestSystem.addChestToInventory(CHEST_TIERS.common);
                }
                for(let i = 0; i < this.config.chest_uncommon; i++) {
                    ChestSystem.addChestToInventory(CHEST_TIERS.uncommon);
                }
                for(let i = 0; i < this.config.chest_legendary; i++) {
                    ChestSystem.addChestToInventory(CHEST_TIERS.legendary);
                }
            },

            isGodmode() {
                return this.enabled && this.config.godmode;
            },

            isInstantWin() {
                return this.enabled && this.config.instantwin;
            }
        };

        // Auto-init on load
        document.addEventListener('DOMContentLoaded', () => {
            DevMode.init();
        });
    </script>

    <script>
        // ========================================
        // LOGGER & ERROR HANDLING SYSTEM
        // ========================================
        const Logger = {
            enabled: true,
            minLevel: 'info', // 'debug', 'info', 'warn', 'error', 'critical'
            levels: { debug: 0, info: 1, warn: 2, error: 3, critical: 4 },
            errorHistory: [],
            maxHistory: 50,

            // Log format: [TIMESTAMP] [LEVEL] [CONTEXT] MESSAGE [DATA]
            _formatMessage(level, context, message, data) {
                const timestamp = new Date().toISOString().substr(11, 12);
                const prefix = `[${timestamp}] [${level.toUpperCase()}] [${context}]`;
                let logMsg = `${prefix} ${message}`;
                if (data !== undefined) {
                    try {
                        if (typeof data === 'object') {
                            logMsg += ' ' + JSON.stringify(data, null, 2);
                        } else {
                            logMsg += ' ' + data;
                        }
                    } catch (e) {
                        logMsg += ' [Data serialization failed]';
                    }
                }
                return logMsg;
            },

            // Add to error history for debugging
            _addToHistory(entry) {
                this.errorHistory.push({
                    timestamp: Date.now(),
                    ...entry
                });
                if (this.errorHistory.length > this.maxHistory) {
                    this.errorHistory.shift();
                }
            },

            // Debug: Lowest priority, detailed information
            debug(context, message, data = null) {
                if (!this.enabled || this.levels[this.minLevel] > this.levels.debug) return;
                console.debug(this._formatMessage('debug', context, message, data));
            },

            // Info: General operational information
            info(context, message, data = null) {
                if (!this.enabled || this.levels[this.minLevel] > this.levels.info) return;
                console.log(this._formatMessage('info', context, message, data));
            },

            // Warn: Something unexpected happened but system continues
            warn(context, message, data = null) {
                if (!this.enabled || this.levels[this.minLevel] > this.levels.warn) return;
                console.warn(this._formatMessage('warn', context, message, data));
                this._addToHistory({ level: 'warn', context, message, data });
            },

            // Error: Serious problem, operation failed
            error(context, errorObj, message = null, data = null) {
                if (!this.enabled || this.levels[this.minLevel] > this.levels.error) return;
                
                const errorMsg = errorObj instanceof Error ? errorObj.message : String(errorObj);
                const stack = errorObj instanceof Error ? errorObj.stack : null;
                const fullMessage = message ? `${message}: ${errorMsg}` : errorMsg;
                
                console.error(this._formatMessage('error', context, fullMessage, data));
                if (stack) {
                    console.error(stack);
                }
                
                this._addToHistory({
                    level: 'error',
                    context,
                    message: fullMessage,
                    error: errorMsg,
                    stack,
                    data
                });

                // Auto-show toast for critical errors
                if (typeof UI !== 'undefined' && UI.showToast) {
                    UI.showToast(`${context}: ${errorMsg}`, 'error');
                }
            },

            // Critical: System-breaking error, immediate attention needed
            critical(context, errorObj, message = null, data = null) {
                if (!this.enabled) return;
                
                const errorMsg = errorObj instanceof Error ? errorObj.message : String(errorObj);
                const stack = errorObj instanceof Error ? errorObj.stack : null;
                const fullMessage = message ? `${message}: ${errorMsg}` : errorMsg;
                
                console.error(this._formatMessage('critical', context, fullMessage, data));
                if (stack) {
                    console.error(stack);
                }
                
                this._addToHistory({
                    level: 'critical',
                    context,
                    message: fullMessage,
                    error: errorMsg,
                    stack,
                    data
                });

                // Always show toast for critical errors
                if (typeof UI !== 'undefined' && UI.showToast) {
                    UI.showToast(`KRTK HATA - ${context}: ${errorMsg}`, 'error');
                }

                // Could send to remote error tracking service here
                this._sendToRemoteTracking(context, fullMessage, errorObj, data);
            },

            // Track function execution time
            profile(context, label) {
                if (!this.enabled || this.levels[this.minLevel] > this.levels.debug) return;
                console.profile(`${context}: ${label}`);
            },

            profileEnd(context, label) {
                if (!this.enabled || this.levels[this.minLevel] > this.levels.debug) return;
                console.profileEnd(`${context}: ${label}`);
            },

            // Get error history for debugging
            getHistory(count = 10) {
                return this.errorHistory.slice(-count);
            },

            // Clear error history
            clearHistory() {
                this.errorHistory = [];
            },

            // Export error history for bug reports
            exportHistory() {
                return {
                    exportedAt: new Date().toISOString(),
                    gameVersion: '1.0.0',
                    errors: this.errorHistory
                };
            },

            // Remote error tracking hook (for future integration)
            _sendToRemoteTracking(context, message, error, data) {
                // Placeholder for Sentry, LogRocket, or custom error tracking
                // Example:
                // if (window.Sentry) {
                //     Sentry.captureException(error, { tags: { context }, extra: data });
                // }
                Logger.info('Logger', 'Error would be sent to remote tracking', { context, message });
            },

            // Safe execution wrapper
            safeExecute(context, fn, fallback = null) {
                try {
                    return fn();
                } catch (error) {
                    this.error(context, error, 'Execution failed');
                    return fallback;
                }
            },

            // Async safe execution wrapper
            async safeExecuteAsync(context, fn, fallback = null) {
                try {
                    return await fn();
                } catch (error) {
                    this.error(context, error, 'Async execution failed');
                    return fallback;
                }
            }
        };

        // Global error handler for uncaught errors
        window.addEventListener('error', (event) => {
            Logger.critical(
                'GlobalErrorHandler',
                event.error || event.message,
                'Uncaught error',
                {
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    message: event.message
                }
            );
        });

        // ========================================
        // TYPE DEFINITIONS (JSDoc for TypeScript-like types)
        // ========================================
        /**
         * @typedef {Object} Player
         * @property {string} id
         * @property {string} name
         * @property {number} level
         * @property {number} xp
         * @property {number} gold
         * @property {number} iron
         * @property {number} wood
         * @property {number} crystal
         * @property {number} gems
         * @property {number} heroHp
         * @property {PlayerStats} stats
         * @property {PlayerDailyData} dailyData
         * @property {HeroEquipment} heroEquipped
         * @property {number} newItemCount
         * @property {number} createdAt
         */

        /**
         * @typedef {Object} PlayerStats
         * @property {number} totalItemsCrafted
         * @property {number} totalItemsSold
         * @property {number} totalGoldEarned
         * @property {number} monstersKilled
         * @property {number} enchantSuccesses
         * @property {number} totalEnchants
         * @property {number} legendaryFound
         * @property {number} mythicFound
         * @property {number} buildingsMaxed
         * @property {string[]} unlockedAchievements
         */

        /**
         * @typedef {Object} PlayerDailyData
         * @property {number} lastLogin
         * @property {number} streakCount
         * @property {number} lastQuestsReset
         * @property {Object} questsProgress
         * @property {string[]} questsCompleted
         */

        /**
         * @typedef {Object} HeroEquipment
         * @property {Item|null} weapon
         * @property {Item|null} armor
         * @property {Item|null} ring
         * @property {Item|null} amulet
         */

        /**
         * @typedef {Object} Item
         * @property {string} id
         * @property {string} category
         * @property {string} subtype
         * @property {RarityType} rarity
         * @property {number} patternId
         * @property {number} qualityScore
         * @property {number} enchantLevel
         * @property {ItemStats} stats
         * @property {string} craftedBy
         * @property {string} craftedByName
         * @property {number} craftedAt
         * @property {number} season
         * @property {TradeHistory[]} tradeHistory
         */

        /**
         * @typedef {Object} ItemStats
         * @property {number} attack
         * @property {number} defense
         * @property {number} magic
         */

        /**
         * @typedef {Object} TradeHistory
         * @property {string} from
         * @property {string} to
         * @property {number} price
         * @property {number} date
         */

        /**
         * @typedef {'common'|'uncommon'|'rare'|'epic'|'legendary'|'mythic'} RarityType
         */

        /**
         * @typedef {Object} Building
         * @property {number} level
         */

        /**
         * @typedef {Object} Buildings
         * @property {Building} iron_mine
         * @property {Building} lumber_mill
         * @property {Building} crystal_cavern
         * @property {Building} forge
         * @property {Building} enchant_tower
         * @property {Building} trade_port
         */

        /**
         * @typedef {Object} ActiveCraft
         * @property {string} id
         * @property {string} catId
         * @property {number} startTime
         * @property {number} targetTime
         */

        /**
         * @typedef {Object} GameState
         * @property {Player|null} player
         * @property {Buildings} buildings
         * @property {Item[]} inventory
         * @property {ActiveCraft[]} activeCrafts
         * @property {number} lastTick
         */

        /**
         * @typedef {'debug'|'info'|'warn'|'error'|'critical'} LogLevel
         */

        /**
         * @typedef {Object} ChatMessage
         * @property {string} id
         * @property {string} playerId
         * @property {string} playerName
         * @property {'Global'|'Trade'} channel
         * @property {string} message
         * @property {number} timestamp
         */

        /**
         * @typedef {Object} Monster
         * @property {string} key
         * @property {string} name
         * @property {string} emoji
         * @property {string} ability
         * @property {string} abilityDesc
         * @property {number} maxHp
         * @property {number} hp
         * @property {number} atk
         * @property {number} baseAtk
         * @property {number} level
         * @property {Object} abilityState
         */

        /**
         * @typedef {Object} HeroState
         * @property {number} hp
         * @property {number} maxHp
         * @property {number} atk
         * @property {number} def
         * @property {boolean} inCombat
         * @property {string} battlePhase
         * @property {boolean} [_isDefending]
         */

        // Global promise rejection handler
        window.addEventListener('unhandledrejection', (event) => {
            Logger.critical(
                'GlobalErrorHandler',
                event.reason || 'Unknown promise rejection',
                'Unhandled promise rejection'
            );
        });

        // ========================================
        // SECURITY UTILITIES
        // ========================================
        const Security = {
            // HTML entity map for escaping
            htmlEntities: {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '/': '&#x2F;',
                '`': '&#x60;',
                '=': '&#x3D;'
            },

            // Sanitize string to prevent XSS
            sanitize(str) {
                if (typeof str !== 'string') {
                    if (str === null || str === undefined) return '';
                    str = String(str);
                }
                
                return str.replace(/[&<>"'`=\/]/g, char => this.htmlEntities[char]);
            },

            // Escape HTML for safe insertion
            escapeHtml(str) {
                return this.sanitize(str);
            },

            // Validate email format
            validateEmail(email) {
                const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return re.test(String(email).toLowerCase());
            },

            // Validate username (alphanumeric, 3-20 chars)
            validateUsername(username) {
                const re = /^[a-zA-Z0-9_]{3,20}$/;
                return re.test(username);
            },

            // Validate password (min 6 chars)
            validatePassword(password, min = 6) {
                return typeof password === 'string' && password.length >= min;
            },

            // Validate number range
            validateNumber(value, min = -Infinity, max = Infinity) {
                const num = Number(value);
                return !isNaN(num) && num >= min && num <= max;
            },

            // Validate string length
            validateStringLength(str, min = 0, max = Infinity) {
                if (typeof str !== 'string') return false;
                return str.length >= min && str.length <= max;
            },

            // Sanitize object recursively
            sanitizeObject(obj) {
                if (obj === null || obj === undefined) return obj;
                
                if (typeof obj === 'string') {
                    return this.sanitize(obj);
                }
                
                if (Array.isArray(obj)) {
                    return obj.map(item => this.sanitizeObject(item));
                }
                
                if (typeof obj === 'object') {
                    const sanitized = {};
                    for (const [key, value] of Object.entries(obj)) {
                        sanitized[key] = this.sanitizeObject(value);
                    }
                    return sanitized;
                }
                
                return obj;
            },

            // Generate CSRF-like token (for future use)
            generateToken(length = 32) {
                const array = new Uint8Array(length);
                crypto.getRandomValues(array);
                return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            },

            // Check if string contains potential SQL injection
            containsSQLInjection(str) {
                const patterns = [
                    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|ALTER|CREATE|TRUNCATE)\b)/i,
                    /(--|#|\/\*|\*\/)/,
                    /(\b(OR|AND)\b\s+\d+\s*=\s*\d+)/i
                ];
                
                return patterns.some(pattern => pattern.test(str));
            },

            // Safe JSON parse
            safeJsonParse(str, fallback = null) {
                try {
                    return JSON.parse(str);
                } catch (error) {
                    Logger.warn('Security', 'JSON parse failed', { error: error.message });
                    return fallback;
                }
            },

            // Validate action (for game actions)
            validateAction(action, data) {
                const validActions = {
                    'upgrade_building': { required: ['buildingKey'], types: { buildingKey: 'string' } },
                    'start_craft': { required: ['category'], types: { category: 'string' } },
                    'send_chat': { required: ['message', 'channel'], types: { message: 'string', channel: 'string' } },
                    'attack': { required: ['type'], types: { type: 'string' } },
                    'enchant_item': { required: ['itemId'], types: { itemId: 'string' } }
                };

                const config = validActions[action];
                if (!config) {
                    Logger.warn('Security', 'Invalid action', { action });
                    return false;
                }

                // Check required fields
                for (const field of config.required) {
                    if (data[field] === undefined || data[field] === null) {
                        Logger.warn('Security', 'Missing required field', { action, field });
                        return false;
                    }
                }

                // Check types
                for (const [field, expectedType] of Object.entries(config.types)) {
                    if (data[field] !== undefined && typeof data[field] !== expectedType) {
                        Logger.warn('Security', 'Invalid field type', { action, field, expectedType });
                        return false;
                    }
                }

                return true;
            }
        };

        // --- 0. AUDIO SYSTEM --- //

        // ========================================
        // PERFORMANCE UTILITIES (Debounce, Throttle, Memoize)
        // ========================================
        const Utils = {
            // Debounce: Function arlarn ertele (son ardan X ms sonra altr)
            debounce(func, wait, immediate = false) {
                let timeout;
                return function executedFunction(...args) {
                    const context = this;
                    const later = () => {
                        timeout = null;
                        if (!immediate) func.apply(context, args);
                    };
                    const callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) func.apply(context, args);
                };
            },

            // Throttle: Function' en fazla X ms'de bir altr
            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            // Memoize: Fonksiyon sonularn nbellee al
            memoize(func, resolver = null) {
                const cache = new Map();

                const memoizedFunc = function memoized(...args) {
                    const context = this;
                    const key = resolver ? resolver.apply(context, args) : JSON.stringify(args);

                    if (cache.has(key)) {
                        Logger.debug('Memoize', `Cache hit for ${func.name || 'anonymous'}`);
                        return cache.get(key);
                    }

                    const result = func.apply(context, args);
                    cache.set(key, result);
                    Logger.debug('Memoize', `Cache miss for ${func.name || 'anonymous'}`);
                    return result;
                };
                
                // FIX: Expose cache for manual clearing (e.g., on building upgrade)
                memoizedFunc.cache = cache;
                
                return memoizedFunc;
            },

            // Memoize with size limit (LRU cache)
            memoizeLimited(func, maxSize = 100) {
                const cache = new Map();
                
                return function(...args) {
                    const key = JSON.stringify(args);
                    
                    if (cache.has(key)) {
                        // Move to end (most recently used)
                        const value = cache.get(key);
                        cache.delete(key);
                        cache.set(key, value);
                        return value;
                    }
                    
                    const result = func.apply(this, args);
                    cache.set(key, result);
                    
                    // Remove oldest if over limit
                    if (cache.size > maxSize) {
                        const firstKey = cache.keys().next().value;
                        cache.delete(firstKey);
                    }
                    
                    return result;
                };
            },

            // Sleep utility for async operations
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            // Request Idle Callback wrapper
            idleCallback(callback, timeout = 1000) {
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(callback, { timeout });
                } else {
                    setTimeout(callback, 1);
                }
            },

            // Request Animation Frame wrapper
            raf(callback) {
                return new Promise(resolve => {
                    requestAnimationFrame(() => {
                        callback();
                        resolve();
                    });
                });
            },

            // Batch process large arrays
            async processInBatches(array, processor, batchSize = 10) {
                const results = [];
                for (let i = 0; i < array.length; i += batchSize) {
                    const batch = array.slice(i, i + batchSize);
                    const batchResults = await Promise.all(batch.map(processor));
                    results.push(...batchResults);
                    // Yield to main thread
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                return results;
            },

            // Deep clone with JSON (faster than structuredClone for simple objects)
            deepClone(obj) {
                return JSON.parse(JSON.stringify(obj));
            },

            // Compare two objects for equality
            deepEqual(a, b) {
                if (a === b) return true;
                if (typeof a !== 'object' || typeof b !== 'object') return false;
                if (a === null || b === null) return false;
                
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                
                if (keysA.length !== keysB.length) return false;
                
                for (const key of keysA) {
                    if (!keysB.includes(key)) return false;
                    if (!this.deepEqual(a[key], b[key])) return false;
                }
                
                return true;
            }
        };

        // ========================================
        // LAZY LOADING SYSTEM
        // ========================================
        const LazyLoader = {
            // Loaded modules tracking
            _loaded: {
                combat: false,
                enchant: false,
                marketplace: false,
                profile: false
            },

            // Loading promises (prevent duplicate loads)
            _loadingPromises: {},

            // Load a module
            async load(module) {
                if (this._loaded[module]) {
                    Logger.debug('LazyLoader', `Module ${module} already loaded`);
                    return true;
                }

                if (this._loadingPromises[module]) {
                    Logger.debug('LazyLoader', `Module ${module} already loading, waiting...`);
                    return this._loadingPromises[module];
                }

                Logger.info('LazyLoader', `Loading module: ${module}`);

                // Create loading promise
                this._loadingPromises[module] = (async () => {
                    try {
                        // Simulate async load (in real implementation, this would import() modules)
                        await Utils.sleep(50);

                        // Mark as loaded
                        this._loaded[module] = true;
                        Logger.info('LazyLoader', `Module ${module} loaded successfully`);

                        // Clean up loading promise
                        delete this._loadingPromises[module];

                        return true;
                    } catch (error) {
                        Logger.error('LazyLoader', error, `Failed to load module: ${module}`);
                        delete this._loadingPromises[module];
                        return false;
                    }
                })();

                return this._loadingPromises[module];
            },

            // Check if module is loaded
            isLoaded(module) {
                return this._loaded[module] === true;
            },

            // Check if module is loading
            isLoading(module) {
                return !!this._loadingPromises[module];
            },

            // Load multiple modules in parallel
            async loadMultiple(modules) {
                const results = await Promise.all(
                    modules.map(module => this.load(module))
                );
                return results.every(r => r);
            },

            // Preload modules (load in background)
            preload(modules) {
                modules.forEach(module => {
                    if (!this._loaded[module] && !this._loadingPromises[module]) {
                        this.load(module);
                    }
                });
            },

            // Get load status
            getStatus() {
                return {
                    loaded: Object.keys(this._loaded).filter(m => this._loaded[m]),
                    loading: Object.keys(this._loadingPromises),
                    notLoaded: Object.keys(this._loaded).filter(m => !this._loaded[m])
                };
            },

            // Unload module (for memory management)
            unload(module) {
                if (this._loadingPromises[module]) {
                    Logger.warn('LazyLoader', `Cannot unload ${module}, still loading`);
                    return false;
                }

                this._loaded[module] = false;
                Logger.info('LazyLoader', `Module ${module} unloaded`);
                return true;
            }
        };

        // ========================================
        // VIRTUAL SCROLLER (Performance Optimization)
        // ========================================
        const VirtualScroller = {
            // Default item dimensions - FIX #23: Use CSS variables
            defaultItemWidth: 100,
            defaultItemHeight: 120,
            defaultGap: 12,

            // Get item dimensions from CSS variables for consistency
            getItemDimensions() {
                const root = document.documentElement;
                const styles = getComputedStyle(root);
                return {
                    width: parseInt(styles.getPropertyValue('--grid-item-width')) || this.defaultItemWidth,
                    height: parseInt(styles.getPropertyValue('--grid-item-height')) || this.defaultItemHeight,
                    gap: parseInt(styles.getPropertyValue('--grid-gap')) || this.defaultGap
                };
            },

            // Calculate visible items in a scrollable container
            getVisibleItems(totalItems, scrollTop, containerHeight, itemWidth, itemHeight, gap, columns) {
                itemWidth = itemWidth || this.defaultItemWidth;
                itemHeight = itemHeight || this.defaultItemHeight;
                gap = gap || this.defaultGap;

                // Calculate row height (item + gap)
                const rowHeight = itemHeight + gap;

                // Calculate which row is at the top of viewport
                const startRow = Math.floor(scrollTop / rowHeight);

                // Calculate how many rows fit in viewport
                const visibleRows = Math.ceil(containerHeight / rowHeight) + 1;

                // Calculate start and end indexes
                const startIndex = Math.max(0, startRow * columns);
                const endIndex = Math.min(totalItems, (startRow + visibleRows) * columns);

                // Calculate offset for positioning
                const offsetY = startRow * rowHeight;

                return {
                    startIndex,
                    endIndex,
                    offsetY,
                    visibleCount: endIndex - startIndex,
                    totalRows: Math.ceil(totalItems / columns),
                    currentRow: startRow
                };
            },

            // Calculate number of columns based on container width
            getColumns(containerWidth, itemWidth, gap) {
                itemWidth = itemWidth || this.defaultItemWidth;
                gap = gap || this.defaultGap;
                return Math.floor((containerWidth + gap) / (itemWidth + gap));
            },

            // Calculate total height needed for all items
            getTotalHeight(totalItems, columns, itemHeight, gap) {
                itemHeight = itemHeight || this.defaultItemHeight;
                gap = gap || this.defaultGap;
                const rows = Math.ceil(totalItems / columns);
                return rows * (itemHeight + gap) - gap;
            },

            // Render visible items with placeholder for scroll
            render(container, items, renderItem, options = {}) {
                // FIX #23: Get default dimensions from CSS variables
                const dims = this.getItemDimensions();
                
                const {
                    itemHeight = dims.height,
                    gap = dims.gap,
                    containerWidth = container.clientWidth,
                    containerHeight = container.clientHeight,
                    scrollTop = container.scrollTop
                } = options;

                // FIX #23: Calculate itemWidth dynamically from container's CSS grid
                // instead of using hardcoded value to match auto-fill minmax behavior
                let itemWidth = options.itemWidth || dims.width;
                
                // Try to get computed style from container's grid-template-columns
                if (!options.itemWidth) {
                    const computedStyle = window.getComputedStyle(container);
                    const gridTemplate = computedStyle.gridTemplateColumns;
                    // Parse "repeat(auto-fill, minmax(100px, 1fr))" or actual column widths
                    if (gridTemplate && gridTemplate !== 'none') {
                        const columns = gridTemplate.split(' ').filter(c => c.trim() && c !== ' ');
                        if (columns.length > 0 && columns[0] !== 'auto-fill') {
                            // Use actual computed column width if available
                            const firstColWidth = parseInt(columns[0], 10);
                            if (!isNaN(firstColWidth)) {
                                itemWidth = firstColWidth;
                            }
                        }
                    }
                }

                const columns = this.getColumns(containerWidth, itemWidth, gap);
                const visible = this.getVisibleItems(
                    items.length,
                    scrollTop,
                    containerHeight,
                    itemWidth,
                    itemHeight,
                    gap,
                    columns
                );

                // Clear container
                container.innerHTML = '';

                // Set container style for virtual scroll
                container.style.position = 'relative';
                container.style.overflowY = 'auto';

                // Create spacer for total height
                const totalHeight = this.getTotalHeight(items.length, columns, itemHeight, gap);
                const spacer = document.createElement('div');
                spacer.style.height = `${totalHeight}px`;
                spacer.style.position = 'relative';
                container.appendChild(spacer);

                // Create visible items container
                const itemsContainer = document.createElement('div');
                itemsContainer.style.position = 'absolute';
                itemsContainer.style.top = `${visible.offsetY}px`;
                itemsContainer.style.left = '0';
                itemsContainer.style.right = '0';
                itemsContainer.style.display = 'grid';
                itemsContainer.style.gridTemplateColumns = `repeat(${columns}, ${itemWidth}px)`;
                itemsContainer.style.gap = `${gap}px`;
                itemsContainer.style.padding = `${gap}px`;

                // Render visible items
                for (let i = visible.startIndex; i < visible.endIndex; i++) {
                    const item = items[i];
                    const itemEl = renderItem(item, i);
                    if (itemEl) {
                        itemsContainer.appendChild(itemEl);
                    }
                }

                spacer.appendChild(itemsContainer);

                // Restore scroll position
                container.scrollTop = scrollTop;

                return visible;
            },

            // Simple virtual scroll for grid (easier integration)
            setupGrid(container, items, renderItem, options = {}) {
                // FIX #23: Get default dimensions from CSS variables
                const dims = this.getItemDimensions();
                
                // FIX #23: Calculate itemWidth dynamically from container's CSS grid
                let itemWidth = options.itemWidth || dims.width;
                let itemHeight = options.itemHeight || dims.height;
                const gap = options.gap || dims.gap;

                // Try to get computed style from container's grid-template-columns
                if (!options.itemWidth) {
                    const computedStyle = window.getComputedStyle(container);
                    const gridTemplate = computedStyle.gridTemplateColumns;
                    // Parse "repeat(auto-fill, minmax(100px, 1fr))" or actual column widths
                    if (gridTemplate && gridTemplate !== 'none') {
                        const columns = gridTemplate.split(' ').filter(c => c.trim() && c !== ' ');
                        if (columns.length > 0 && columns[0] !== 'auto-fill') {
                            // Use actual computed column width if available
                            const firstColWidth = parseInt(columns[0], 10);
                            if (!isNaN(firstColWidth)) {
                                itemWidth = firstColWidth;
                            }
                        }
                    }
                }

                // Store state
                container._virtualScroll = {
                    items,
                    renderItem,
                    itemWidth,
                    itemHeight,
                    gap,
                    lastScrollTop: 0
                };

                // Initial render
                this._renderGrid(container);

                // Throttled scroll handler
                container._scrollHandler = Utils.throttle(() => {
                    this._renderGrid(container);
                }, 100);

                container.addEventListener('scroll', container._scrollHandler);

                // Return cleanup function
                return () => {
                    if (container._scrollHandler) {
                        container.removeEventListener('scroll', container._scrollHandler);
                    }
                };
            },

            // Internal grid render
            _renderGrid(container) {
                const state = container._virtualScroll;
                if (!state) return;

                const { items, renderItem, itemWidth, itemHeight, gap } = state;

                const columns = this.getColumns(container.clientWidth, itemWidth, gap);
                const visible = this.getVisibleItems(
                    items.length,
                    container.scrollTop,
                    container.clientHeight,
                    itemWidth,
                    itemHeight,
                    gap,
                    columns
                );

                // Clear and rebuild
                container.innerHTML = '';
                container.style.overflowY = 'auto';

                // Create content wrapper with total height
                const content = document.createElement('div');
                content.style.height = `${this.getTotalHeight(items.length, columns, itemHeight, gap)}px`;
                content.style.position = 'relative';
                container.appendChild(content);

                // Create items grid
                const grid = document.createElement('div');
                grid.style.position = 'absolute';
                grid.style.top = `${visible.offsetY}px`;
                grid.style.left = '0';
                grid.style.right = '0';
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = `repeat(${columns}, ${itemWidth}px)`;
                grid.style.gap = `${gap}px`;
                grid.style.padding = `${gap}px`;

                // Render visible items
                for (let i = visible.startIndex; i < visible.endIndex; i++) {
                    const item = items[i];
                    const itemEl = renderItem(item, i);
                    if (itemEl) {
                        grid.appendChild(itemEl);
                    }
                }

                content.appendChild(grid);

                // Restore scroll position
                container.scrollTop = state.lastScrollTop || 0;
                state.lastScrollTop = container.scrollTop;
            },

            // Update items and re-render
            updateItems(container, newItems) {
                if (container._virtualScroll) {
                    container._virtualScroll.items = newItems;
                    this._renderGrid(container);
                }
            },

            // Destroy virtual scroll
            destroy(container) {
                if (container._virtualScroll) {
                    if (container._scrollHandler) {
                        container.removeEventListener('scroll', container._scrollHandler);
                    }
                    delete container._virtualScroll;
                }
            }
        };

        // ========================================
        // ICON LAZY LOADER (Intersection Observer)
        // ========================================
        const IconLazyLoader = {
            // Observer instance
            _observer: null,

            // Icons to load
            _pendingIcons: new Map(),

            // Initialize Intersection Observer
            init() {
                if (this._observer) return;

                this._observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const icon = entry.target;
                            this._loadIcon(icon);
                            this._observer.unobserve(icon);
                        }
                    });
                }, {
                    rootMargin: '100px', // Load icons 100px before they're visible
                    threshold: 0.01
                });

                Logger.info('IconLazyLoader', 'Initialized Intersection Observer');
            },

            // Load a single icon
            _loadIcon(iconEl) {
                const iconChar = iconEl.dataset.lazyIcon;
                if (!iconChar) return;

                // Add fade-in animation
                iconEl.style.opacity = '0';
                iconEl.style.transition = 'opacity 0.2s ease';

                // Set the icon
                iconEl.textContent = iconChar;

                // Fade in
                requestAnimationFrame(() => {
                    iconEl.style.opacity = '1';
                });

                Logger.debug('IconLazyLoader', `Loaded icon: ${iconChar}`);
            },

            // Observe an element for lazy loading
            observe(element, iconChar) {
                if (!element) return;

                this.init();

                element.dataset.lazyIcon = iconChar;
                element.textContent = ''; // Clear until loaded

                // Add placeholder
                element.style.opacity = '0.3';

                this._observer.observe(element);
            },

            // Observe multiple elements
            observeAll(elements) {
                elements.forEach(el => {
                    const iconChar = el.dataset.lazyIcon;
                    if (iconChar) {
                        this.observe(el, iconChar);
                    }
                });
            },

            // Load icon immediately (no lazy loading)
            loadImmediate(element, iconChar) {
                if (!element) return;
                element.textContent = iconChar;
                element.style.opacity = '1';
            },

            // Disconnect observer (cleanup)
            destroy() {
                if (this._observer) {
                    this._observer.disconnect();
                    this._observer = null;
                }
            },

            // Create lazy icon element
            createIconElement(iconChar, className = '') {
                const span = document.createElement('span');
                span.className = `lazy-icon ${className}`;
                span.dataset.lazyIcon = iconChar;
                span.style.opacity = '0.3';
                span.style.transition = 'opacity 0.2s ease';
                return span;
            }
        };

        // ========================================
        // ANALYTICS & MONITORING SYSTEM
        // ========================================
        const Analytics = {
            // Session data
            sessionId: null,
            sessionStart: null,
            events: [],
            maxEvents: 1000,

            // Player behavior tracking
            playerActions: {
                levelUps: 0,
                itemsCrafted: 0,
                monstersKilled: 0,
                itemsEnchanted: 0,
                buildingsUpgraded: 0,
                chatsSent: 0,
                tradesCompleted: 0
            },

            // Feature usage tracking
            featureUsage: {
                combat: 0,
                crafting: 0,
                enchanting: 0,
                inventory: 0,
                chat: 0,
                marketplace: 0
            },

            // Error tracking
            errors: [],
            maxErrors: 100,

            // Initialize analytics
            init() {
                this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                this.sessionStart = Date.now();

                Logger.info('Analytics', 'Session started', {
                    sessionId: this.sessionId,
                    timestamp: new Date().toISOString()
                });

                // Track page unload
                window.addEventListener('beforeunload', () => {
                    this.trackSessionEnd();
                });

                // Track errors
                window.addEventListener('error', (event) => {
                    this.trackError('global', event.message, {
                        filename: event.filename,
                        lineno: event.lineno
                    });
                });
            },

            // Track custom event
            track(eventName, data = {}) {
                const event = {
                    eventId: 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                    sessionId: this.sessionId,
                    timestamp: Date.now(),
                    name: eventName,
                    data: data
                };

                this.events.push(event);

                // Trim if too many events
                if (this.events.length > this.maxEvents) {
                    this.events = this.events.slice(-this.maxEvents);
                }

                // Log in debug mode
                Logger.debug('Analytics', `Event: ${eventName}`, data);

                // Could send to remote analytics service
                // this.sendToRemote(event);
            },

            // Track player action
            trackAction(action, data = {}) {
                if (this.playerActions[action] !== undefined) {
                    this.playerActions[action]++;
                }
                this.track(`player_${action}`, data);
            },

            // Track feature usage
            trackFeature(feature, data = {}) {
                if (this.featureUsage[feature] !== undefined) {
                    this.featureUsage[feature]++;
                }
                this.track(`feature_${feature}`, data);
            },

            // Track error
            trackError(context, message, data = {}) {
                const error = {
                    timestamp: Date.now(),
                    context,
                    message,
                    data
                };

                this.errors.push(error);

                if (this.errors.length > this.maxErrors) {
                    this.errors = this.errors.slice(-this.maxErrors);
                }

                Logger.warn('Analytics', `Error tracked: ${context}`, { message, data });
            },

            // Track level up
            trackLevelUp(level, xp) {
                this.trackAction('levelUps', { level, xp });
                this.track('milestone_level', { level, xp });
            },

            // Track item craft
            trackItemCraft(rarity, category) {
                this.trackAction('itemsCrafted', { rarity, category });
                this.trackFeature('crafting', { rarity, category });

                if (['legendary', 'mythic'].includes(rarity)) {
                    this.track('milestone_rare_craft', { rarity, category });
                }
            },

            // Track monster kill
            trackMonsterKill(dungeon, difficulty, level) {
                this.trackAction('monstersKilled', { dungeon, difficulty, level });
                this.trackFeature('combat', { dungeon, difficulty, level });
            },

            // Track enchant attempt
            trackEnchant(itemRarity, enchantLevel, success) {
                this.trackAction('itemsEnchanted', { itemRarity, enchantLevel, success });
                this.trackFeature('enchanting', { itemRarity, enchantLevel, success });

                if (success && enchantLevel >= 5) {
                    this.track('milestone_high_enchant', { itemRarity, enchantLevel });
                }
            },

            // Track building upgrade
            trackBuildingUpgrade(building, level) {
                this.trackAction('buildingsUpgraded', { building, level });
            },

            // Track chat message
            trackChat(channel, messageLength) {
                this.trackAction('chatsSent', { channel, messageLength });
                this.trackFeature('chat', { channel, messageLength });
            },

            // Track trade
            trackTrade(itemRarity, price) {
                this.trackAction('tradesCompleted', { itemRarity, price });
                this.trackFeature('marketplace', { itemRarity, price });
            },

            // Track session end
            trackSessionEnd() {
                const sessionDuration = Date.now() - this.sessionStart;
                this.track('session_end', {
                    duration: sessionDuration,
                    eventsCount: this.events.length,
                    actionsCount: Object.values(this.playerActions).reduce((a, b) => a + b, 0)
                });

                Logger.info('Analytics', 'Session ended', {
                    sessionId: this.sessionId,
                    duration: sessionDuration,
                    eventsCount: this.events.length
                });
            },

            // Get session summary
            getSessionSummary() {
                const sessionDuration = Date.now() - this.sessionStart;
                const totalActions = Object.values(this.playerActions).reduce((a, b) => a + b, 0);
                const totalFeatureUses = Object.values(this.featureUsage).reduce((a, b) => a + b, 0);

                return {
                    sessionId: this.sessionId,
                    sessionDuration,
                    sessionDurationFormatted: this._formatDuration(sessionDuration),
                    eventsCount: this.events.length,
                    totalActions,
                    totalFeatureUses,
                    playerActions: { ...this.playerActions },
                    featureUsage: { ...this.featureUsage },
                    errorsCount: this.errors.length,
                    recentErrors: this.errors.slice(-5)
                };
            },

            // Get event log
            getEventLog(count = 50) {
                return this.events.slice(-count);
            },

            // Get error log
            getErrorLog(count = 20) {
                return this.errors.slice(-count);
            },

            // Export analytics data
            exportData() {
                return {
                    sessionId: this.sessionId,
                    sessionStart: new Date(this.sessionStart).toISOString(),
                    sessionDuration: Date.now() - this.sessionStart,
                    events: this.events,
                    playerActions: this.playerActions,
                    featureUsage: this.featureUsage,
                    errors: this.errors,
                    exportedAt: new Date().toISOString()
                };
            },

            // Clear analytics data
            clear() {
                this.events = [];
                this.errors = [];
                this.playerActions = {
                    levelUps: 0,
                    itemsCrafted: 0,
                    monstersKilled: 0,
                    itemsEnchanted: 0,
                    buildingsUpgraded: 0,
                    chatsSent: 0,
                    tradesCompleted: 0
                };
                this.featureUsage = {
                    combat: 0,
                    crafting: 0,
                    enchanting: 0,
                    inventory: 0,
                    chat: 0,
                    marketplace: 0
                };
            },

            // Format duration helper
            _formatDuration(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);

                if (hours > 0) {
                    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${seconds % 60}s`;
                } else {
                    return `${seconds}s`;
                }
            },

            // Print dashboard to console
            printDashboard() {
                const summary = this.getSessionSummary();
                console.group(' Analytics Dashboard');
                console.log(`Session: ${summary.sessionId}`);
                console.log(`Duration: ${summary.sessionDurationFormatted}`);
                console.log(`Events: ${summary.eventsCount}`);
                console.log('--- Player Actions ---');
                Object.entries(summary.playerActions).forEach(([action, count]) => {
                    if (count > 0) console.log(`  ${action}: ${count}`);
                });
                console.log('--- Feature Usage ---');
                Object.entries(summary.featureUsage).forEach(([feature, count]) => {
                    if (count > 0) console.log(`  ${feature}: ${count}`);
                });
                if (summary.errorsCount > 0) {
                    console.log(`--- Errors: ${summary.errorsCount} ---`);
                    summary.recentErrors.forEach(err => {
                        console.log(`  [${err.context}] ${err.message}`);
                    });
                }
                console.groupEnd();
            }
        };

        const AudioSystem = {
            ctx: null,
            init() { 
                if(!this.ctx) {
                    try { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); } 
                    catch(e) { console.log('Audio API not supported'); }
                } 
            },
            playTone(freq, type, duration, vol=0.1) {
                if(!this.ctx) return;
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            click() { this.playTone(400, 'sine', 0.1, 0.05); },
            buy() { this.playTone(600, 'triangle', 0.15, 0.05); setTimeout(()=>this.playTone(800, 'triangle', 0.2, 0.05), 100); },
            error() { this.playTone(150, 'sawtooth', 0.3, 0.1); },
            success() { this.playTone(440, 'sine', 0.1, 0.05); setTimeout(()=>this.playTone(554, 'sine', 0.1, 0.05), 100); setTimeout(()=>this.playTone(659, 'sine', 0.2, 0.05), 200); },
            craftReveal() { this.playTone(300, 'square', 1.0, 0.05); setTimeout(()=>this.playTone(800, 'sine', 0.5, 0.1), 1000); },
            crit() { this.playTone(900, 'triangle', 0.1, 0.12); setTimeout(()=>this.playTone(1200, 'sine', 0.18, 0.1), 70); },
            powerStrike() { this.playTone(80, 'sawtooth', 0.25, 0.18); setTimeout(()=>this.playTone(550, 'triangle', 0.3, 0.45), 160); },
            achievement() { this.playTone(440, 'sine', 0.15, 0.1); setTimeout(()=>this.playTone(660, 'sine', 0.15, 0.1), 120); setTimeout(()=>this.playTone(880, 'sine', 0.2, 0.3), 250); }
        };

        // Attach click sound to all buttons globally (delegation)
        document.addEventListener('click', (e) => {
            AudioSystem.init(); // Init on first interaction
            const button = e.target.closest('button');
            if(button && !button.disabled) {
                const text = button.innerText.toLowerCase();
                if(text.includes('cancel') || text.includes('close')) AudioSystem.click();
                else if(text.includes('buy') || text.includes('upgrade')) AudioSystem.buy();
                else AudioSystem.click();
            }
        });

        /**
         * REALM TYCOON - Core Game Logic
         */

        // --- 1. UTILITIES & STORAGE WRAPPERS --- //

        const LangDict = {
                // UI & Resources
                res_gold: "Altn", res_iron: "Demir", res_wood: "Odun", res_crystal: "Kristal", res_gems: "Elmas",
                btn_settings: "Ayarlar", btn_logout: "Hesaptan k Yap", btn_wipe: "Kayt Verisini Sil",
                danger_zone: "Tehlikeli Blge", wipe_warning: "Yerel krallk verinizi kalc olarak silin.",
                settings_desc: "Krallk tercihlerinizi ynetin.",
                lang_toggle: "Dili Deitir (English)",
                kingdom_overview: "Krallk Genel Bak",
                select_building: "Ynetmek ve gelitirmek iin haritadan bir bina sein.",
                inventory: "Envanter", chat: "Sohbet", send: "Gnder",
                
                // Buildings Details & Dungeons
                b_iron_mine: "Derin Madenler", b_lumber_mill: "Karanlk Orman", b_crystal_cavern: "Kristal Catacombs",
                b_forge: "Demirci", b_enchant_tower: "Tlsm Kulesi", b_trade_port: "Ticaret Liman",
                lvl: "Svy", max_reached: "Maksimum Seviyeye Ulald",
                current_prod: "Mevcut retim", next_level: "Sonraki Seviye", upgrade_cost: "Seviye Atlama Bedeli",
                upgrade_to: "Seviye Atlat", back_to_town: " Kasabaya Dn", building_details: "Blge Detaylar",
                enter_dungeon: "Zindana Gir (Sava)",
                
                // Auth & Login
                login: "Giri Yap", register: "Kayt Ol", create_acc: "Hesap Olutur", email_ph: "E-posta Adresi", pass_ph: "ifre (min 6 krk)",
                welcome_back: "Tekrar Hogeldin",

                // Messages & Toasts
                purchase_succ: "Satn alma baarl!", not_enough_gold: "Yeterli Altn yok!",
                trade_sent: "Takas teklifi gnderildi!", trade_succ: "Takas Baarl!",
                invalid_id: "Geersiz Oyuncu ID.",
                // Daily & Quests
                daily_quests: "Gnlk Grevler", login_streak: "Giri Serisi", day: "Gn",
                quest_kill5: "5 Canavar ldr", quest_craft1: "1 Eya Yap", quest_sell1: "1 Eya Listele", quest_enchant1: "1 By Dene",
                streak_reward: "Gnlk Giri dl!", streak_day: "Seri Gn", streak_bonus: "Bonus",
                quests_complete: "Tm Grevler Tamamland! Bonus dl Alnd!",
                // Achievements
                achievements: "Baarmlar", achievement_unlocked: "Baarm Ald",
                ach_kill10_n: "lk Kan", ach_kill100_n: "Canavar Avcs", ach_kill1000_n: "Zindan Lordu",
                ach_craft5_n: "rak Demirci", ach_craft50_n: "Usta Zanaatkar",
                ach_legendary_n: "Kadere Dokunu", ach_mythic_n: "Efsane Demirci",
                ach_sell10_n: "Pazar Mdavimi", ach_gold10k_n: "Altn Biriktirici", ach_maxbuild_n: "Bina Ustas",
                // Combat
                combo: "COMBO", power_ready: " GL DARBE HAZIR ", crit_hit: "KRTK!", power_hit: "GL!",
                // Difficulty
                choose_difficulty: "Zorluk Se", diff_normal: "Normal", diff_hard: "Zor", diff_nightmare: "Kabus",
                diff_normal_desc: "Standart loot dlleri", diff_hard_desc: "2x loot, daha gl canavarlar", diff_nightmare_desc: "3.5x loot + Elmas d, ok tehlikeli",
                // Equipment
                equip_hero: "Kahraman'a Giy", unequip: "kar", hero_equipment: "Kahraman Ekipman",
                slot_weapon: "Silah", slot_armor: "Zrh", slot_ring: "Yzk", slot_amulet: "Tlsm", slot_empty: "Bo",
                equipped_bonus: "Ekipman Bonuslar",
                // Rush
                rush_craft: "Hzlandr", not_enough_gems: "Yeterli Elmas yok!",
                // Leaderboard
                leaderboard: "Kresel Sralama", lb_gold: "Altn Biriktirenler", lb_crafts: "Zanaatkarlar", lb_kills: "Canavar Avclar", loading: "Ykleniyor..."
        };

        const LangSys = {
            init() {},
            toggle() {},
            get(key) { return LangDict[key] || key; },
            applyToDOM() {
                document.querySelectorAll('[data-i18n]').forEach(el => {
                   el.innerText = this.get(el.getAttribute('data-i18n'));
                });
                document.querySelectorAll('[data-i18n-title]').forEach(el => {
                   el.title = this.get(el.getAttribute('data-i18n-title'));
                });
                document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                   el.placeholder = this.get(el.getAttribute('data-i18n-placeholder'));
                });
            }
        };

        LangSys.init(); // Execute immediately before UI is fully created
        document.addEventListener('DOMContentLoaded', () => LangSys.applyToDOM());

        const UI = {
            // Private cached elements
            _toastContainer: null,
            _gameContainer: null,
            _modalContainer: null,
            _modalBody: null,
            _resCells: null,
            _playerName: null,

            // Lazy loading getters
            get gameContainer() {
                if(!this._gameContainer) this._gameContainer = document.getElementById('game-container');
                return this._gameContainer;
            },
            get modalContainer() {
                if(!this._modalContainer) this._modalContainer = document.getElementById('modal-container');
                return this._modalContainer;
            },
            get modalBody() {
                if(!this._modalBody) this._modalBody = document.getElementById('modal-body');
                return this._modalBody;
            },
            get toastContainer() {
                if(!this._toastContainer) this._toastContainer = document.getElementById('toast-container');
                return this._toastContainer;
            },
            get resCells() {
                if(!this._resCells) {
                    this._resCells = {
                        gold: document.getElementById('res-gold'),
                        iron: document.getElementById('res-iron'),
                        wood: document.getElementById('res-wood'),
                        crystal: document.getElementById('res-crystal'),
                        gems: document.getElementById('res-gems')
                    };
                }
                return this._resCells;
            },
            get playerName() {
                if(!this._playerName) this._playerName = document.getElementById('player-profile-summary');
                return this._playerName;
            },
            
            showModal: function(htmlContent, preventClose = false) {
                if(!this.modalBody || !this.modalContainer) {
                    console.error('[UI.showModal] Modal elements not found!');
                    return;
                }
                this.modalBody.innerHTML = htmlContent;
                if(!preventClose) {
                    this.modalBody.innerHTML += '<button class="modal-close" onclick="UI.hideModal()">&times;</button>';
                }
                this.modalContainer.classList.add('active');
            },
            hideModal: function() {
                this.modalContainer.classList.remove('active');
            },
            formatNumber: function(num) {
                if (num === null || num === undefined) return '0';
                num = Number(num);
                if (isNaN(num)) return '0';
                if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return Math.floor(num).toString();
            },
            showToast: function(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                this.toastContainer.appendChild(toast);
                
                // Remove out after 4 seconds
                setTimeout(() => {
                    toast.style.animation = 'fadeOut 0.3s ease forwards';
                    setTimeout(() => toast.remove(), 300);
                }, 4000);

                if(type === 'error') AudioSystem.error();
            },
            switchView: function(viewId) {
                // Hide all views
                document.querySelectorAll('.view-section').forEach(v => v.classList.add('hidden'));
                // Remove active from all nav items
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                
                // Show requested view
                const view = document.getElementById('view-' + viewId);
                if(view) {
                    view.classList.remove('hidden');
                    // Add active to nav
                    const nav = document.getElementById('nav-' + viewId);
                    if(nav) nav.classList.add('active');
                    
                    // Specific view logic
                    if(viewId === 'town') {
                        BuildingSystem.renderMainView();
                    } else if(viewId === 'inventory') {
                        InventorySystem.renderFullView();
                    } else if(viewId === 'hero') {
                        HeroSystem.renderFullView();
                    }
                }
            },
            showSettings: function() {
                this.showModal(`
                    <h2 class="text-gold" style="margin-bottom: 20px;">${LangSys.get('btn_settings')}</h2>
                    <p class="text-secondary" style="margin-bottom: 20px;">${LangSys.get('settings_desc')}</p>
                    
                    <button style="width: 100%; margin-bottom: 20px;" onclick="window.FB.signOut(window.FB.auth).then(()=>location.reload())">${LangSys.get('btn_logout')}</button>

                    <div style="background: rgba(139,0,0,0.1); padding: 15px; border-left: 3px solid var(--rarity-mythic); border-radius: 4px; border-top: var(--border-subtle); border-bottom: var(--border-subtle); border-right: var(--border-subtle);">
                        <h4 style="color: var(--rarity-mythic); margin-bottom: 10px;">${LangSys.get('danger_zone')}</h4>
                        <p style="font-size: 0.9rem; margin-bottom: 15px;">${LangSys.get('wipe_warning')}</p>
                        <button style="border-color: var(--rarity-mythic); color: var(--rarity-mythic); width: 100%;" onclick="if(confirm('Are you absolutely sure you want to delete your save? You will lose all your progress!')) { StorageAPI.delete('player-data'); StorageAPI.delete('player-buildings'); setTimeout(()=>location.reload(), 1000); }">${LangSys.get('btn_wipe')}</button>
                    </div>
                `);
            },
            updateNavBadges() {
                // Inventory badge: Show NEW items count (items added since last viewed)
                const newItemCount = gameState.player.newItemCount || 0;
                const invBadge = document.getElementById('nav-badge-inventory');
                if(invBadge) {
                    if(newItemCount > 0) {
                        invBadge.style.display = 'block';
                        invBadge.textContent = newItemCount > 99 ? '99+' : newItemCount;
                    } else {
                        invBadge.style.display = 'none';
                    }
                }
                // Chat badge is now on FAB (handled by ChatSystem.updateFabBadge)
            }
        };

        // Firebase Storage Wrapper
        const StorageAPI = {
            isReady: false,
            uid: null,
            initCallback: null,

            init(callback) {
                this.initCallback = callback;
                window.FB.onAuthStateChanged(window.FB.auth, (user) => {
                    if (user) {
                        this.uid = user.uid;
                        this.isReady = true;
                        if(this.initCallback) {
                            this.initCallback(this.uid);
                            this.initCallback = null;
                        }
                    } else {
                        // User is signed out
                        this.uid = null;
                        this.isReady = false;
                        if(this.initCallback) {
                            this.initCallback(null);
                            this.initCallback = null;
                        }
                    }
                });
            },

            async get(key, shared = false) {
                if(!this.isReady) return null;
                try {
                    let docRef;
                    if(shared) {
                        docRef = window.FB.doc(window.FB.db, `shared_data/${key}`);
                    } else {
                        docRef = window.FB.doc(window.FB.db, `players/${this.uid}/local_data/${key}`);
                    }
                    const snap = await window.FB.getDoc(docRef);
                    if(snap.exists()) {
                        return snap.data().value;
                    }
                    return null;
                } catch(e) { console.error(`Storage GET error [${key}]:`, e); return null; }
            },
            async set(key, value, shared = false) {
                if(!this.isReady) return;

                try {
                    let docRef;
                    if(shared) {
                        docRef = window.FB.doc(window.FB.db, `shared_data/${key}`);
                    } else {
                        docRef = window.FB.doc(window.FB.db, `players/${this.uid}/local_data/${key}`);
                    }
                    await window.FB.setDoc(docRef, { value: value }, { merge: true });
                } catch(e) { console.error(`Storage SET error [${key}]:`, e); }
            },
            async delete(key, shared = false) {
                if(!this.isReady) return;
                try {
                    let docRef;
                    if(shared) {
                        docRef = window.FB.doc(window.FB.db, `shared_data/${key}`);
                    } else {
                        docRef = window.FB.doc(window.FB.db, `players/${this.uid}/local_data/${key}`);
                    }
                    await window.FB.deleteDoc(docRef);
                } catch(e) { console.error(`Storage DELETE error [${key}]:`, e); }
            }
        };

        // ========================================
        // GAME STATE MANAGEMENT (Observer Pattern)
        // ========================================
        const GameStateManager = {
            // Internal state
            _state: {
                player: null,
                buildings: {
                    iron_mine: { level: 1 },
                    lumber_mill: { level: 1 },
                    crystal_cavern: { level: 1 },
                    forge: { level: 1 },
                    enchant_tower: { level: 1 },
                    trade_port: { level: 1 }
                },
                inventory: [],
                activeCrafts: [],
                lastTick: Date.now()
            },

            // Subscribers by category
            _subscribers: {
                player: [],
                buildings: [],
                inventory: [],
                activeCrafts: [],
                all: []
            },

            // Get state or specific property
            getState(path = null) {
                if (!path) return this._state;
                
                const parts = path.split('.');
                let value = this._state;
                
                for (const part of parts) {
                    if (value === undefined || value === null) return undefined;
                    value = value[part];
                }
                
                return value;
            },

            // Set state with optional notification
            setState(newState, notify = true) {
                const oldState = { ...this._state };
                
                // Merge new state
                this._state = this._mergeDeep(this._state, newState);
                
                // Notify subscribers
                if (notify) {
                    this._notify(newState, oldState);
                }
                
                Logger.debug('GameStateManager', 'State updated', Object.keys(newState));
            },

            // Subscribe to state changes
            subscribe(category, callback) {
                if (!this._subscribers[category]) {
                    this._subscribers[category] = [];
                }
                
                this._subscribers[category].push(callback);
                
                Logger.debug('GameStateManager', `Subscribed to ${category}`);
                
                // Return unsubscribe function
                return () => this.unsubscribe(category, callback);
            },

            // Unsubscribe from state changes
            unsubscribe(category, callback) {
                if (!this._subscribers[category]) return;
                
                this._subscribers[category] = this._subscribers[category].filter(
                    cb => cb !== callback
                );
            },

            // Clear all subscribers (for cleanup)
            clearSubscribers() {
                Object.keys(this._subscribers).forEach(key => {
                    this._subscribers[key] = [];
                });
            },

            // Notify subscribers
            _notify(newState, oldState) {
                // Notify 'all' subscribers
                this._subscribers.all.forEach(cb => {
                    try {
                        cb(this._state, newState, oldState);
                    } catch (error) {
                        Logger.error('GameStateManager', error, 'Subscriber callback failed');
                    }
                });

                // Notify category-specific subscribers
                const changedCategories = new Set();
                
                for (const key of Object.keys(newState)) {
                    if (this._subscribers[key]) {
                        changedCategories.add(key);
                    }
                }

                changedCategories.forEach(category => {
                    this._subscribers[category].forEach(cb => {
                        try {
                            cb(this._state[category], newState[category], oldState[category]);
                        } catch (error) {
                            Logger.error('GameStateManager', error, `Subscriber callback failed for ${category}`);
                        }
                    });
                });
            },

            // Deep merge helper
            _mergeDeep(target, source) {
                const result = { ...target };
                
                for (const key of Object.keys(source)) {
                    const sourceValue = source[key];
                    const targetValue = target[key];

                    if (this._isObject(sourceValue) && this._isObject(targetValue)) {
                        result[key] = this._mergeDeep(targetValue, sourceValue);
                    } else if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {
                        // For arrays, replace entirely (can be customized)
                        result[key] = sourceValue;
                    } else {
                        result[key] = sourceValue;
                    }
                }
                
                return result;
            },

            _isObject(item) {
                return item && typeof item === 'object' && !Array.isArray(item);
            },

            // Get state history for debugging
            getHistory() {
                return {
                    state: this._state,
                    subscriberCount: Object.values(this._subscribers).reduce((a, b) => a + b.length, 0)
                };
            },

            // Export state for save
            exportState() {
                return JSON.parse(JSON.stringify(this._state));
            },

            // Import state from save
            importState(savedState) {
                try {
                    this._state = this._mergeDeep(this._state, savedState);
                    Logger.info('GameStateManager', 'State imported successfully');
                } catch (error) {
                    Logger.error('GameStateManager', error, 'Failed to import state');
                }
            }
        };

        // ========================================
        // SECURITY SYSTEM - ANTI-CHEAT ENGINE
        // ========================================
        const SecuritySys = {
            // SECRET SALT - Known only to you
            SECRET_SALT: "R3alm_Tyc00n_AntiCh3at_2026_!xQp9",
            _goldSignature: "",

            // 1. Signature Generator
            generateSignature: function(amount) {
                let str = amount.toString() + this.SECRET_SALT;
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    let char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(16); // Return as hexadecimal
            },

            // 2. Initialize engine when game loads
            initEngine: function(initialGold) {
                this._goldSignature = this.generateSignature(initialGold);
            },

            // 3. SECURE GOLD ADD (Use instead of direct +=)
            addGold: function(amount) {
                gameState.player.gold += amount;
                this._goldSignature = this.generateSignature(gameState.player.gold); // Update signature
            },

            // 4. SECURE GOLD SPEND (Use instead of direct -=)
            spendGold: function(amount) {
                if (gameState.player.gold >= amount) {
                    gameState.player.gold -= amount;
                    this._goldSignature = this.generateSignature(gameState.player.gold); // Update signature
                    return true; // Spend successful
                }
                return false; // Insufficient gold
            }
        };

        // ========================================
        // DEEP PROXY FOR NESTED PROPERTY TRACKING
        // ========================================
        // Creates a recursive Proxy that tracks nested property changes
        function createDeepProxy(target, path = '') {
            return new Proxy(target, {
                get(target, prop) {
                    const value = target[prop];

                    // If it's a function, bind it to the target
                    if (typeof value === 'function') {
                        return value.bind(target);
                    }

                    // If it's an object/array (and not null), wrap it in a deep proxy
                    if (value !== null && typeof value === 'object' && prop !== '_state') {
                        const newPath = path ? `${path}.${prop}` : prop;
                        return createDeepProxy(value, newPath);
                    }

                    return value;
                },

                set(target, prop, value) {
                    const fullPath = path ? `${path}.${prop}` : prop;

                    // Update the actual state
                    target[prop] = value;

                    // Notify GameStateManager about the change
                    // FIX #9: Properly handle nested paths by notifying the root category
                    if (path) {
                        // Extract the root category (e.g., 'player' from 'player.gold')
                        const rootCategory = path.split('.')[0];
                        const rootValue = GameStateManager.getState(rootCategory);
                        if (rootValue) {
                            GameStateManager.setState({ [rootCategory]: rootValue });
                        }
                        Logger.debug('DeepProxy', `Set ${fullPath}`, value);
                    } else {
                        GameStateManager.setState({ [prop]: value });
                        Logger.debug('DeepProxy', `Set ${fullPath}`, value);
                    }

                    return true;
                },

                // Handle nested property modifications (e.g., player.gold += 100)
                // This intercepts operations on nested objects
                getOwnPropertyDescriptor(target, prop) {
                    return Object.getOwnPropertyDescriptor(target, prop);
                }
            });
        }

        // Helper to handle compound operations like +=, -=, etc.
        // Wrap numeric properties to intercept in-place modifications
        function wrapNumericObject(obj, path) {
            if (!obj || typeof obj !== 'object') return obj;
            
            for (const key of Object.keys(obj)) {
                const fullPath = path ? `${path}.${key}` : key;
                const value = obj[key];
                
                if (typeof value === 'number') {
                    // Create a getter/setter pair for numeric values
                    Object.defineProperty(obj, key, {
                        get: function() {
                            return this['_' + key];
                        },
                        set: function(newValue) {
                            this['_' + key] = newValue;
                            // Notify state manager
                            if (path) {
                                const parentValue = GameStateManager.getState(path);
                                if (parentValue) {
                                    GameStateManager.setState({ [path]: parentValue });
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    obj['_' + key] = value;
                } else if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
                    wrapNumericObject(value, fullPath);
                }
            }
            return obj;
        }

        // Backwards compatibility: gameState uses deep proxy
        const gameState = new Proxy(GameStateManager._state, {
            get(target, prop) {
                const value = GameStateManager.getState(prop);
                
                // If it's an object, wrap it in a deep proxy for nested tracking
                if (value !== null && typeof value === 'object' && prop !== '_state') {
                    return createDeepProxy(value, prop);
                }
                
                return value;
            },
            set(target, prop, value) {
                GameStateManager.setState({ [prop]: value });
                return true;
            }
        });

        // --- 2. GAME STATE & PLAYER SYSTEM --- //
        // Note: gameState is now managed by GameStateManager (see above)

        const BUILDING_DATA = {
            iron_mine: {
                name: LangSys.get('b_iron_mine'),
                icon: "",
                maxLevel: 50,
                category: 'resource',
                desc: "Karanlk, istila edilmi bir maden. Demir ve ganimet toplamak iin iindeki canavarlar ldrn.",
                baseCost: { gold: 50, wood: 20 },
                getCost: Utils.memoize(function(level) {
                    const mult = Math.pow(1.5, level - 1);
                    return { gold: Math.round(50 * mult), wood: Math.round(20 * mult) };
                })
            },
            lumber_mill: {
                name: LangSys.get('b_lumber_mill'),
                icon: "",
                maxLevel: 50,
                category: 'resource',
                desc: "Lanetli bir orman. Odun toplamak iin yozlam entleri alt edin.",
                baseCost: { gold: 50, iron: 20 },
                getCost: Utils.memoize(function(level) {
                    const mult = Math.pow(1.5, level - 1);
                    return { gold: Math.round(50 * mult), iron: Math.round(20 * mult) };
                })
            },
            crystal_cavern: {
                name: LangSys.get('b_crystal_cavern'),
                icon: "",
                maxLevel: 50,
                category: 'resource',
                desc: "Kadim yeralt mezarlar. Kristaller ve nadir elmaslar iin muhafzlarla savan.",
                baseCost: { gold: 100, iron: 30, wood: 30 },
                getCost: Utils.memoize(function(level) {
                    const mult = Math.pow(1.5, level - 1);
                    return { gold: Math.round(100 * mult), iron: Math.round(30 * mult), wood: Math.round(30 * mult) };
                })
            },
            forge: {
                name: LangSys.get('b_forge'),
                icon: "",
                maxLevel: 50,
                category: 'production',
                desc: "Gl eyalar retin. Daha yksek seviye daha iyi nadirlikler ve daha fazla alan aar.",
                baseCost: { gold: 100, iron: 50, crystal: 30 },
                getCost: Utils.memoize(function(level) {
                    const mult = Math.pow(1.5, level - 1);
                    return { gold: Math.round(100 * mult), iron: Math.round(50 * mult), crystal: Math.round(30 * mult) };
                })
            },
            enchant_tower: {
                name: LangSys.get('b_enchant_tower'),
                icon: "",
                maxLevel: 30,
                category: 'production',
                desc: "Eyalar Ykselt. Seviye bana +%1 baar ans.",
                baseCost: { gold: 150, crystal: 40 },
                getCost: Utils.memoize(function(level) {
                    const mult = Math.pow(1.5, level - 1);
                    return { gold: Math.round(150 * mult), crystal: Math.round(40 * mult) };
                })
            },
            trade_port: {
                name: LangSys.get('b_trade_port'),
                icon: "",
                maxLevel: 30,
                category: 'trade',
                desc: "Pazara eriin. Daha yksek seviye listeleme alanlarn artrr ve cretleri drr.",
                baseCost: { gold: 200, wood: 50, iron: 30 },
                getCost: Utils.memoize(function(level) {
                    const mult = Math.pow(1.5, level - 1);
                    return { gold: Math.round(200 * mult), wood: Math.round(50 * mult), iron: Math.round(30 * mult) };
                })
            }
        };

        const PlayerSystem = {
            async init() {
                if(!StorageAPI.isReady || !StorageAPI.uid) {
                    this.showAuthScreen();
                    return;
                }

                const pData = await StorageAPI.get('player-data');
                const bData = await StorageAPI.get('player-buildings');
                
                if (pData && pData.id) {
                    gameState.player = pData;
                    if (bData) {
                        gameState.buildings = bData;
                    }
                    // Load Inventory
                    const invData = await StorageAPI.get('player-inventory');
                    if (invData) {
                        gameState.inventory = invData;
                    }
                    this.onLoadGame();
                } else {
                    this.showWelcomeScreen();
                }
            },

            showAuthScreen() {
                 UI.showModal(`
                    <h2 class="text-gold" style="font-size:2rem; text-align:center; margin-bottom:10px;">Realm Tycoon</h2>
                    <p style="text-align:center; margin-bottom: 20px;" class="text-secondary">lerlemenizi Buluta kaydetmek iin Giri Yapn veya Kayt Olun.</p>
                    
                    <div style="display:flex; gap:10px; margin-bottom:15px;">
                        <button id="tab-login" style="flex:1; background:var(--accent-gold); color:black;" onclick="PlayerSystem.switchAuthTab('login')">Giri Yap</button>
                        <button id="tab-register" style="flex:1;" onclick="PlayerSystem.switchAuthTab('register')">Kayt Ol</button>
                    </div>

                    <div id="auth-form-container">
                        <input type="email" id="auth-email" placeholder="E-posta Adresi" style="width:100%; font-size:1.1rem; padding:10px; margin-bottom:10px;">
                        <input type="password" id="auth-pass" placeholder="ifre (min 6 krk)" style="width:100%; font-size:1.1rem; padding:10px; margin-bottom:20px;">
                        <button style="width:100%; padding:15px; font-size:1.1rem; background:var(--accent-gold); color:black;" id="btn-submit-auth" onclick="PlayerSystem.submitAuth('login')">Giri Yap</button>
                    </div>
                `, true); // Prevent closing
            },

            switchAuthTab(tab) {
                const btnL = document.getElementById('tab-login');
                const btnR = document.getElementById('tab-register');
                const submitBtn = document.getElementById('btn-submit-auth');
                
                if(tab === 'login') {
                    btnL.style.background = 'var(--accent-gold)'; btnL.style.color = 'black';
                    btnR.style.background = 'var(--bg-tertiary)'; btnR.style.color = 'var(--text-primary)';
                    submitBtn.innerText = 'Giri Yap';
                    submitBtn.setAttribute('onclick', "PlayerSystem.submitAuth('login')");
                } else {
                    btnR.style.background = 'var(--accent-gold)'; btnR.style.color = 'black';
                    btnL.style.background = 'var(--bg-tertiary)'; btnL.style.color = 'var(--text-primary)';
                    submitBtn.innerText = 'Hesap Olutur';
                    submitBtn.setAttribute('onclick', "PlayerSystem.submitAuth('register')");
                }
            },

            async submitAuth(action) {
                const email = document.getElementById('auth-email').value.trim();
                const pass = document.getElementById('auth-pass').value.trim();
                
                if(!email || pass.length < 6) return UI.showToast("Invalid Email or ifre (min 6 krk).", "error");
                
                const btn = document.getElementById('btn-submit-auth');
                btn.disabled = true;
                btn.innerText = "leniyor...";

                try {
                    if(action === 'login') {
                        await window.FB.signInWithEmailAndPassword(window.FB.auth, email, pass);
                    } else {
                        await window.FB.createUserWithEmailAndPassword(window.FB.auth, email, pass);
                    }
                    UI.hideModal();
                    
                    // The onAuthStateChanged listener handles reloading if we attached a callback
                    // But if callback is null, it means we are in the middle of a session.
                    if(!StorageAPI.initCallback) {
                       StorageAPI.uid = window.FB.auth.currentUser.uid;
                       StorageAPI.isReady = true;
                       this.init();
                    }
                } catch(e) {
                    console.error("Auth error", e);
                    UI.showToast(e.message, "error");
                    btn.disabled = false;
                    btn.innerText = action === 'login' ? "Giri Yap" : "Hesap Olutur";
                }
            },

            showWelcomeScreen() {
                UI.showModal(`
                    <h2 class="text-gold" style="font-size:2rem; text-align:center; margin-bottom:10px;">Realm Tycoon</h2>
                    <p style="text-align:center; margin-bottom: 20px;" class="text-secondary">Kaderinizi ekillendirin. mparatorluunuzu kurun. Eyalarnz takas edin.</p>
                    <div style="margin-bottom: 20px;">
                        <label style="display:block; margin-bottom:5px;">Lordunuzun ad nedir?</label>
                        <input type="text" id="init-player-name" placeholder="sim girin (maks 15 krk)" maxlength="15" style="width:100%; font-size:1.1rem; padding:10px;">
                    </div>
                    <button style="width:100%; padding:15px; font-size:1.1rem;" id="btn-start-journey">Maceraya Bala</button>
                `, true); // Prevent closing

                document.getElementById('btn-start-journey').addEventListener('click', async () => {
                    const name = document.getElementById('init-player-name').value.trim();
                    if(name.length < 3 || name.length > 15) {
                        UI.showToast("sim 3 ile 15 karakter arasnda olmaldr.", "error");
                        return;
                    }
                    await this.createNewPlayer(name);
                });
            },

            async createNewPlayer(name) {
                const newId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                gameState.player = {
                    id: newId,
                    name: name,
                    gold: 100,
                    iron: 50,
                    wood: 50,
                    crystal: 20,
                    gems: 0,
                    level: 1,
                    xp: 0,
                    createdAt: Date.now(),
                    stats: {
                        totalItemsCrafted: 0,
                        totalItemsSold: 0,
                        totalGoldEarned: 0,
                        monstersKilled: 0,
                        enchantSuccesses: 0,
                        totalEnchants: 0,  // Added for success rate calculation
                        legendaryFound: 0,
                        mythicFound: 0,
                        buildingsMaxed: 0,
                        unlockedAchievements: []
                    },
                    dailyData: { lastLogin: 0, streakCount: 0, lastQuestsReset: 0, questsProgress: { kills: 0, crafts: 0, sells: 0, enchants: 0 }, questsCompleted: [] },
                    heroEquipped: { weapon: null, armor: null, ring: null, amulet: null },
                    newItemCount: 0
                };

                // Create public profile (shared state)
                const publicProfile = {
                    id: newId,
                    name: name,
                    showcase: [],
                    stats: { totalCrafted: 0, rarest_item: 'None' },
                    joinedAt: Date.now()
                };

                await StorageAPI.set('player-data', gameState.player);
                await StorageAPI.set('player-buildings', gameState.buildings);
                await StorageAPI.set('player-inventory', gameState.inventory);
                await StorageAPI.set(`public-profile:${newId}`, publicProfile, true);
                
                UI.hideModal();
                this.onLoadGame();
                UI.showToast(`Realm Tycoon'a ho geldin, Lord ${name}! retim balasn.`, "success");
            },

            async save() {
                if(!gameState.player) return;
                await StorageAPI.set('player-data', gameState.player);
                await StorageAPI.set('player-buildings', gameState.buildings);
                await StorageAPI.set('player-inventory', gameState.inventory);
            },

            onLoadGame() {
                // Patch old saves for new fields
                const p = gameState.player;
                if(!p.stats) p.stats = {};
                if(!p.stats.monstersKilled) p.stats.monstersKilled = 0;
                if(!p.stats.enchantSuccesses) p.stats.enchantSuccesses = 0;
                if(!p.stats.legendaryFound) p.stats.legendaryFound = 0;
                if(!p.stats.mythicFound) p.stats.mythicFound = 0;
                if(!p.stats.buildingsMaxed) p.stats.buildingsMaxed = 0;
                if(!p.stats.unlockedAchievements) p.stats.unlockedAchievements = [];
                if(!p.dailyData) p.dailyData = { lastLogin: 0, streakCount: 0, lastQuestsReset: 0, questsProgress: { kills: 0, crafts: 0, sells: 0, enchants: 0 }, questsCompleted: [] };
                if(!p.dailyData.questsProgress) p.dailyData.questsProgress = { kills: 0, crafts: 0, sells: 0, enchants: 0 };
                if(!p.heroEquipped) p.heroEquipped = { weapon: null, armor: null, ring: null, amulet: null };
                if(p.newItemCount === undefined) p.newItemCount = 0;
                // Level system patch
                if(p.level === undefined) p.level = 1;
                if(p.xp === undefined) p.xp = 0;

                // Initialize security system with current gold
                SecuritySys.initEngine(gameState.player.gold);

                UI.gameContainer.classList.remove('hidden');
                BuildingSystem.renderList();
                BuildingSystem.renderMainView();
                this.updateUI();
                InventorySystem.render();
                ChatSystem.init();
                Analytics.init(); // Initialize analytics tracking
                GameLoop.start();
                this.calcOfflineProgress();
                DailySystem.checkLoginStreak();
            },

            async calcOfflineProgress() {
                // FIX #21: Implement offline progress calculation
                // Note: Passive income was removed in Phase 11 (Active RPG Transition)
                // This function now only tracks offline time for analytics purposes
                const lastSave = await StorageAPI.get('last-save-time');
                if (!lastSave) return;

                const now = Date.now();
                const offlineSeconds = Math.floor((now - lastSave) / 1000);

                if (offlineSeconds > 60) {
                    // Log offline time for analytics (no passive rewards)
                    console.log(`Player was offline for ${Math.floor(offlineSeconds / 60)} minutes`);

                    // Track in analytics if available
                    if (typeof Analytics !== 'undefined') {
                        Analytics.track('offline_session', {
                            durationSeconds: offlineSeconds,
                            playerId: gameState.player?.id
                        });
                    }
                }
            },

            updateUI() {
                if(!gameState.player) return;
                UI.resCells.gold.innerText = UI.formatNumber(gameState.player.gold);
                UI.resCells.iron.innerText = UI.formatNumber(gameState.player.iron);
                UI.resCells.wood.innerText = UI.formatNumber(gameState.player.wood);
                UI.resCells.crystal.innerText = Math.floor(gameState.player.crystal);
                UI.resCells.gems.innerText = UI.formatNumber(gameState.player.gems);
                UI.playerName.innerText = gameState.player.name;

                // Update level and XP display
                const levelEl = document.getElementById('player-level');
                const xpCurrentEl = document.getElementById('xp-current');
                const xpRequiredEl = document.getElementById('xp-required');
                const xpProgressEl = document.getElementById('xp-progress');
                
                if(levelEl) levelEl.textContent = gameState.player.level;
                if(xpCurrentEl && xpRequiredEl && xpProgressEl) {
                    const xpRequired = LevelSystem.getXpRequired(gameState.player.level);
                    xpCurrentEl.textContent = gameState.player.xp;
                    xpRequiredEl.textContent = xpRequired;
                    const xpPercent = Math.floor((gameState.player.xp / xpRequired) * 100);
                    xpProgressEl.style.width = xpPercent + '%';
                }

                // Hero HP topbar - centralized update
                this.updateHeroHPDisplay();

                // Update nav badges
                UI.updateNavBadges();
            },

            updateHeroHPDisplay() {
                const hpEl = document.getElementById('hero-hp-topbar');
                if(!hpEl || !gameState.player) return;
                const heroLevel = gameState.player.level || 1;
                const maxHp = LevelSystem.getMaxHp(heroLevel);
                if(gameState.player.heroHp === undefined) gameState.player.heroHp = maxHp;
                hpEl.textContent = `${Math.floor(gameState.player.heroHp)}/${maxHp}`;
                hpEl.style.color = gameState.player.heroHp < maxHp * 0.3 ? 'var(--rarity-mythic)' : (gameState.player.heroHp < maxHp * 0.6 ? 'var(--accent-warning)' : 'var(--accent-danger)');
            }
        };

        // --- LEVEL SYSTEM --- //
        const LevelSystem = {
            // XP required for next level: 100 * level^1.5 (MEMOIZED)
            getXpRequired: Utils.memoize(function(level) {
                return Math.floor(100 * Math.pow(level, 1.5));
            }),

            // Max HP: 100 * (1 + (level-1)*0.15) (MEMOIZED)
            getMaxHp: Utils.memoize(function(level) {
                return Math.floor(100 * (1 + (level - 1) * 0.15));
            }),

            // Base ATK: 10 * (1 + (level-1)*0.12) (MEMOIZED)
            getBaseAtk: Utils.memoize(function(level) {
                return Math.floor(10 * (1 + (level - 1) * 0.12));
            }),
            
            // Add XP and check for level up
            addXp(amount) {
                const player = gameState.player;
                if(!player) return;
                
                player.xp += amount;
                
                let leveledUp = false;
                let newLevel = player.level;
                
                // Check for level up
                while(player.xp >= this.getXpRequired(newLevel)) {
                    player.xp -= this.getXpRequired(newLevel);
                    newLevel++;
                    leveledUp = true;
                }
                
                if(leveledUp) {
                    const oldLevel = player.level;
                    player.level = newLevel;

                    // FIX #20: Clear memoize cache for level-dependent functions
                    // This ensures XP/HP/ATK calculations use the new level
                    if (this.getXpRequired.cache) this.getXpRequired.cache.clear();
                    if (this.getMaxHp.cache) this.getMaxHp.cache.clear();
                    if (this.getBaseAtk.cache) this.getBaseAtk.cache.clear();

                    // Track analytics
                    if (typeof Analytics !== 'undefined') {
                        Analytics.trackLevelUp(newLevel, player.xp);
                    }

                    // Show level up toast
                    this.showLevelUpToast(newLevel);

                    // Play achievement sound
                    if(typeof AudioSystem !== 'undefined') AudioSystem.achievement();
                }
                
                // Update UI
                PlayerSystem.updateUI();
                PlayerSystem.save();
            },
            
            showLevelUpToast(newLevel) {
                const toast = document.createElement('div');
                toast.className = 'toast achievement';
                toast.innerHTML = ` <strong>LEVEL ATLANDI!</strong><br>Seviye ${newLevel} ulatn!<br><span style="font-size:0.85rem; color:var(--text-secondary)">HP ve Saldr Gcn artt!</span>`;
                document.getElementById('toast-container').appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'fadeOut 0.3s ease forwards';
                    setTimeout(() => toast.remove(), 300);
                }, 5000);
            },
            
            // Get XP progress percentage (0-100)
            getXpProgress() {
                const player = gameState.player;
                if(!player) return 0;
                const required = this.getXpRequired(player.level);
                return Math.floor((player.xp / required) * 100);
            }
        };

        // --- B. BUILDING SYSTEM --- //
        const BuildingSystem = {
            renderList() {
                // Obsolete: We no longer use the left panel list.
            },

            renderMainView() {
                document.getElementById('view-title').innerText = "Kingdom Overview";
                const container = document.getElementById('view-container');

                // Render category selection view
                container.innerHTML = this.renderCategoryView();
            },

            renderCategoryView() {
                const categories = {
                    resource: {
                        id: 'resource',
                        name: ' Sava Alanlar',
                        description: 'Kaynak toplamak iin canavarlarla sava',
                        icon: '',
                        color: 'var(--rarity-mythic)',
                        buildings: Object.keys(BUILDING_DATA).filter(key => BUILDING_DATA[key].category === 'resource')
                    },
                    production: {
                        id: 'production',
                        name: ' retim Binalar',
                        description: 'Eya ret ve ykselt',
                        icon: '',
                        color: 'var(--accent-info)',
                        buildings: Object.keys(BUILDING_DATA).filter(key => BUILDING_DATA[key].category === 'production')
                    },
                    trade: {
                        id: 'trade',
                        name: ' Ticaret',
                        description: 'Pazar ve ticaret ilemleri',
                        icon: '',
                        color: 'var(--accent-gold)',
                        buildings: Object.keys(BUILDING_DATA).filter(key => BUILDING_DATA[key].category === 'trade')
                    }
                };

                let html = `<div class="category-container">`;

                for(const cat of Object.values(categories)) {
                    const buildingCount = cat.buildings.length;
                    html += `
                        <div class="category-card" onclick="BuildingSystem.showCategory('${cat.id}')" style="border-color: ${cat.color};">
                            <div class="category-icon">${cat.icon}</div>
                            <div class="category-name">${cat.name}</div>
                            <div class="category-desc">${cat.description}</div>
                            <div class="category-count">${buildingCount} Bina</div>
                        </div>
                    `;
                }

                html += `</div>
                <p class="text-secondary" style="margin-top:25px; text-align:center;">Bir kategori sein veya <button style="padding:5px 10px; margin-left:5px;" onclick="BuildingSystem.showAllBuildings()">tm binalar gster</button></p>`;

                return html;
            },

            showCategory(categoryId) {
                document.getElementById('view-title').innerText = "Kingdom Overview";
                const container = document.getElementById('view-container');

                const categoryBuildings = Object.keys(BUILDING_DATA).filter(key => BUILDING_DATA[key].category === categoryId);

                let html = `
                    <button style="margin-bottom:20px; background:var(--bg-tertiary); border:var(--border-subtle); color:var(--text-secondary); width:auto; padding:8px 15px;" onclick="BuildingSystem.renderMainView()"> Geri Dn</button>
                    <div class="town-map">
                `;

                for(const key of categoryBuildings) {
                    const bData = BUILDING_DATA[key];
                    const currentLevel = gameState.buildings[key].level;
                    let maxLvl = bData.maxLevel;
                    let tier = Math.ceil((currentLevel / maxLvl) * 5) || 1;
                    if(currentLevel === 0) tier = 1;

                    html += `
                        <div class="town-building tier-${tier}" onclick="BuildingSystem.selectBuilding('${key}')">
                            <div class="b-icon">${bData.icon}</div>
                            <div class="b-name">${bData.name}</div>
                            <div class="b-level">Svy ${currentLevel} ${currentLevel >= maxLvl ? '(MAKS)' : ''}</div>
                        </div>
                    `;
                }

                html += `</div>`;
                container.innerHTML = html;
            },

            showAllBuildings() {
                document.getElementById('view-title').innerText = "Kingdom Overview";
                const container = document.getElementById('view-container');

                let html = `
                    <button style="margin-bottom:20px; background:var(--bg-tertiary); border:var(--border-subtle); color:var(--text-secondary); width:auto; padding:8px 15px;" onclick="BuildingSystem.renderMainView()"> Geri Dn</button>
                    <div class="town-map">
                `;

                for (const [key, bData] of Object.entries(BUILDING_DATA)) {
                    const currentLevel = gameState.buildings[key].level;
                    let maxLvl = bData.maxLevel;
                    let tier = Math.ceil((currentLevel / maxLvl) * 5) || 1;
                    if(currentLevel === 0) tier = 1;

                    html += `
                        <div class="town-building tier-${tier}" onclick="BuildingSystem.selectBuilding('${key}')">
                            <div class="b-icon">${bData.icon}</div>
                            <div class="b-name">${bData.name}</div>
                            <div class="b-level">Svy ${currentLevel} ${currentLevel >= maxLvl ? '(MAKS)' : ''}</div>
                        </div>
                    `;
                }

                html += `</div>`;
                container.innerHTML = html;
            },

            showUpgradeModal(buildingKey) {
                const bData = BUILDING_DATA[buildingKey];
                const currentLevel = gameState.buildings[buildingKey].level;
                const nextLevel = currentLevel + 1;
                const isMax = currentLevel >= bData.maxLevel;
                const cost = bData.getCost(currentLevel);

                if(isMax) {
                    return UI.showToast("Bu bina zaten maksimum seviyede!", "error");
                }

                // Get current and next level stats
                const currentStats = this.getBuildingStats(buildingKey, currentLevel);
                const nextStats = this.getBuildingStats(buildingKey, nextLevel);

                // Build cost HTML
                let costHtml = '';
                let canAfford = true;
                for(const [res, amt] of Object.entries(cost)) {
                    const hasEnough = gameState.player[res] >= amt;
                    if(!hasEnough) canAfford = false;
                    const resName = LangSys.get('res_' + res) || (res.charAt(0).toUpperCase() + res.slice(1));
                    const resIcon = res === 'gold' ? '' : res === 'wood' ? '' : res === 'iron' ? '' : res === 'crystal' ? '' : '';
                    costHtml += `
                        <div class="upgrade-cost-item ${hasEnough ? 'can-afford' : 'cannot-afford'}">
                            <span>${resIcon} ${resName}</span>
                            <span>${UI.formatNumber(gameState.player[res])} / ${UI.formatNumber(amt)}</span>
                        </div>
                    `;
                }

                // Build stat rows
                let currentStatsHtml = '';
                let nextStatsHtml = '';
                
                currentStats.forEach(stat => {
                    currentStatsHtml += `
                        <div class="upgrade-stat-row">
                            <span class="upgrade-stat-label">${stat.label}</span>
                            <span class="upgrade-stat-value">${stat.value}</span>
                        </div>
                    `;
                });

                nextStats.forEach((stat, index) => {
                    const isIncrease = stat.isIncrease;
                    nextStatsHtml += `
                        <div class="upgrade-stat-row">
                            <span class="upgrade-stat-label">${stat.label}</span>
                            <span class="upgrade-stat-value">
                                ${stat.value}
                                ${isIncrease ? `<span class="upgrade-stat-increase">(+${stat.change})</span>` : ''}
                            </span>
                        </div>
                    `;
                });

                const modalContent = `
                    <div class="upgrade-modal-container">
                        <h3 class="upgrade-modal-title">
                            ${bData.icon} ${bData.name} Ykseltme
                        </h3>
                        
                        <div class="upgrade-compare-grid">
                            <div class="upgrade-box current">
                                <div class="upgrade-box-title">MEVCUT<br>Seviye ${currentLevel}</div>
                                ${currentStatsHtml}
                            </div>
                            
                            <div class="upgrade-arrow"></div>
                            
                            <div class="upgrade-box next">
                                <div class="upgrade-box-title">YEN<br>Seviye ${nextLevel}</div>
                                ${nextStatsHtml}
                            </div>
                        </div>

                        <div class="upgrade-cost-section">
                            <div class="upgrade-cost-title">Ykseltme Maliyeti</div>
                            ${costHtml}
                        </div>

                        <div class="upgrade-actions">
                            <button onclick="UI.hideModal()">ptal</button>
                            <button class="btn-upgrade-confirm" ${!canAfford ? 'disabled' : ''} onclick="BuildingSystem.confirmUpgrade('${buildingKey}')">
                                 Ykselt
                            </button>
                        </div>
                    </div>
                `;

                UI.showModal(modalContent);
            },

            getBuildingStats(buildingKey, level) {
                const bData = BUILDING_DATA[buildingKey];
                const stats = [];

                // Common stat: Max Level
                stats.push({
                    label: 'Maksimum Seviye',
                    value: `${level}/${bData.maxLevel}`,
                    isIncrease: false
                });

                // Building-specific stats
                switch(buildingKey) {
                    case 'iron_mine':
                    case 'lumber_mill':
                    case 'crystal_cavern':
                        // Resource buildings - dungeon difficulty increases
                        const baseDifficulty = 1;
                        const difficultyIncrease = 0.15;
                        const currentDiff = Math.floor(baseDifficulty * (1 + (level - 1) * difficultyIncrease) * 10) / 10;
                        const nextDiff = Math.floor(baseDifficulty * (1 + level * difficultyIncrease) * 10) / 10;
                        
                        // dl bonusu: Her seviye +%3
                        const baseRewardMult = 1.0;
                        const rewardPerLevel = 0.03;
                        const currentRewardMult = Math.floor((baseRewardMult + (level - 1) * rewardPerLevel) * 100) / 100;
                        const nextRewardMult = Math.floor((baseRewardMult + level * rewardPerLevel) * 100) / 100;

                        if(level < bData.maxLevel) {
                            stats.push({
                                label: 'Zorluk Seviyesi',
                                value: nextDiff.toFixed(1),
                                change: `+${(nextDiff - currentDiff).toFixed(1)}`,
                                isIncrease: true
                            });
                            stats.push({
                                label: 'dl Bonusu',
                                value: `+${Math.round((nextRewardMult - 1) * 100)}%`,
                                change: `+${Math.round((nextRewardMult - currentRewardMult) * 100)}%`,
                                isIncrease: true
                            });
                        } else {
                            stats.push({
                                label: 'Zorluk Seviyesi',
                                value: currentDiff.toFixed(1),
                                isIncrease: false
                            });
                            stats.push({
                                label: 'dl Bonusu',
                                value: `+${Math.round((currentRewardMult - 1) * 100)}%`,
                                isIncrease: false
                            });
                        }
                        break;

                    case 'forge':
                        // Forge slots
                        const baseSlots = 2;
                        const slotsPer5Levels = 1;
                        const currentSlots = baseSlots + Math.floor((level - 1) / 5) * slotsPer5Levels;
                        const nextSlots = level >= bData.maxLevel ? currentSlots : baseSlots + Math.floor(level / 5) * slotsPer5Levels;
                        
                        if(level < bData.maxLevel) {
                            stats.push({
                                label: 'retim Slotlar',
                                value: nextSlots,
                                change: nextSlots > currentSlots ? `+${nextSlots - currentSlots}` : '',
                                isIncrease: nextSlots > currentSlots
                            });
                        } else {
                            stats.push({
                                label: 'retim Slotlar',
                                value: currentSlots,
                                isIncrease: false
                            });
                        }
                        break;

                    case 'enchant_tower':
                        // Enchant success rate (+1% per level)
                        const currentRate = level;
                        const nextRate = level >= bData.maxLevel ? currentRate : nextLevel;
                        
                        if(level < bData.maxLevel) {
                            stats.push({
                                label: 'By Baar ans',
                                value: `+${nextRate}%`,
                                change: '+1%',
                                isIncrease: true
                            });
                        } else {
                            stats.push({
                                label: 'By Baar ans',
                                value: `+${currentRate}%`,
                                isIncrease: false
                            });
                        }
                        break;

                    case 'trade_port':
                        // Trade port: listing limit and fee reduction
                        const baseListings = 3;
                        const listingsPerLevel = 2;
                        const currentListings = baseListings + (level - 1) * listingsPerLevel;
                        const nextListings = level >= bData.maxLevel ? currentListings : baseListings + level * listingsPerLevel;
                        
                        const currentFee = level >= 20 ? 5 : level >= 10 ? 7 : 10;
                        const nextFee = nextLevel >= 20 ? 5 : nextLevel >= 10 ? 7 : 10;
                        
                        if(level < bData.maxLevel) {
                            stats.push({
                                label: 'lan Limiti',
                                value: nextListings,
                                change: `+${nextListings - currentListings}`,
                                isIncrease: true
                            });
                            stats.push({
                                label: 'Pazar creti',
                                value: `${nextFee}%`,
                                change: nextFee < currentFee ? `-${currentFee - nextFee}%` : '',
                                isIncrease: nextFee > currentFee
                            });
                        } else {
                            stats.push({
                                label: 'lan Limiti',
                                value: currentListings,
                                isIncrease: false
                            });
                            stats.push({
                                label: 'Pazar creti',
                                value: `${currentFee}%`,
                                isIncrease: false
                            });
                        }
                        break;
                }

                return stats;
            },

            async confirmUpgrade(buildingKey) {
                const bData = BUILDING_DATA[buildingKey];
                const currentLevel = gameState.buildings[buildingKey].level;
                const cost = bData.getCost(currentLevel);

                // Check if player can afford
                for(const [res, amt] of Object.entries(cost)) {
                    if(gameState.player[res] < amt) {
                        return UI.showToast("Yetersiz kaynak!", "error");
                    }
                }

                // Deduct resources
                for(const [res, amt] of Object.entries(cost)) {
                    gameState.player[res] -= amt;
                }

                // Upgrade building
                gameState.buildings[buildingKey].level++;
                const newLevel = gameState.buildings[buildingKey].level;

                // FIX: Clear memoize cache for building cost functions when upgraded
                // This ensures getCost returns correct values for the new level
                if (BUILDING_DATA[buildingKey].getCost && BUILDING_DATA[buildingKey].getCost.cache) {
                    BUILDING_DATA[buildingKey].getCost.cache.clear();
                }

                // Save and update UI
                PlayerSystem.save();
                
                UI.hideModal();
                
                // Show success message
                UI.showToast(`${bData.name} Seviye ${newLevel}'e ykseltildi!`, "success");
                
                // Re-render building view
                this.selectBuilding(buildingKey);
                
                // Update top bar resources
                PlayerSystem.updateUI();
            },

            selectBuilding(buildingKey) {
                const bData = BUILDING_DATA[buildingKey];
                const currentLevel = gameState.buildings[buildingKey].level;
                const isMax = currentLevel >= bData.maxLevel;
                const cost = bData.getCost(currentLevel);
                
                document.getElementById('view-title').innerText = `${bData.icon} ${bData.name} (Svy ${currentLevel})`;
                
                let viewHtml = `
                    <button style="margin-bottom:20px; background:var(--bg-tertiary); border:var(--border-subtle); color:var(--text-secondary); width:auto; padding:8px 15px;" onclick="BuildingSystem.renderMainView()">${LangSys.get('back_to_town')}</button>
                    <div class="card" style="max-width: 600px;">
                        <h3 class="text-gold" style="margin-bottom: 10px;">${LangSys.get('building_details')}</h3>
                        <p class="text-secondary" style="margin-bottom: 15px;">${bData.desc}</p>
                `;

                // Passive check removed: UI no longer references getProd

                if(isMax) {
                    viewHtml += `<div class="text-gold" style="padding: 10px; border: 1px solid var(--accent-gold); text-align:center; border-radius: 4px;">${LangSys.get('max_reached')}</div>`;
                } else {
                    let costHtml = '';
                    let canAfford = true;
                    for(const [res, amt] of Object.entries(cost)) {
                        const hasEnough = gameState.player[res] >= amt;
                        if(!hasEnough) canAfford = false;
                        costHtml += `<div style="display:flex; justify-content:space-between; margin-bottom: 4px; ${hasEnough?'color:var(--text-primary)':'color:var(--rarity-mythic)'}">
                            <span>${LangSys.get('res_' + res) || (res.charAt(0).toUpperCase() + res.slice(1))}</span>
                            <span>${UI.formatNumber(gameState.player[res])} / ${UI.formatNumber(amt)}</span>
                        </div>`;
                    }
                    
                    viewHtml += `
                        <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px; border: var(--border-subtle);">
                            <h4 style="margin-bottom: 10px;">${LangSys.get('upgrade_cost')}:</h4>
                            ${costHtml}
                        </div>
                        <button id="btn-upgrade-building" style="width:100%; padding:15px; font-size:1.1rem; ${!canAfford ? 'opacity:0.5; cursor:not-allowed;' : ''}" ${!canAfford ? 'disabled' : ''} onclick="BuildingSystem.showUpgradeModal('${buildingKey}')">
                             Ykseltme Detaylarn Gr
                        </button>
                    `;
                }

                // Add "Enter Dungeon" for the 3 gather zones
                if (['iron_mine', 'lumber_mill', 'crystal_cavern'].includes(buildingKey)) {
                    viewHtml += `
                        <div style="margin-top:20px; padding-top:20px; border-top: 1px dashed var(--border-subtle);">
                            <button onclick="DungeonSystem.enterDungeon('${buildingKey}')" style="width:100%; padding:20px; font-size:1.3rem; background:var(--rarity-mythic); color:white; border:none; border-radius:8px; box-shadow: 0 0 15px rgba(255,50,50,0.5);">
                                 ${LangSys.get('enter_dungeon')}
                            </button>
                        </div>
                    `;
                }

                // Append custom views based on the building selected (Forge, Enchant, etc.)
                if(buildingKey === 'forge') {
                    const slotsCount = ItemSystem.getForgeSlots();
                    
                    viewHtml += `<div style="margin-top:30px; border-top: 1px dashed #333; padding-top:20px;">
                        <h4 class="text-gold" style="margin-bottom: 15px;">retim rsleri (${gameState.activeCrafts.length} / ${slotsCount} kullanmda)</h4>
                        
                        <!-- Active Crafts -->
                        <div id="active-crafts-container" style="display:flex; flex-direction:column; gap:15px; margin-bottom:20px;">
                            ${gameState.activeCrafts.length === 0 ? '<em class="text-muted">Aktif retim yok.</em>' : ''}
                        </div>
                        
                        <!-- Craft Options -->
                        <h4 style="margin-bottom: 15px;">Mevcut emalar</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px;">
                    `;

                    for(const [catId, catData] of Object.entries(ITEM_CATEGORIES)) {
                        const costStr = `Fe:${catData.cost.iron} W:${catData.cost.wood} Cr:${catData.cost.crystal} G:${catData.cost.gold}`;
                        
                        // Check affordability
                        const canAfford = gameState.player.iron >= catData.cost.iron &&
                                          gameState.player.wood >= catData.cost.wood &&
                                          gameState.player.crystal >= catData.cost.crystal &&
                                          gameState.player.gold >= catData.cost.gold;
                        const canSlot = gameState.activeCrafts.length < slotsCount;
                        const btnDisabled = !canAfford || !canSlot;

                        viewHtml += `
                            <div class="card" style="padding:10px; display:flex; flex-direction:column; align-items:center;">
                                <div style="font-size:2rem; margin-bottom:5px;">${catData.icon}</div>
                                <strong style="font-family:var(--font-display); margin-bottom:5px;">${catData.name}</strong>
                                <span style="font-size:0.75rem; color:var(--text-secondary); text-align:center; margin-bottom:10px;">Maliyet: ${costStr}</span>
                                <span style="font-size:0.75rem; color:var(--text-muted); margin-bottom:10px;">Sre: ${catData.craftTime}s</span>
                                <button style="width:100%; font-size:0.8rem; padding: 6px;" ${btnDisabled ? 'disabled' : ''} onclick="ItemSystem.startCraft('${catId}')">ret</button>
                            </div>
                        `;
                    }
                    
                    viewHtml += `</div></div>`;
                } else if (buildingKey === 'enchant_tower') {
                    viewHtml += `<div style="margin-top:30px; border-top: 1px dashed #333; padding-top:20px;">
                        <h4 class="text-gold" style="margin-bottom: 15px;">Byc</h4>
                        <p class="text-secondary" style="margin-bottom: 15px;">Bylemek iin envanterinizden bir eya sein. Uyar: Gl byler tehlikeli olabilir!</p>

                        <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px; border: var(--border-subtle); display:flex; flex-direction:column; align-items:center; min-height: 200px;" id="enchant-main-area">
                            <span class="text-muted" style="margin-top: 80px;">Envanterden bir eya sein</span>
                        </div>

                        <!-- Envanter Blm -->
                        <div style="margin-top:25px; border-top: 1px dashed #333; padding-top:20px;">
                            <h4 class="text-gold" style="margin-bottom: 15px;"> Envanteriniz</h4>
                            <div id="enchant-inventory-grid" class="inventory-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 12px; max-height: 400px; overflow-y: auto;">
                                <!-- Envanter itemleri buraya doldurulacak -->
                            </div>
                        </div>
                    </div>`;
                } else if (buildingKey === 'trade_port') {
                    const lLevel = gameState.buildings.trade_port.level;
                    const maxListings = 3 + (lLevel * 2);
                    const feeRate = lLevel >= 20 ? 0.05 : lLevel >= 10 ? 0.07 : 0.10;

                    viewHtml += `<div style="margin-top:30px; border-top: 1px dashed #333; padding-top:20px;">
                        <h4 class="text-gold" style="margin-bottom: 15px;">Pazar Yeri Eriimi</h4>
                        <div style="display:flex; justify-content:space-between; font-size:0.9rem; color:var(--text-secondary); margin-bottom: 15px;">
                            <span>zin Verilen Aktif Listelemeler: ${maxListings}</span>
                            <span>Pazar creti: ${(feeRate * 100).toFixed(0)}%</span>
                        </div>
                        <button style="width:100%; background: var(--rarity-rare); color: white; padding: 15px; font-size: 1.1rem;" onclick="MarketplaceSystem.openMarket()">Kresel Pazara Gz At</button>
                        <button style="width:100%; margin-top:10px; background: rgba(212,160,23,0.15); border-color:var(--accent-gold); color:var(--accent-gold); padding:12px; font-size:1rem;" onclick="LeaderboardSystem.openLeaderboard()"> ${LangSys.get('leaderboard')}</button>

                        <div style="margin-top:20px; display:flex; gap:10px;">
                            <button style="flex:1;" onclick="MarketplaceSystem.openMyListings()">lanlarm</button>
                            <button style="flex:1;" onclick="TradeSystem.openIncoming()">Takas Teklifleri</button>
                        </div>

                        <div style="margin-top:30px; border-top: 1px dashed #333; padding-top:20px;">
                            <h4 class="text-gold" style="margin-bottom: 15px;">Dorudan Takas</h4>
                            <p class="text-secondary" style="font-size:0.9rem; margin-bottom: 10px;">Baka bir oyuncuya gvenli bir takas teklifi gnderin. Oyuncu kimliine ihtiyacnz var.</p>
                            <input type="text" id="trade-target-id" placeholder="Hedef Oyuncu ID (r: player_123_abc)" style="width:100%; padding: 10px; margin-bottom: 10px;">
                            <button style="width:100%; background: var(--accent-purple); color: white;" onclick="TradeSystem.initiateTradeSetup()">Teklif Olutur</button>
                        </div>
                    </div>`;
                }

                viewHtml += `</div>`;

                const container = document.getElementById('view-container');
                container.innerHTML = viewHtml;

                // Enchant Tower iin envanter grid'ini doldur
                if(buildingKey === 'enchant_tower') {
                    setTimeout(() => {
                        EnchantSystem.renderEnchantInventoryGridOnOpen();
                    }, 100);
                }
            },

            upgradeBuilding(key) {
                const bData = BUILDING_DATA[key];
                const currentLevel = gameState.buildings[key].level;
                if(currentLevel >= bData.maxLevel) return;

                const cost = bData.getCost(currentLevel);
                
                // Deduct Cost
                for(const [res, amt] of Object.entries(cost)) {
                    gameState.player[res] -= amt;
                }
                
                // Upgrade
                gameState.buildings[key].level++;

                // XP Gain: Building_tier  50 XP
                const xpGain = Math.ceil(gameState.buildings[key].level / 10) * 50;
                LevelSystem.addXp(xpGain);

                // Check if building reached max
                if(gameState.buildings[key].level >= bData.maxLevel) {
                    gameState.player.stats.buildingsMaxed = (gameState.player.stats.buildingsMaxed || 0) + 1;
                    AchievementSystem.check('buildingsMaxed', gameState.player.stats.buildingsMaxed);
                }

                UI.showToast(`${bData.name} upgraded to Seviye ${gameState.buildings[key].level}!`, 'success');
                PlayerSystem.save();
                PlayerSystem.updateUI();
                this.selectBuilding(key); // Refresh view
            }
        };

        // --- B.5 DUNGEON & HERO SYSTEM --- //
        const DungeonSystem = {
            activeMonster: null,
            inCombat: false,
            activeDifficulty: null,

            enterDungeon(dungeonKey) {
                // Show difficulty selection modal first
                UI.showModal(`
                    <h2 class="text-gold" style="margin-bottom:20px;">${LangSys.get('choose_difficulty')}</h2>
                    <button class="diff-btn diff-normal" onclick="DungeonSystem.startDungeon('${dungeonKey}','normal'); UI.hideModal();">
                        <strong>${LangSys.get('diff_normal')}</strong>
                        <div style="font-size:0.85rem; color:var(--text-secondary); margin-top:4px;">${LangSys.get('diff_normal_desc')}</div>
                    </button>
                    <button class="diff-btn diff-hard" onclick="DungeonSystem.startDungeon('${dungeonKey}','hard'); UI.hideModal();">
                        <strong style="color:var(--rarity-legendary)">${LangSys.get('diff_hard')}</strong>
                        <div style="font-size:0.85rem; color:var(--text-secondary); margin-top:4px;">${LangSys.get('diff_hard_desc')}</div>
                    </button>
                    <button class="diff-btn diff-nightmare" onclick="DungeonSystem.startDungeon('${dungeonKey}','nightmare'); UI.hideModal();">
                        <strong style="color:var(--rarity-mythic)">${LangSys.get('diff_nightmare')}</strong>
                        <div style="font-size:0.85rem; color:var(--text-secondary); margin-top:4px;">${LangSys.get('diff_nightmare_desc')}</div>
                    </button>
                `);
            },

            startDungeon(dungeonKey, diffKey) {
                const level = gameState.buildings[dungeonKey].level;
                const diff = DIFFICULTY[diffKey];
                this.activeDifficulty = diff;

                // Instant win for dev mode
                if(DevMode.isInstantWin()) {
                    this.instantWin(dungeonKey, level, diff);
                    return;
                }

                const hpBase = dungeonKey === 'crystal_cavern' ? 500 : (dungeonKey === 'lumber_mill' ? 100 : 50);
                const atkBase = dungeonKey === 'crystal_cavern' ? 15 : (dungeonKey === 'lumber_mill' ? 5 : 2);

                // Pick random monster from pool
                const pool = MONSTER_POOLS[dungeonKey];
                const monsterTemplate = pool[Math.floor(Math.random() * pool.length)];

                this.activeMonster = {
                    key: dungeonKey,
                    name: monsterTemplate.name,
                    emoji: monsterTemplate.emoji,
                    ability: monsterTemplate.ability,
                    abilityDesc: monsterTemplate.abilityDesc,
                    maxHp: Math.floor(hpBase * level * diff.hpMult),
                    hp: Math.floor(hpBase * level * diff.hpMult),
                    atk: Math.floor((atkBase + (level * 2)) * diff.atkMult),
                    baseAtk: Math.floor((atkBase + (level * 2)) * diff.atkMult),
                    level: level,
                    abilityState: { hitsReceived: 0, turnsElapsed: 0 }
                };

                // Calculate hero stats including equipment
                const heroLevel = gameState.player.level || 1;
                let heroAtk = LevelSystem.getBaseAtk(heroLevel);
                let heroDef = 0;
                const eq = gameState.player.heroEquipped || {};
                if(eq.weapon) heroAtk += InventorySystem.applyEnchantMult(eq.weapon.stats.attack, eq.weapon.enchantLevel || 0);
                if(eq.armor)  heroDef += InventorySystem.applyEnchantMult(eq.armor.stats.defense,  eq.armor.enchantLevel  || 0);
                if(eq.ring)   { heroAtk += InventorySystem.applyEnchantMult(eq.ring.stats.attack, eq.ring.enchantLevel || 0); heroDef += InventorySystem.applyEnchantMult(eq.ring.stats.defense, eq.ring.enchantLevel || 0); }
                if(eq.amulet) { heroAtk += InventorySystem.applyEnchantMult(eq.amulet.stats.attack, eq.amulet.enchantLevel || 0); heroDef += InventorySystem.applyEnchantMult(eq.amulet.stats.defense, eq.amulet.enchantLevel || 0); }

                const heroMaxHp = LevelSystem.getMaxHp(heroLevel);

                // Kalc HP: player.heroHp'den bala (ilk girite maxHp)
                if(gameState.player.heroHp === undefined) gameState.player.heroHp = heroMaxHp;
                const startHp = Math.min(Math.max(1, gameState.player.heroHp), heroMaxHp);

                // Godmode: Always full HP
                const effectiveHp = DevMode.isGodmode() ? heroMaxHp : startHp;

                // ok dk HPde uyar ama engelleme (kapanmadan nce uyar)
                if(effectiveHp < 10 && !DevMode.isGodmode()) {
                    UI.showModal(`
                        <h3 style="color:var(--accent-danger); margin-bottom:12px;"> Kahraman ok Yaral!</h3>
                        <p style="margin-bottom:16px;">Kahramann sadece <strong>${Math.floor(effectiveHp)} HP</strong>'si var. yilemesini beklemeyi dn.</p>
                        <button style="width:100%; padding:12px;" onclick="UI.hideModal(); DungeonSystem.startDungeon('${dungeonKey}','${diffKey}', true)">Yine de Gir (${Math.floor(effectiveHp)} HP)</button>
                        <button style="width:100%; margin-top:8px; background:var(--bg-tertiary);" onclick="UI.hideModal()">ptal</button>
                    `);
                    // Check if forced
                    if(!arguments[2]) { this.inCombat = false; return; }
                }

                gameState.heroState = { hp: effectiveHp, maxHp: heroMaxHp, atk: heroAtk, def: heroDef, inCombat: true, battlePhase: 'player_turn', _isDefending: false };

                this.inCombat = true;
                // SECURITY FIX: Set combat lock timestamp to prevent regen exploit
                gameState.player._combatLock = Date.now();
                PlayerSystem.save();
                
                this.renderBattle();
            },

            instantWin(dungeonKey, level, diff) {
                // Simulate instant victory
                this.activeMonster = { key: dungeonKey, level: level };
                this.activeDifficulty = diff;
                
                // Direct victory without combat
                setTimeout(() => {
                    this.victory();
                }, 500);
            },

            renderBattle() {
                const container = document.getElementById('view-container');
                const mon = this.activeMonster;
                const hs = gameState.heroState;
                document.getElementById('view-title').innerText = `${LangSys.get('enter_dungeon')} - Seviye ${mon.level}`;

                const monPct = Math.max(0, (mon.hp / mon.maxHp) * 100);
                const heroPct = Math.max(0, (hs.hp / hs.maxHp) * 100);
                const heroLevel = gameState.player.level || 1;
                const diffLabel = this.activeDifficulty ? LangSys.get(this.activeDifficulty.label) : 'Normal';
                const diffColor = diffLabel === LangSys.get('diff_nightmare') ? 'var(--rarity-mythic)' : (diffLabel === LangSys.get('diff_hard') ? 'var(--rarity-legendary)' : 'var(--rarity-common)');

                // Equipped items mini display
                const eq = gameState.player.heroEquipped || {};
                const eqIcons = ['weapon','armor','ring','amulet'].map(slot => {
                    const item = eq[slot];
                    return item ? `<span title="${item.subtype} +${item.enchantLevel||0}" style="font-size:1.2rem;">${ITEM_CATEGORIES[item.category]?.icon || ''}</span>` : `<span style="font-size:1rem; color:#444;" title="${LangSys.get('slot_'+slot)}"></span>`;
                }).join(' ');

                // Ability icon mapping
                const abilityIcons = { armor: '', poison: '', regen: '', enrage: '', breath: '', curse: '', none: '' };
                const abilityIcon = abilityIcons[mon.ability] || '';

                let html = `
                    <div class="combat-arena">
                        <!-- Turn Indicator Zone (centered over VS area) -->
                        <div id="turn-indicator-zone" style="position:relative; height:0; overflow:visible; z-index:100;"></div>

                        <!-- Battle Field - Side by Side Layout -->
                        <div class="battle-field">
                            <!-- PLAYER PANEL (LEFT) -->
                            <div class="player-panel">
                                <!-- Health Bar (TOP) -->
                                <div class="health-bar-container" style="margin-bottom:10px;">
                                    <div class="health-bar-fill hero-hp" id="hero-hp-bar" style="width: ${heroPct}%"></div>
                                    <div class="health-bar-text">
                                        <span id="hero-hp-text">${Math.floor(hs.hp)}</span> / ${hs.maxHp} HP
                                    </div>
                                </div>

                                <!-- Character Display (CENTER) -->
                                <div class="character-display" id="hero-display">
                                    <div class="character-sprite"></div>
                                    <div class="character-name">Kahraman</div>
                                    <span class="character-level">Svy ${heroLevel}</span>
                                </div>

                                <!-- Stats Panel (BOTTOM) -->
                                <div class="stats-panel">
                                    <div class="stats-row">
                                        <span class="stat-item"><span class="stat-icon"></span> ${hs.atk}</span>
                                        ${hs.def > 0 ? `<span class="stat-item"><span class="stat-icon"></span> ${hs.def}</span>` : ''}
                                    </div>
                                    <!-- Equipment Display -->
                                    <div class="equipment-display">
                                        ${eqIcons}
                                    </div>
                                </div>
                            </div>

                            <!-- VS ZONE (CENTER) -->
                            <div class="vs-zone">
                                <div class="vs-circle">VS</div>
                                <div class="vs-turn-indicator" id="vs-turn-text">HAZIR</div>
                            </div>

                            <!-- ENEMY PANEL (RIGHT) -->
                            <div class="enemy-panel">
                                <!-- Health Bar (TOP) -->
                                <div class="health-bar-container" id="monster-card" style="margin-bottom:10px;">
                                    <div class="health-bar-fill enemy-hp" id="enemy-hp-bar" style="width: ${monPct}%"></div>
                                    <div class="health-bar-text">
                                        <span id="enemy-hp-text">${Math.floor(mon.hp)}</span> / ${mon.maxHp} HP
                                    </div>
                                </div>

                                <!-- Enemy Display (CENTER) -->
                                <div class="character-display">
                                    ${abilityIcon ? `<div class="enemy-ability-icon" title="${mon.abilityDesc}">${abilityIcon}</div>` : ''}
                                    <div class="character-sprite" id="enemy-emoji">${mon.emoji}</div>
                                    <div class="character-name">${mon.name}</div>
                                    <span class="character-level">Svy ${mon.level}</span>
                                    <div style="margin-top:8px; font-size:0.75rem; color:${diffColor};">[${diffLabel}]</div>
                                    ${mon.ability !== 'none' ? `<div style="margin-top:8px; font-size:0.75rem; color:var(--rarity-epic);"> ${mon.abilityDesc}</div>` : ''}
                                </div>

                                <!-- Stats Panel (BOTTOM) -->
                                <div class="stats-panel">
                                    <div class="stats-row">
                                        <span class="stat-item"><span class="stat-icon"></span> ${mon.atk || (mon.level * 8)}</span>
                                        ${mon.def ? `<span class="stat-item"><span class="stat-icon"></span> ${mon.def}</span>` : ''}
                                    </div>
                                    <div class="equipment-display">
                                        <span class="equip-item" title="Dman"></span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Combat Actions (BOTTOM) -->
                        <div class="combat-actions" id="battle-actions">
                            <button id="btn-quick"  class="combat-btn btn-quick"  onclick="DungeonSystem.attackQuick()"> Hzl<br><small>0.75x  %100</small></button>
                            <button id="btn-normal" class="combat-btn btn-normal" onclick="DungeonSystem.attackNormal()"> Normal<br><small>1x  %15 krit</small></button>
                            <button id="btn-heavy"  class="combat-btn btn-heavy"  onclick="DungeonSystem.attackHeavy()"> Gl<br><small>1.6x  %30 skala</small></button>
                            <button id="btn-defend" class="combat-btn btn-defend" onclick="DungeonSystem.defend()"> Savun<br><small>-40% hasar</small></button>
                            <button id="btn-flee"   class="combat-btn btn-flee"   onclick="DungeonSystem.flee()"> Ka</button>
                        </div>

                        <!-- Combat Log (BOTTOM) -->
                        <div class="combat-log" id="combat-log">
                            <div class="combat-log-entry log-info"> Sava balad! ${mon.name} ile kar karyasn. <strong style="color:var(--accent-success)">SENN SIRAN!</strong></div>
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            },

            addToCombatLog(message, type = 'log-info') {
                const log = document.getElementById('combat-log');
                if(!log) return;
                const entry = document.createElement('div');
                entry.className = `combat-log-entry ${type}`;
                entry.textContent = message;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            },

            // --- TURN-BASED UTILITIES ---

            delay(ms) { return new Promise(r => setTimeout(r, ms)); },

            lockButtons() {
                document.querySelectorAll('.combat-btn').forEach(b => b.classList.add('locked'));
            },

            unlockButtons() {
                document.querySelectorAll('.combat-btn').forEach(b => b.classList.remove('locked'));
                const pw = document.getElementById('btn-power');
                if(pw) pw.disabled = !(gameState.heroState && gameState.heroState.powerCharged);
            },

            async showTurnIndicator(text, type) {
                const zone = document.getElementById('turn-indicator-zone');
                if(!zone) return;
                const el = document.createElement('div');
                el.className = `turn-indicator-overlay ${type}`;
                el.textContent = text;
                zone.appendChild(el);
                await this.delay(750);
                el.classList.add('fade-out');
                await this.delay(300);
                if(el.parentNode) el.remove();
                
                // Update VS zone turn text
                const vsText = document.getElementById('vs-turn-text');
                if(vsText) {
                    vsText.textContent = type === 'player' ? 'SENN TURN' : 'DMAN';
                    vsText.style.color = type === 'player' ? 'var(--accent-success)' : 'var(--accent-danger)';
                }
            },

            flashHeroHit() {
                const hd = document.getElementById('hero-display');
                if(hd) { hd.classList.add('hero-hit-flash'); setTimeout(() => hd.classList.remove('hero-hit-flash'), 450); }
                const flash = document.getElementById('hero-damage-flash');
                if(flash) { flash.className = 'flash'; setTimeout(() => flash.className = '', 500); }
            },

            _flashAttack(type) {
                const colors = { quick:'rgba(0,140,255,0.3)', normal:'rgba(180,100,255,0.25)', heavy:'rgba(255,80,0,0.4)' };
                const flash = document.getElementById('power-flash');
                if(!flash) return;
                flash.style.background = colors[type] || colors.normal;
                flash.className = 'flash';
                setTimeout(() => { flash.className = ''; flash.style.background = ''; }, 350);
            },

            _shakeScreen() {
                const arena = document.querySelector('.combat-arena');
                if(!arena) return;
                arena.classList.add('screen-shake');
                setTimeout(() => arena.classList.remove('screen-shake'), 350);
            },

            _showMissText() {
                const zone = document.querySelector('.vs-zone');
                if(!zone) return;
                const el = document.createElement('div');
                el.className = 'damage-float normal';
                el.style.cssText = 'position:absolute; color:#aaa; font-size:1.5rem; left:50%; top:50%; transform:translate(-50%, -50%); text-align:center;';
                el.textContent = 'ISKALADI!';
                zone.appendChild(el);
                setTimeout(() => el.remove(), 900);
            },

            playEnemyAttackAnim() {
                const ee = document.getElementById('enemy-emoji');
                if(!ee) return;
                ee.classList.add('enemy-lunge');
                setTimeout(() => ee.classList.remove('enemy-lunge'), 500);
            },

            setDefendingVisual(on) {
                const hd = document.getElementById('hero-display');
                const playerPanel = document.querySelector('.player-panel');
                if(!hd) return;
                if(on) {
                    hd.classList.add('defending-aura');
                    if(playerPanel) playerPanel.style.borderColor = 'rgba(0, 200, 255, 0.8)';
                } else {
                    hd.classList.remove('defending-aura');
                    if(playerPanel) playerPanel.style.borderColor = '';
                }
            },

            updateHpBars() {
                const mon = this.activeMonster;
                const hs = gameState.heroState;
                if(!mon || !hs) return;
                const monPct = Math.max(0, (mon.hp / mon.maxHp) * 100);
                const heroPct = Math.max(0, (hs.hp / hs.maxHp) * 100);
                const enemyBar = document.getElementById('enemy-hp-bar');
                const enemyTxt = document.getElementById('enemy-hp-text');
                const heroBar  = document.getElementById('hero-hp-bar');
                const heroTxt  = document.getElementById('hero-hp-text');
                if(enemyBar) enemyBar.style.width = monPct + '%';
                if(enemyTxt) enemyTxt.textContent = Math.floor(mon.hp);
                if(heroBar)  heroBar.style.width  = heroPct + '%';
                if(heroTxt)  heroTxt.textContent  = Math.floor(hs.hp);
            },

            // --- ENEMY AI ---

            enemyAI() {
                const mon = this.activeMonster;
                const hs = gameState.heroState;
                const hpPct = mon.hp / mon.maxHp;
                const hasAbility = mon.ability && mon.ability !== 'none';
                // Kahraman savunmadaysa yetenei tercih et
                if (hs._isDefending && hasAbility && Math.random() < 0.55) return 'ability';
                if (hpPct < 0.25) {
                    return (hasAbility && Math.random() < 0.55) ? 'ability' : 'attack';
                } else if (hpPct < 0.5) {
                    return (hasAbility && Math.random() < 0.30) ? 'ability' : 'attack';
                } else {
                    return (hasAbility && Math.random() < 0.15) ? 'ability' : 'attack';
                }
            },

            // --- MONSTER TURN ---

            async monsterTurn() {
                const mon = this.activeMonster;
                const hs = gameState.heroState;
                if(!this.inCombat || !mon || !hs) return;

                await this.showTurnIndicator(' DMAN SIRASIN!', 'enemy');
                await this.delay(200);

                const aiAction = this.enemyAI();
                let monDamage = mon.atk;

                if (aiAction === 'ability') {
                    switch(mon.ability) {
                        case 'enrage':
                            if(mon.hp < mon.maxHp * 0.3) {
                                mon.atk = Math.floor(mon.baseAtk * 2);
                                monDamage = mon.atk;
                                this.addToCombatLog(` ${mon.name} ldrd! Saldr gc 2 katna kt!`, 'log-damage');
                            }
                            break;
                        case 'breath':
                            monDamage = Math.floor(mon.atk * 3);
                            this.addToCombatLog(` ${mon.name} ate pskrtyor!  KAT HASAR!`, 'log-damage');
                            break;
                        case 'regen': {
                            const healAmt = Math.floor(mon.maxHp * 0.1);
                            mon.hp = Math.min(mon.maxHp, mon.hp + healAmt);
                            this.addToCombatLog(` ${mon.name} kendini iyiletirdi! +${healAmt} HP`, 'log-heal');
                            this.updateHpBars();
                            monDamage = Math.floor(mon.atk * 0.7);
                            break;
                        }
                        case 'curse':
                            if(!hs._cursed) {
                                hs._curseAtk = hs.atk;
                                hs.atk = Math.floor(hs.atk * 0.7);
                                hs._cursed = true;
                                hs._curseTimer = 3;
                                this.addToCombatLog(` ${mon.name} seni lanetledi! Saldr gcn %30 dt.`, 'log-damage');
                            }
                            monDamage = Math.floor(mon.atk * 0.8);
                            break;
                        case 'poison':
                            monDamage = Math.floor(mon.atk * 2);
                            this.addToCombatLog(` ${mon.name} zehir saldrs! FT HASAR!`, 'log-damage');
                            break;
                        // armor = savunma yetenei, saldr yetenei deil  normal saldr
                    }
                }

                // Lanet countdown
                if(hs._cursed) {
                    hs._curseTimer--;
                    if(hs._curseTimer <= 0) {
                        hs.atk = hs._curseAtk;
                        delete hs._curseAtk; delete hs._cursed; delete hs._curseTimer;
                        this.addToCombatLog(` Lanet sona erdi! Saldr gcn geri dnd.`, 'log-heal');
                    }
                }

                this.playEnemyAttackAnim();
                await this.delay(450);

                // Percentage-based defense (diminishing returns, max 75% reduction)
                const defVal = hs.def || 0;
                const defPct = Math.min(0.75, defVal / (defVal + 80));
                const defendMult = hs._isDefending ? 0.6 : 1.0;
                const effectiveDamage = Math.max(1, Math.floor(monDamage * defendMult * (1 - defPct)));

                if(hs._isDefending) {
                    this.addToCombatLog(` Savunma! ${mon.name}'in ${monDamage} hasar  ${effectiveDamage} oldu.`, 'log-damage');
                } else {
                    this.addToCombatLog(`${mon.name} saldryor! ${effectiveDamage} hasar aldn.`, 'log-damage');
                }

                hs.hp -= effectiveDamage;
                this.flashHeroHit();

                if(hs._isDefending) {
                    hs._isDefending = false;
                    this.setDefendingVisual(false);
                }

                mon.abilityState.turnsElapsed = (mon.abilityState.turnsElapsed || 0) + 1;
                this.updateHpBars();
                await this.delay(300);

                if(hs.hp <= 0) {
                    hs.hp = 0;
                    this.updateHpBars();
                    this.addToCombatLog(` Kahraman yenik dt...`, 'log-damage');
                    hs.battlePhase = 'ended';
                    await this.delay(500);
                    this.defeat();
                    return;
                }

                hs.battlePhase = 'player_turn';
                await this.showTurnIndicator(' SENN SIRAN!', 'player');
                this.unlockButtons();
            },

            async defend() {
                if(!this.inCombat) return;
                const hs = gameState.heroState;
                if(hs.battlePhase !== 'player_turn') return;
                hs.battlePhase = 'animating';
                this.lockButtons();

                hs._isDefending = true;
                this.setDefendingVisual(true);
                this.addToCombatLog(' Savunma pozisyonu aldn! Gelen hasar byk lde azalacak.', 'log-info');

                await this.delay(400);
                await this.monsterTurn();
            },

            showDamageNumber(damage, isCrit, isHeavy) {
                const vsZone = document.querySelector('.vs-zone');
                if(!vsZone) return;
                const el = document.createElement('div');
                el.className = `damage-float ${isHeavy ? 'power' : (isCrit ? 'crit' : 'normal')}`;
                el.style.cssText = 'position:absolute; left:50%; top:40%; transform:translate(-50%, -50%); text-align:center;';
                el.innerText = (isHeavy ? ' ' : (isCrit ? ' ' : '')) + damage;
                vsZone.appendChild(el);
                setTimeout(() => el.remove(), 900);
            },

            // --- ATTACK TYPES ---

            attackQuick()  { this._doAttack('quick'); },
            attackNormal() { this._doAttack('normal'); },
            attackHeavy()  { this._doAttack('heavy'); },

            _doAttack(type) {
                const hs = gameState.heroState;
                if(!this.inCombat || !hs || hs.battlePhase !== 'player_turn') return;
                hs.battlePhase = 'animating';
                this.lockButtons();
                this._performAttack(type);
            },

            async _performAttack(type) {
                const hs = gameState.heroState;
                const mon = this.activeMonster;

                let damage = 0;
                let hit = true;
                let isCrit = false;
                let isHeavy = false;
                let logType = 'log-info';
                let logMsg = '';

                const base = Math.floor(hs.atk * (0.9 + Math.random() * 0.2));

                if(type === 'quick') {
                    damage = Math.floor(base * 0.75);
                    AudioSystem.click();
                    this._flashAttack('quick');
                    logMsg = ` Hzl Darbe! ${mon.name}'e ${damage} hasar verdin.`;
                }
                else if(type === 'normal') {
                    isCrit = Math.random() < 0.15;
                    damage = isCrit ? Math.floor(base * 1.5) : base;
                    if(isCrit) { AudioSystem.crit(); logType = 'log-crit'; logMsg = ` KRTK! ${mon.name}'e ${damage} hasar verdin!`; }
                    else       { AudioSystem.click(); logMsg = ` Normal Saldr. ${mon.name}'e ${damage} hasar verdin.`; }
                    this._flashAttack('normal');
                }
                else if(type === 'heavy') {
                    hit = Math.random() > 0.30;
                    if(hit) {
                        isHeavy = true;
                        damage = Math.floor(base * 1.6);
                        AudioSystem.powerStrike();
                        logType = 'log-power';
                        logMsg = ` Gl Darbe! ${mon.name}'e ${damage} hasar verdin!`;
                        this._flashAttack('heavy');
                        this._shakeScreen();
                    } else {
                        logMsg = ` Gl Darbe skalaad! ${mon.name} kat.`;
                        this._showMissText();
                        AudioSystem.click();
                    }
                }

                // Zrh yetenei
                if(hit && mon.ability === 'armor' && (mon.abilityState.hitsReceived || 0) < 3) {
                    damage = Math.floor(damage * 0.5);
                    mon.abilityState.hitsReceived = (mon.abilityState.hitsReceived || 0) + 1;
                    this.addToCombatLog(` ${mon.name}'in zrh hasar azaltt!`, 'log-info');
                }

                if(hit && damage > 0) {
                    mon.hp -= damage;
                    const enemyEmoji = document.getElementById('enemy-emoji');
                    if(enemyEmoji) { enemyEmoji.classList.add('enemy-hit'); setTimeout(() => enemyEmoji.classList.remove('enemy-hit'), 300); }
                    this.showDamageNumber(damage, isCrit, isHeavy);
                }

                this.addToCombatLog(logMsg, logType);
                this.updateHpBars();
                await this.delay(400);

                if(mon.hp <= 0) {
                    mon.hp = 0;
                    this.updateHpBars();
                    this.addToCombatLog(` ${mon.name} yenildi!`, 'log-heal');
                    hs.battlePhase = 'ended';
                    await this.delay(500);
                    this.victory();
                    return;
                }

                await this.monsterTurn();
            },

            victory() {
                this.inCombat = false;
                gameState.heroState.inCombat = false;
                // Kalc HP kaydet
                if(gameState.heroState && gameState.player) {
                    gameState.player.heroHp = Math.max(1, Math.floor(gameState.heroState.hp));
                    PlayerSystem.updateHeroHPDisplay();
                }

                const key = this.activeMonster.key;
                const lvl = this.activeMonster.level;
                const lootMult = this.activeDifficulty ? this.activeDifficulty.lootMult : 1;
                const gemChance = this.activeDifficulty ? this.activeDifficulty.gemChance : 0;
                
                // Building bonus: Her bina seviyesi iin +%3 dl art
                const buildingBonus = 1 + (lvl * 0.03);

                let resReward = 0;
                let resType = '';
                let goldReward = Math.floor(lvl * 20 * lootMult * buildingBonus);

                if(key === 'iron_mine')      { resType = 'iron';    resReward = Math.floor(10 * lvl * lootMult * buildingBonus); }
                else if(key === 'lumber_mill')  { resType = 'wood';    resReward = Math.floor(10 * lvl * lootMult * buildingBonus); }
                else if(key === 'crystal_cavern'){ resType = 'crystal'; resReward = Math.floor(2  * lvl * lootMult * buildingBonus); goldReward = Math.floor(lvl * 50 * lootMult * buildingBonus); }

                gameState.player[resType] += resReward;
                SecuritySys.addGold(goldReward);
                gameState.player.stats.totalGoldEarned = (gameState.player.stats.totalGoldEarned || 0) + goldReward;
                AchievementSystem.check('totalGoldEarned', gameState.player.stats.totalGoldEarned);

                // Gem drop for hard/nightmare
                let gemDropHtml = '';
                if(gemChance > 0 && Math.random() < gemChance) {
                    const gemAmt = Math.ceil(lvl * lootMult * 0.5);
                    gameState.player.gems = (gameState.player.gems || 0) + gemAmt;
                    gemDropHtml = `<div class="flex-between"><span> Gems</span> <strong style="color:var(--rarity-epic)">+${gemAmt}</strong></div>`;
                }

                // Monster kill stat tracking
                gameState.player.stats.monstersKilled = (gameState.player.stats.monstersKilled || 0) + 1;
                AchievementSystem.check('monstersKilled', gameState.player.stats.monstersKilled);
                DailySystem.trackProgress('kills', 1);

                // XP Gain: dungeon_level  difficulty_mult  10
                const xpGain = Math.floor(lvl * (this.activeDifficulty ? this.activeDifficulty.lootMult : 1) * 10);
                LevelSystem.addXp(xpGain);

                // Item Drop
                const dropChance = 0.10 + (lvl * 0.02);
                let droppedItem = null;
                let dropHtml = '';
                if(Math.random() <= dropChance) {
                    const categories = Object.keys(ITEM_CATEGORIES);
                    droppedItem = ItemSystem.generateCompletedItem(categories[Math.floor(Math.random() * categories.length)], true);
                    if(droppedItem) {
                        // Add dropped item to inventory using centralized function
                        InventorySystem.addToInventory(droppedItem, true);
                        dropHtml = `
                        <div style="margin-top:15px; padding-top:15px; border-top:1px dashed var(--rarity-epic);">
                            <h4 style="color:var(--rarity-legendary); margin-bottom:5px;">Nadir Eya Dt!</h4>
                            <div class="card" style="border-color:${RARITIES[droppedItem.rarity].color}; cursor:pointer; padding:10px;" onclick="InventorySystem.showItemDetails(InventorySystem.getItem('${droppedItem.id}'))">
                                <strong style="color:${RARITIES[droppedItem.rarity].color}">${droppedItem.subtype}</strong>
                                <span style="font-size:0.8rem; color:var(--text-secondary);"> (Grmek iin tkla)</span>
                            </div>
                        </div>`;
                    }
                }

                // Chest Drop System
                let chestDropHtml = '';
                if(ChestSystem.rollForChest(lvl)) {
                    const chestTier = ChestSystem.determineChestTier();
                    // FIX: Don't pre-generate loot - addChestToInventory now generates at open time
                    ChestSystem.addChestToInventory(chestTier);

                    chestDropHtml = `
                        <div style="margin-top:15px; padding-top:15px; border-top:1px dashed ${chestTier.color}; background: rgba(${chestTier.color}, 0.1); padding: 15px; border-radius: 8px;">
                            <h4 style="color: ${chestTier.color}; margin-bottom:10px;"> ${chestTier.name} Dt!</h4>
                            <p style="font-size:0.85rem; color:var(--text-secondary); margin-bottom:10px;">
                                Sandk envanterine eklendi. Amak iin envanterinden zerine tkla!
                            </p>
                            <div style="font-size:2rem; text-align:center; filter: drop-shadow(0 0 15px ${chestTier.color});">
                                ${chestTier.icon}
                            </div>
                        </div>`;
                }

                PlayerSystem.updateUI();
                PlayerSystem.save();

                UI.showModal(`
                    <h2 class="text-gold" style="font-size:2rem; margin-bottom:20px;">ZAFER!</h2>
                    <div style="text-align:center; font-size:4rem; margin-bottom:20px;"></div>
                    <p class="text-secondary" style="margin-bottom:20px;">Yendin: ${this.activeMonster.name}!</p>
                    <div style="background:var(--bg-tertiary); padding:15px; border-radius:8px;">
                        <h4 style="margin-bottom:10px;">Elde Edilen Ganimet:</h4>
                        <div class="flex-between"><span> Gold</span> <strong class="text-gold">+${UI.formatNumber(goldReward)}</strong></div>
                        <div class="flex-between"><span> ${LangSys.get('res_'+resType)}</span> <strong>+${UI.formatNumber(resReward)}</strong></div>
                        ${gemDropHtml}
                        ${dropHtml}
                        ${chestDropHtml}
                    </div>
                    <button style="width:100%; margin-top:20px; padding:15px;" onclick="UI.hideModal(); DungeonSystem.enterDungeon('${this.activeMonster.key}')">Sonrakine Saldr</button>
                    <button style="width:100%; margin-top:10px; background:var(--bg-tertiary); color:var(--text-primary);" onclick="UI.hideModal(); BuildingSystem.renderMainView();">Kasabaya Dn</button>
                `, true);
            },

            defeat() {
                this.inCombat = false;
                gameState.heroState.inCombat = false;
                // SECURITY FIX: Kalc HP kaydet (yenilgide ok dk HP kalsn - 1 HP)
                // Senkron kaydetme - sayfa yenileme exploit'ini nler
                if(gameState.heroState && gameState.player) {
                    gameState.player.heroHp = 1;
                    gameState.player._combatLock = Date.now(); // Combat lock'u gncelle
                    PlayerSystem.save(); // SENKRON KAYDET
                    PlayerSystem.updateHeroHPDisplay();
                }
                UI.showModal(`
                    <h2 style="color:var(--rarity-mythic); font-size:2rem; margin-bottom:20px;">YENLDN</h2>
                    <div style="text-align:center; font-size:4rem; margin-bottom:20px;"></div>
                    <p class="text-secondary" style="margin-bottom:20px;">Kahramann una yenik dt: ${this.activeMonster.name}.</p>
                    <button style="width:100%; padding:15px; background:var(--bg-tertiary); color:var(--text-primary);" onclick="UI.hideModal(); BuildingSystem.renderMainView();">Kasabaya Dn to Heal</button>
                `, true);
            },

            flee() {
                if(!this.inCombat) return;
                const hs = gameState.heroState;
                if(hs && hs.battlePhase !== 'player_turn') return;
                this.inCombat = false;
                if(hs) {
                    hs.inCombat = false; hs.battlePhase = 'ended';
                    if(gameState.player) {
                        gameState.player.heroHp = Math.max(1, Math.floor(hs.hp));
                        gameState.player._combatLock = Date.now();
                        PlayerSystem.save(); // SENKRON KAYDET
                        PlayerSystem.updateHeroHPDisplay();
                    }
                }
                BuildingSystem.renderMainView();
            }
        };

        // --- C. ITEM & CRAFTING SYSTEM --- //
        const RARITIES = {
            common:    { id: 'common', name: 'Common', color: 'var(--rarity-common)', mult: 1.0, prob: 0.60 },
            uncommon:  { id: 'uncommon', name: 'Uncommon', color: 'var(--rarity-uncommon)', mult: 1.2, prob: 0.25 },
            rare:      { id: 'rare', name: 'Rare', color: 'var(--rarity-rare)', mult: 1.5, prob: 0.10 },
            epic:      { id: 'epic', name: 'Epic', color: 'var(--rarity-epic)', mult: 2.0, prob: 0.04 },
            legendary: { id: 'legendary', name: 'Legendary', color: 'var(--rarity-legendary)', mult: 2.8, prob: 0.009 },
            mythic:    { id: 'mythic', name: 'Mythic', color: 'var(--rarity-mythic)', mult: 4.0, prob: 0.001 }
        };

        const ITEM_CATEGORIES = {
            swords: { name: 'Kllar', icon: '', subtypes: ['Ksa Kl', 'Uzun Kl', 'Byk Kl', 'Katana'], cost: { iron: 15, wood: 8, crystal: 0, gold: 10 }, craftTime: 30, stats: { atk: [20, 40], def: [0, 5], mag: [0, 10] } },
            axes: { name: 'Baltalar', icon: '', subtypes: ['Satr', 'Sava Baltas', 'Cenk Baltas', 'Cellat Baltas'], cost: { iron: 18, wood: 10, crystal: 0, gold: 10 }, craftTime: 35, stats: { atk: [25, 45], def: [0, 3], mag: [0, 5] } },
            armor: { name: 'Zrhlar', icon: '', subtypes: ['Zincir Zrh', 'Plaka Zrh', 'Kraliyet Zrh', 'Ejderha Pulu'], cost: { iron: 25, wood: 0, crystal: 5, gold: 20 }, craftTime: 60, stats: { atk: [0, 5], def: [25, 50], mag: [5, 15] } },
            shields: { name: 'Kalkanlar', icon: '', subtypes: ['Kk Kalkan', 'Uurtma Kalkan', 'Kule Kalkan', 'Aegis Kalkan'], cost: { iron: 20, wood: 12, crystal: 0, gold: 15 }, craftTime: 45, stats: { atk: [0, 3], def: [20, 40], mag: [0, 10] } },
            rings: { name: 'Yzkler', icon: '', subtypes: ['Bronz Yzk', 'Gm Yzk', 'Altn Yzk', 'Sihirli Yzk'], cost: { iron: 0, wood: 0, crystal: 10, gold: 30 }, craftTime: 45, stats: { atk: [5, 15], def: [5, 15], mag: [15, 30] } },
            amulets: { name: 'Tlsmlar', icon: '', subtypes: ['Kolye', 'Tlsm', 'G Kolyesi', 'Kraliyet Mcevheri'], cost: { iron: 0, wood: 0, crystal: 15, gold: 40 }, craftTime: 60, stats: { atk: [0, 10], def: [5, 15], mag: [20, 40] } }
        };

        // Equipment slot mapping by item category
        const EQUIP_SLOTS = { swords: 'weapon', axes: 'weapon', armor: 'armor', shields: 'armor', rings: 'ring', amulets: 'amulet' };

        // Daily Quest definitions
        const DAILY_QUESTS = [
            { id: 'kills',    reqKey: 'kills',    target: 5,  rewardKey: 'gold',    rewardAmt: 250, nameKey: 'quest_kill5'    },
            { id: 'crafts',   reqKey: 'crafts',   target: 1,  rewardKey: 'iron',    rewardAmt: 60,  nameKey: 'quest_craft1'   },
            { id: 'sells',    reqKey: 'sells',    target: 1,  rewardKey: 'gold',    rewardAmt: 350, nameKey: 'quest_sell1'    },
            { id: 'enchants', reqKey: 'enchants', target: 1,  rewardKey: 'crystal', rewardAmt: 25,  nameKey: 'quest_enchant1' }
        ];

        // Streak reward table (1-indexed, cycles through 7)
        const STREAK_REWARDS = [
            { gold: 100 },
            { iron: 60, wood: 60 },
            { gold: 400 },
            { crystal: 25 },
            { gems: 5 },
            { gold: 700, crystal: 40 },
            { gems: 20, gold: 1200 }  // Day 7
        ];

        // Achievement definitions
        const ACHIEVEMENTS = [
            { id: 'ach_kill10',   icon: '',  nameKey: 'ach_kill10_n',   req: { stat: 'monstersKilled', val: 10    }, reward: { gold: 100  } },
            { id: 'ach_kill100',  icon: '',  nameKey: 'ach_kill100_n',  req: { stat: 'monstersKilled', val: 100   }, reward: { gold: 500  } },
            { id: 'ach_kill1000', icon: '',  nameKey: 'ach_kill1000_n', req: { stat: 'monstersKilled', val: 1000  }, reward: { gems: 10   } },
            { id: 'ach_craft5',   icon: '',  nameKey: 'ach_craft5_n',   req: { stat: 'totalItemsCrafted', val: 5  }, reward: { iron: 100  } },
            { id: 'ach_craft50',  icon: '',  nameKey: 'ach_craft50_n',  req: { stat: 'totalItemsCrafted', val: 50 }, reward: { gems: 5    } },
            { id: 'ach_legendary',icon: '',  nameKey: 'ach_legendary_n',req: { stat: 'legendaryFound', val: 1     }, reward: { gems: 5    } },
            { id: 'ach_mythic',   icon: '',  nameKey: 'ach_mythic_n',   req: { stat: 'mythicFound', val: 1        }, reward: { gems: 20   } },
            { id: 'ach_sell10',   icon: '',  nameKey: 'ach_sell10_n',   req: { stat: 'totalItemsSold', val: 10    }, reward: { gold: 300  } },
            { id: 'ach_gold10k',  icon: '',  nameKey: 'ach_gold10k_n',  req: { stat: 'totalGoldEarned', val: 10000}, reward: { gems: 3    } },
            { id: 'ach_maxbuild', icon: '',  nameKey: 'ach_maxbuild_n', req: { stat: 'buildingsMaxed', val: 1     }, reward: { gems: 15   } }
        ];

        // Monster pool for each dungeon zone
        const MONSTER_POOLS = {
            iron_mine: [
                { name: 'Cave Bat',      emoji: '', ability: 'none',   abilityDesc: '' },
                { name: 'Iron Golem',    emoji: '', ability: 'armor',  abilityDesc: 'First 3 hits reduced by 50%' },
                { name: 'Shadow Spider', emoji: '', ability: 'poison', abilityDesc: 'Every 4th hit deals double damage' }
            ],
            lumber_mill: [
                { name: 'Corrupted Ent', emoji: '', ability: 'none',   abilityDesc: '' },
                { name: 'Forest Wraith', emoji: '', ability: 'regen',  abilityDesc: 'Heals 10% HP if not killed in 8 hits' },
                { name: 'Thornback Boar',emoji: '', ability: 'enrage', abilityDesc: 'ATK doubles below 30% HP' }
            ],
            crystal_cavern: [
                { name: 'Crystal Golem', emoji: '', ability: 'none',   abilityDesc: '' },
                { name: 'Void Lich',     emoji: '', ability: 'curse',  abilityDesc: 'Reduces hero ATK by 30% for 3 turns' },
                { name: 'Ancient Dragon',emoji: '', ability: 'breath', abilityDesc: 'Every 5th turn deals triple damage' }
            ]
        };

        // Difficulty tiers
        const DIFFICULTY = {
            normal:    { label: 'diff_normal',    hpMult: 1.0, atkMult: 1.0, lootMult: 1.0, gemChance: 0    },
            hard:      { label: 'diff_hard',      hpMult: 2.0, atkMult: 1.5, lootMult: 2.0, gemChance: 0.05 },
            nightmare: { label: 'diff_nightmare', hpMult: 4.0, atkMult: 2.5, lootMult: 3.5, gemChance: 0.15 }
        };

        // ========================================
        // CHEST SYSTEM DATA
        // ========================================
        const CHEST_TIERS = {
            common:    { id: 'common',    name: 'Sradan Sandk',   icon: '', color: '#9d9d9d', dropWeight: 70, sellPrice: 50 },
            uncommon:  { id: 'uncommon',  name: 'Nadir Sandk',     icon: '', color: '#0070dd', dropWeight: 25, sellPrice: 200 },
            legendary: { id: 'legendary', name: 'Efsanevi Sandk',  icon: '', color: '#ffd700', dropWeight: 5,  sellPrice: 500 }
        };

        const CHEST_LOOT_TABLES = {
            common: {
                gold: { min: 50, max: 200 },
                wood: { min: 20, max: 80 },
                iron: { min: 20, max: 80 },
                crystal: { min: 5, max: 25 },
                gems: { min: 0, max: 3, chance: 0.30 },
                item: { chance: 0.10, rarities: ['common'], categories: ['swords', 'axes', 'armor', 'shields'] }
            },
            uncommon: {
                gold: { min: 200, max: 600 },
                wood: { min: 80, max: 200 },
                iron: { min: 80, max: 200 },
                crystal: { min: 25, max: 80 },
                gems: { min: 2, max: 8, chance: 1.0 },
                item: { 
                    chance: 1.0, 
                    rarities: ['uncommon', 'rare'], 
                    rarityWeights: { uncommon: 80, rare: 20 },
                    categories: ['swords', 'axes', 'armor', 'shields', 'rings', 'amulets'] 
                }
            },
            legendary: {
                gold: { min: 800, max: 2500 },
                wood: { min: 200, max: 500 },
                iron: { min: 200, max: 500 },
                crystal: { min: 80, max: 250 },
                gems: { min: 10, max: 30, chance: 1.0 },
                item: { 
                    chance: 1.0, 
                    rarities: ['rare', 'epic', 'legendary', 'mythic'], 
                    rarityWeights: { rare: 60, epic: 30, legendary: 9, mythic: 1 },
                    categories: ['swords', 'axes', 'armor', 'shields', 'rings', 'amulets'] 
                },
                extraItem: { chance: 0.50, rarities: ['uncommon'], categories: ['swords', 'axes', 'armor', 'shields', 'rings', 'amulets'] }
            }
        };

        // ========================================
        // CHEST SYSTEM
        // ========================================
        const ChestSystem = {
            // Calculate chest drop chance based on building level
            calculateDropChance(buildingLevel) {
                const baseChance = 0.02; // 2% base
                const perLevelBonus = 0.004; // 0.4% per level
                const maxChance = 0.15; // 15% cap
                
                const chance = baseChance + (buildingLevel * perLevelBonus);
                return Math.min(chance, maxChance);
            },

            // Roll for chest drop
            rollForChest(buildingLevel) {
                const dropChance = this.calculateDropChance(buildingLevel);
                return Math.random() < dropChance;
            },

            // Determine chest tier based on weights
            determineChestTier() {
                const rand = Math.random() * 100;
                const totalWeight = 100; // 70 + 25 + 5
                
                if (rand < 70) return CHEST_TIERS.common;
                if (rand < 95) return CHEST_TIERS.uncommon;
                return CHEST_TIERS.legendary;
            },

            // Generate loot for a chest
            generateLoot(chestTier) {
                const lootTable = CHEST_LOOT_TABLES[chestTier.id];
                const loot = {
                    chestId: 'chest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                    tier: chestTier.id,
                    resources: {},
                    items: []
                };

                // Generate resources
                loot.resources.gold = this.randomInRange(lootTable.gold.min, lootTable.gold.max);
                loot.resources.wood = this.randomInRange(lootTable.wood.min, lootTable.wood.max);
                loot.resources.iron = this.randomInRange(lootTable.iron.min, lootTable.iron.max);
                loot.resources.crystal = this.randomInRange(lootTable.crystal.min, lootTable.crystal.max);

                // Gems (chance-based for common tier)
                if (lootTable.gems.chance >= 1.0 || Math.random() < lootTable.gems.chance) {
                    loot.resources.gems = this.randomInRange(lootTable.gems.min, lootTable.gems.max);
                } else {
                    loot.resources.gems = 0;
                }

                // Main item drop
                if (lootTable.item && Math.random() < lootTable.item.chance) {
                    const rarity = this.selectRarity(lootTable.item.rarities, lootTable.item.rarityWeights);
                    const category = lootTable.item.categories[Math.floor(Math.random() * lootTable.item.categories.length)];
                    const item = ItemSystem.generateCompletedItem(category, false, rarity);
                    if (item) {
                        loot.items.push(item);
                    }
                }

                // Extra item for legendary chests
                if (lootTable.extraItem && Math.random() < lootTable.extraItem.chance) {
                    const rarity = lootTable.extraItem.rarities[0];
                    const category = lootTable.extraItem.categories[Math.floor(Math.random() * lootTable.extraItem.categories.length)];
                    const item = ItemSystem.generateCompletedItem(category, false, rarity);
                    if (item) {
                        loot.items.push(item);
                    }
                }

                return loot;
            },

            // Helper: Random number in range
            randomInRange(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },

            // Helper: Select rarity based on weights
            selectRarity(rarities, weights) {
                if (!weights) return rarities[0];
                
                const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
                const rand = Math.random() * totalWeight;
                let cumulative = 0;
                
                for (const [rarity, weight] of Object.entries(weights)) {
                    cumulative += weight;
                    if (rand < cumulative) return rarity;
                }
                
                return rarities[0];
            },

            // Add chest to player inventory
            // SECURITY FIX: Don't pre-generate loot - generate at open time to prevent manipulation
            addChestToInventory(chestTier, loot = null) {
                const chestItem = {
                    id: 'chest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                    category: 'chest',
                    chestTier: chestTier.id,
                    name: chestTier.name,
                    icon: chestTier.icon,
                    color: chestTier.color,
                    // Don't store loot - generate at open time
                    opened: false
                };

                // FIX: Use centralized addToInventory for limit check
                InventorySystem.addToInventory(chestItem, true);
                PlayerSystem.save();

                return chestItem;
            },

            // Open a chest - generate loot at open time
            openChest(chestId) {
                const chestIndex = gameState.inventory.findIndex(i => i.id === chestId);
                if (chestIndex === -1) return null;

                const chest = gameState.inventory[chestIndex];
                if (chest.category !== 'chest' || chest.opened) return null;

                // SECURITY FIX: Generate loot at open time, not when chest is added
                const chestTier = CHEST_TIERS[chest.chestTier];
                const loot = this.generateLoot(chestTier);

                // Mark as opened and remove from inventory
                chest.opened = true;

                // Add resources to player
                SecuritySys.addGold(loot.resources.gold);
                gameState.player.wood += loot.resources.wood;
                gameState.player.iron += loot.resources.iron;
                gameState.player.crystal += loot.resources.crystal;
                if (loot.resources.gems > 0) {
                    gameState.player.gems = (gameState.player.gems || 0) + loot.resources.gems;
                }

                // Add items to inventory using centralized function (with limit check)
                loot.items.forEach(item => {
                    InventorySystem.addToInventory(item, true);
                });

                // Remove chest from inventory
                gameState.inventory.splice(chestIndex, 1);

                PlayerSystem.save();
                PlayerSystem.updateUI();

                return loot;
            },

            // Sell a chest
            sellChest(chestId) {
                const chestIndex = gameState.inventory.findIndex(i => i.id === chestId);
                if (chestIndex === -1) return false;

                const chest = gameState.inventory[chestIndex];
                if (chest.category !== 'chest') return false;

                const chestTier = CHEST_TIERS[chest.chestTier];
                SecuritySys.addGold(chestTier.sellPrice);

                gameState.inventory.splice(chestIndex, 1);
                PlayerSystem.save();
                PlayerSystem.updateUI();

                return true;
            },

            // Render chest opening animation
            renderChestOpening(chest) {
                const chestTier = CHEST_TIERS[chest.chestTier];
                
                UI.showModal(`
                    <div class="chest-opening-container">
                        <div class="chest-opening-header">
                            <h2 class="text-gold">${chestTier.icon} ${chestTier.name}</h2>
                        </div>
                        
                        <div class="chest-opening-stage" id="chest-stage-1">
                            <div class="chest-visual ${chestTier.id === 'legendary' ? 'legendary' : ''}" style="font-size: 8rem; filter: drop-shadow(0 0 30px ${chestTier.color});">
                                ${chestTier.icon}
                            </div>
                            <div class="chest-progress-bar">
                                <div class="chest-progress-fill" id="chest-progress"></div>
                            </div>
                            <p class="chest-status-text">Sandk alyor...</p>
                        </div>
                        
                        <div class="chest-opening-stage hidden" id="chest-stage-2">
                            <div class="chest-reward-container" id="chest-rewards">
                                <!-- Rewards will be injected here -->
                            </div>
                        </div>
                        
                        <div class="chest-actions hidden" id="chest-actions">
                            <button style="width:100%; padding:15px; font-size:1.1rem; background:var(--accent-gold); color:black;" onclick="UI.hideModal()">Tamam</button>
                        </div>
                    </div>
                `);

                // Start animation
                this.playChestAnimation(chest);
            },

            // Play chest opening animation
            playChestAnimation(chest) {
                const progressEl = document.getElementById('chest-progress');
                const stage1 = document.getElementById('chest-stage-1');
                const stage2 = document.getElementById('chest-stage-2');
                const actions = document.getElementById('chest-actions');
                const chestTier = CHEST_TIERS[chest.chestTier];
                
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 2;
                    if (progressEl) {
                        progressEl.style.width = progress + '%';
                    }

                    if (progress >= 100) {
                        clearInterval(interval);
                        
                        // Shake animation
                        const chestVisual = document.querySelector('.chest-visual');
                        if (chestVisual) {
                            chestVisual.classList.add('chest-shake');
                        }

                        // After shake, show rewards
                        setTimeout(() => {
                            stage1.classList.add('hidden');
                            stage2.classList.remove('hidden');
                            actions.classList.remove('hidden');
                            
                            this.showRewards(chest);
                        }, 1500);
                    }
                }, 30); // 1.5 seconds total
            },

            // Show rewards with animation
            showRewards(chest) {
                const container = document.getElementById('chest-rewards');
                const loot = chest.loot;
                const chestTier = CHEST_TIERS[chest.chestTier];
                
                let html = `
                    <div class="chest-opened-header" style="color: ${chestTier.color}; text-shadow: 0 0 20px ${chestTier.color};">
                         SANDIK AILDI! 
                    </div>
                    <div class="chest-rewards-grid">
                `;

                // Resources
                html += `
                    <div class="chest-reward-item fade-in" style="animation-delay: 0.1s;">
                        <div class="reward-icon"></div>
                        <div class="reward-amount text-gold">+${UI.formatNumber(loot.resources.gold)}</div>
                        <div class="reward-label">Altn</div>
                    </div>
                    <div class="chest-reward-item fade-in" style="animation-delay: 0.2s;">
                        <div class="reward-icon"></div>
                        <div class="reward-amount">+${UI.formatNumber(loot.resources.wood)}</div>
                        <div class="reward-label">Odun</div>
                    </div>
                    <div class="chest-reward-item fade-in" style="animation-delay: 0.3s;">
                        <div class="reward-icon"></div>
                        <div class="reward-amount">+${UI.formatNumber(loot.resources.iron)}</div>
                        <div class="reward-label">Demir</div>
                    </div>
                    <div class="chest-reward-item fade-in" style="animation-delay: 0.4s;">
                        <div class="reward-icon"></div>
                        <div class="reward-amount" style="color: var(--rarity-epic);">+${UI.formatNumber(loot.resources.crystal)}</div>
                        <div class="reward-label">Kristal</div>
                    </div>
                `;

                // Gems
                if (loot.resources.gems > 0) {
                    html += `
                        <div class="chest-reward-item fade-in" style="animation-delay: 0.5s;">
                            <div class="reward-icon"></div>
                            <div class="reward-amount" style="color: var(--rarity-mythic);">+${UI.formatNumber(loot.resources.gems)}</div>
                            <div class="reward-label">Gems</div>
                        </div>
                    `;
                }

                html += `</div>`;

                // Items
                if (loot.items && loot.items.length > 0) {
                    html += `<div class="chest-items-section">`;
                    loot.items.forEach((item, index) => {
                        const rarityData = RARITIES[item.rarity];
                        const itemName = item.subtype || item.name || 'Bilinmeyen Eya';
                        html += `
                            <div class="chest-item-card fade-in" style="animation-delay: ${0.6 + (index * 0.2)}s; border-color: ${rarityData.color};">
                                <div class="item-rarity-badge" style="background: ${rarityData.color};">${rarityData.name}</div>
                                <div class="item-icon">${item.icon || ''}</div>
                                <div class="item-name" style="color: ${rarityData.color};">${itemName}</div>
                            </div>
                        `;
                    });
                    html += `</div>`;
                }

                html += `</div>`;
                container.innerHTML = html;
            },

            // Show chest details modal (from inventory)
            showChestDetails(chest) {
                const chestTier = CHEST_TIERS[chest.chestTier];
                
                UI.showModal(`
                    <div class="chest-details-container">
                        <div class="chest-details-icon" style="font-size: 6rem; color: ${chestTier.color}; filter: drop-shadow(0 0 20px ${chestTier.color});">
                            ${chestTier.icon}
                        </div>
                        <h2 class="text-gold" style="margin: 15px 0;">${chestTier.name}</h2>
                        <p class="text-secondary" style="margin-bottom: 25px;">Bu sand aarak kaynaklar ve nadir eyalar kazanabilirsin!</p>
                        
                        <div class="chest-details-actions">
                            <button style="flex:1; padding:15px; font-size:1.1rem; background:var(--accent-gold); color:black;" onclick="ChestSystem.openChestFromInventory('${chest.id}')">
                                 Sand A
                            </button>
                            <button style="flex:1; padding:15px; font-size:1.1rem; background:var(--bg-tertiary); border-color:var(--accent-gold); color:var(--accent-gold);" onclick="MarketplaceSystem.showListingModal('${chest.id}')">
                                 Pazarda Sat
                            </button>
                        </div>
                    </div>
                `);
            },

            // Open chest from inventory (wrapper)
            openChestFromInventory(chestId) {
                const chestIndex = gameState.inventory.findIndex(i => i.id === chestId);
                if (chestIndex === -1) return;
                
                const chest = gameState.inventory[chestIndex];
                
                // Open and get loot
                const loot = this.openChest(chestId);
                if (!loot) return;
                
                // Show animation with the loot
                this.renderChestOpening({ ...chest, loot });
                
                // Refresh inventory UI
                if (typeof InventorySystem !== 'undefined' && InventorySystem.renderFullView) {
                    InventorySystem.renderFullView();
                }
            },

            // Sell chest from inventory (wrapper)
            sellChestFromInventory(chestId) {
                const success = this.sellChest(chestId);
                if (success) {
                    UI.hideModal();
                    UI.showToast("Sandk satld!", "success");
                    
                    // Refresh inventory UI
                    if (typeof InventorySystem !== 'undefined' && InventorySystem.renderFullView) {
                        InventorySystem.renderFullView();
                    }
                }
            }
        };

        // Helper: Convert hex color to RGB string
        // FIX: Added CSS variable support for hexToRgb
        function hexToRgb(hex) {
            // Handle CSS variables (e.g., 'var(--rarity-common)')
            if (typeof hex === 'string' && hex.startsWith('var(')) {
                // Extract CSS variable name
                const varName = hex.match(/var\(--([\w-]+)\)/);
                if (varName && varName[1]) {
                    // Get computed style from root
                    const root = document.documentElement;
                    const computedColor = getComputedStyle(root).getPropertyValue('--' + varName[1]).trim();
                    if (computedColor) {
                        // Recursively call with resolved color
                        return hexToRgb(computedColor);
                    }
                }
                return '157, 157, 157'; // Default gray fallback
            }
            
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ?
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` :
                '255, 255, 255';
        }

        const ItemSystem = {
            getForgeSlots() {
                const lvl = gameState.buildings.forge.level;
                if(lvl < 6) return 1;
                if(lvl < 11) return 2;
                if(lvl < 21) return 3;
                return 4;
            },

            startCraft(catId) {
                const cat = ITEM_CATEGORIES[catId];
                if(gameState.activeCrafts.length >= this.getForgeSlots()) return UI.showToast("No available craft slots!", "error");
                
                // Deduct cost
                if(gameState.player.iron < cat.cost.iron || gameState.player.wood < cat.cost.wood || 
                   gameState.player.crystal < cat.cost.crystal || gameState.player.gold < cat.cost.gold) {
                    return UI.showToast("Not enough resources.", "error");
                }

                gameState.player.iron -= cat.cost.iron;
                gameState.player.wood -= cat.cost.wood;
                gameState.player.crystal -= cat.cost.crystal;
                if(!SecuritySys.spendGold(cat.cost.gold)) {
                    UI.showToast("Yetersiz altn!", "error");
                    return;
                }
                PlayerSystem.updateUI();

                // Start timer
                const now = Date.now();
                const targetTime = now + (cat.craftTime * 1000);
                const craftId = 'craft_' + now + '_' + Math.floor(Math.random()*1000);
                
                gameState.activeCrafts.push({ id: craftId, catId: catId, startTime: now, targetTime: targetTime });
                PlayerSystem.save();
                
                // Refresh UI if forge is open
                if(document.getElementById('active-crafts-container')) {
                    BuildingSystem.selectBuilding('forge'); // re-render
                }
            },

            updateCraftTimers() {
                const container = document.getElementById('active-crafts-container');
                const now = Date.now();
                let completedIndexes = [];

                gameState.activeCrafts.forEach((craft, index) => {
                    if (now >= craft.targetTime) {
                        completedIndexes.push(index);
                    } else if (container) {
                        const totalTime = craft.targetTime - craft.startTime;
                        const elapsed = now - craft.startTime;
                        const pct = (elapsed / totalTime) * 100;
                        const remSec = Math.ceil((craft.targetTime - now) / 1000);
                        
                        // Try to find the progress bar to update without re-rendering everything
                        let craftRow = document.getElementById('craft-row-' + craft.id);
                        if (!craftRow) {
                            // Needs creation
                            craftRow = document.createElement('div');
                            craftRow.id = 'craft-row-' + craft.id;
                            craftRow.className = 'card';
                            craftRow.style.padding = '10px';
                            const rushCost = Math.max(1, Math.ceil(remSec / 10));
                            const canRush = (gameState.player.gems || 0) >= rushCost;
                            craftRow.innerHTML = `
                                <div class="flex-between" style="font-size:0.9rem;">
                                    <span>${ITEM_CATEGORIES[craft.catId].icon} Crafting ${ITEM_CATEGORIES[craft.catId].name}...</span>
                                    <span id="craft-time-${craft.id}">${remSec}s</span>
                                </div>
                                <div class="crafting-progress-bar">
                                    <div id="craft-fill-${craft.id}" class="crafting-progress-fill" style="width: ${pct}%"></div>
                                </div>
                                <div style="display:flex; justify-content:flex-end; margin-top:6px;">
                                    <button id="rush-btn-${craft.id}" style="font-size:0.75rem; padding:3px 10px; border-color:var(--rarity-epic); color:var(--rarity-epic); ${!canRush?'opacity:0.5':''}" ${!canRush?'disabled':''} onclick="ItemSystem.rushCraft('${craft.id}', ${rushCost})"> ${LangSys.get('rush_craft')} (${rushCost})</button>
                                </div>
                            `;
                            container.appendChild(craftRow);
                            // Remove empty state message if exists
                            const emptyMsg = container.querySelector('em');
                            if(emptyMsg) emptyMsg.remove();
                        } else {
                            // Update existing
                            document.getElementById('craft-time-' + craft.id).innerText = remSec + 's';
                            document.getElementById('craft-fill-' + craft.id).style.width = pct + '%';
                            // Update rush button cost
                            const rushCost = Math.max(1, Math.ceil(remSec / 10));
                            const canRush = (gameState.player.gems || 0) >= rushCost;
                            const rushBtn = document.getElementById('rush-btn-' + craft.id);
                            if(rushBtn) {
                                rushBtn.innerText = ` ${LangSys.get('rush_craft')} (${rushCost})`;
                                rushBtn.disabled = !canRush;
                                rushBtn.style.opacity = canRush ? '1' : '0.5';
                                rushBtn.setAttribute('onclick', `ItemSystem.rushCraft('${craft.id}', ${rushCost})`);
                            }
                        }
                    }
                });

                // Process completions
                if (completedIndexes.length > 0) {
                    // Sort descending to not mess up splice indexes
                    completedIndexes.sort((a,b)=>b-a).forEach(idx => {
                        const craft = gameState.activeCrafts[idx];
                        gameState.activeCrafts.splice(idx, 1);
                        this.generateCompletedItem(craft.catId);
                    });
                    PlayerSystem.save();
                    if(container) BuildingSystem.selectBuilding('forge'); // full re-render
                }
            },

            // FIX: Added forcedRarity parameter (3rd param) for chest loot and other forced rarity scenarios
            generateCompletedItem(catId, isDrop = false, forcedRarity = null) {
                // Envanter dolu mu kontrol et
                if(gameState.inventory.length >= 100) {
                    UI.showToast("Envanter dolu! Eya alnamad.", "error");
                    return null;
                }

                const cat = ITEM_CATEGORIES[catId];
                const forgeLevel = gameState.buildings.forge ? gameState.buildings.forge.level : 1;

                // 1. Rarity Roll (0-100000 + forge bonus)
                // Base: Com(0-59999) Unc(60000-84999) Rar(85000-94999) Epi(95000-98999) Leg(99000-99899) Myt(99900-99999)
                // FIX: Use forced rarity if provided (for chest loot), otherwise roll normally
                let rarity = forcedRarity;
                
                if (!rarity) {
                    // Cap forge bonus to prevent overflow (max +5000 bonus at forge level 10+)
                    // Without cap: forge level 50 = +25000 bonus = guaranteed mythic
                    // With cap: forge level 10+ = max +5000 bonus = still improves rates but not broken
                    const forgeBonus = Math.min(forgeLevel * 500, 5000);
                    let roll = Math.floor(Math.random() * 100000) + forgeBonus;

                    if(roll >= 99900 && forgeLevel >= 21) rarity = 'mythic';
                    else if (roll >= 99000 && forgeLevel >= 11) rarity = 'legendary';
                    else if (roll >= 95000 && forgeLevel >= 6) rarity = 'epic';
                    else if (roll >= 85000) rarity = 'rare';
                    else if (roll >= 60000) rarity = 'uncommon';
                    else rarity = 'common';
                }

                // 2. Subtype Selection based on rarity
                let subIdx = 0;
                const r = Math.random();
                if(rarity === 'common' || rarity === 'uncommon') {
                    if(r > 0.9) subIdx = 2; else if (r > 0.7) subIdx = 1; else subIdx = 0;
                } else if (rarity === 'rare' || rarity === 'epic') {
                    if(r > 0.8) subIdx = 3; else if (r > 0.4) subIdx = 2; else if (r > 0.1) subIdx = 1; else subIdx = 0;
                } else {
                    if(r > 0.4) subIdx = 3; else if (r > 0.1) subIdx = 2; else subIdx = 1;
                }
                const subtype = cat.subtypes[subIdx];

                // 3. Pattern & Quality
                const patternId = Math.floor(Math.random() * 1000) + 1;
                const qualityScore = Math.random(); // 0.0000 to 1.0000
                
                // 4. Stats Generation
                const rarityData = RARITIES[rarity];
                const stats = {
                    attack: Math.floor((Math.random() * (cat.stats.atk[1] - cat.stats.atk[0]) + cat.stats.atk[0]) * rarityData.mult),
                    defense: Math.floor((Math.random() * (cat.stats.def[1] - cat.stats.def[0]) + cat.stats.def[0]) * rarityData.mult),
                    magic: Math.floor((Math.random() * (cat.stats.mag[1] - cat.stats.mag[0]) + cat.stats.mag[0]) * rarityData.mult)
                };

                // Create Item
                const newItem = {
                    id: 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                    category: catId,
                    subtype: subtype,
                    rarity: rarity,
                    patternId: patternId,
                    qualityScore: parseFloat(qualityScore.toFixed(4)),
                    enchantLevel: 0,
                    craftedBy: isDrop ? "Dungeon" : gameState.player.id,
                    craftedByName: isDrop ? "Loot Drop" : gameState.player.name,
                    craftedAt: Date.now(),
                    season: 1,
                    tradeHistory: [],
                    stats: stats
                };

                // FIX: Use centralized addToInventory for limit check and consistency
                InventorySystem.addToInventory(newItem, !isDrop);
                
                if (!isDrop) {
                    gameState.player.stats.totalItemsCrafted++;
                    AchievementSystem.check('totalItemsCrafted', gameState.player.stats.totalItemsCrafted);
                    DailySystem.trackProgress('crafts', 1);

                    // XP Gain based on rarity
                    const xpValues = { common: 5, uncommon: 10, rare: 25, epic: 50, legendary: 100, mythic: 250 };
                    const xpGain = xpValues[rarity] || 5;
                    LevelSystem.addXp(xpGain);

                    // Track analytics
                    if (typeof Analytics !== 'undefined') {
                        Analytics.trackItemCraft(rarity, catId);
                    }
                }
                // Track rare items for achievements (both crafted and dropped)
                if(rarity === 'legendary' || rarity === 'mythic') {
                    if(rarity === 'legendary') { gameState.player.stats.legendaryFound++; AchievementSystem.check('legendaryFound', gameState.player.stats.legendaryFound); }
                    if(rarity === 'mythic')    { gameState.player.stats.mythicFound++;    AchievementSystem.check('mythicFound',    gameState.player.stats.mythicFound);    }
                }

                PlayerSystem.save(); // ENSURE PERSISTENCE

                // Play reveal animation (if user is active)
                if (!isDrop) {
                    if(typeof window.AudioSystem !== 'undefined') window.AudioSystem.craftReveal();
                    this.playRevealAnimation(newItem);
                }

                return newItem;
            },

            rushCraft(craftId, cost) {
                if((gameState.player.gems || 0) < cost) return UI.showToast(LangSys.get('not_enough_gems'), 'error');
                const idx = gameState.activeCrafts.findIndex(c => c.id === craftId);
                if(idx === -1) return;
                gameState.player.gems -= cost;
                gameState.activeCrafts[idx].targetTime = Date.now() - 1;
                PlayerSystem.updateUI();
                AudioSystem.success();
            },

            getPatternGradient(patternId, rarity) {
                const hue1 = (patternId * 137) % 360;
                const hue2 = (hue1 + 40 + (patternId % 60)) % 360;
                const saturation = rarity === 'mythic' ? 90 : rarity === 'legendary' ? 75 : 50;
                return `linear-gradient(${patternId % 180}deg, hsl(${hue1}, ${saturation}%, 15%), hsl(${hue2}, ${saturation}%, 25%))`;
            },

            playRevealAnimation(item) {
                const cat = ITEM_CATEGORIES[item.category];
                const rarityData = RARITIES[item.rarity];
                const gradient = this.getPatternGradient(item.patternId, item.rarity);
                
                // Step 1: Show silhouette and suspense
                UI.showModal(`
                    <div class="craft-reveal-container">
                        <h2 class="text-gold">retim Tamamland</h2>
                        <div class="craft-silhoutte" style="display:flex; justify-content:center; align-items:center; font-size:4rem; color:#333;">?</div>
                        <p class="text-secondary">Eya ortaya karlyor...</p>
                    </div>
                `, true); // Prevent close during animation

                // Step 2: Full reveal after 1.5s
                setTimeout(() => {
                    let qualityTextClass = 'text-secondary';
                    if(item.qualityScore < 0.01) qualityTextClass = 'text-gold';
                    else if (item.qualityScore < 0.1) qualityTextClass = 'text-uncommon'; // assuming uncommon is green
                    
                    const isMythic = item.rarity === 'mythic' ? 'mythic-glow' : '';

                    UI.showModal(`
                        <div class="craft-reveal-container">
                            <h2 style="color:${rarityData.color}; ${item.rarity==='mythic'?'text-shadow: 0 0 10px red;':''}">${rarityData.name} Kefedildi!</h2>
                            
                            <!-- ITEM CARD -->
                            <div class="item-card craft-reveal-item ${isMythic}" style="width: 250px; margin: 20px auto; border-color: ${rarityData.color}; cursor:default;">
                                <div class="item-card-pattern" style="background: ${gradient}; height:120px; font-size:4rem;">
                                    ${cat.icon}
                                </div>
                                <div class="item-card-body" style="text-align:left;">
                                    <div class="item-card-title" style="color:${rarityData.color}; font-size:1.1rem; border-bottom:1px solid #333; padding-bottom:5px; margin-bottom:5px;">
                                        ${item.subtype}
                                    </div>
                                    <div style="display:flex; justify-content:space-between;">
                                        <span class="text-muted">Desen #${item.patternId}</span>
                                        <span style="font-size:0.8rem; color:${item.qualityScore < 0.1 ? 'var(--rarity-uncommon)' : 'var(--text-secondary)'}">Q: ${item.qualityScore}</span>
                                    </div>
                                    <div style="margin-top: 10px; font-family:var(--font-display);">
                                        ${item.stats.attack > 0 ? `<div class="flex-between"><span>ATK</span> <span>${item.stats.attack}</span></div>` : ''}
                                        ${item.stats.defense > 0 ? `<div class="flex-between"><span>DEF</span> <span>${item.stats.defense}</span></div>` : ''}
                                        ${item.stats.magic > 0 ? `<div class="flex-between"><span>MAG</span> <span>${item.stats.magic}</span></div>` : ''}
                                    </div>
                                </div>
                            </div>

                            <button onclick="UI.hideModal(); AudioSystem.success();" style="margin-top:20px;">Eyay Al</button>
                        </div>
                    `, false);
                }, 1500);
            }
        };

        // --- D. INVENTORY SYSTEM --- //
        const InventorySystem = {
            openInventoryModal() {
                UI.showModal(`
                    <div style="width:100%; max-width:600px;">
                        <h3 class="text-gold" style="margin-bottom:20px; border-bottom:1px solid #444; padding-bottom:10px;">Envanter</h3>
                        <div id="inventory-grid-modal" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; max-height: 450px; overflow-y: auto; padding:5px;">
                            <!-- Items will be injected here -->
                        </div>
                    </div>
                `);
                this.renderModal();
            },

            renderModal() {
                const grid = document.getElementById('inventory-grid-modal');
                if(!grid) return;
                grid.innerHTML = '';
                
                if(gameState.inventory.length === 0) {
                    grid.innerHTML = '<span class="text-muted" style="grid-column: 1/-1; text-align:center; padding:20px;">Envanter bo.</span>';
                    return;
                }

                const items = [...gameState.inventory].sort((a,b) => b.craftedAt - a.craftedAt);

                items.forEach(item => {
                    const rarityData = RARITIES[item.rarity];
                    const gradient = ItemSystem.getPatternGradient(item.patternId, item.rarity);
                    const isMythic = item.rarity === 'mythic' ? 'mythic-glow' : '';
                    const stars = item.enchantLevel > 0 ? ''.repeat(item.enchantLevel) : '';
                    
                    const card = document.createElement('div');
                    card.className = `item-card ${isMythic}`;
                    card.style.borderColor = rarityData.color;
                    card.onclick = () => { UI.hideModal(); this.showItemDetails(item); };
                    
                    card.innerHTML = `
                        <div class="item-card-pattern" style="background: ${gradient}; height:80px; font-size:2.5rem;">
                            ${ITEM_CATEGORIES[item.category]?.icon || ''}
                        </div>
                        <div class="item-card-body">
                            <div class="item-card-title" style="color:${rarityData.color}; font-size:0.85rem;">${item.subtype}</div>
                            <div style="font-size:0.7rem;" class="text-gold">${stars}</div>
                        </div>
                    `;
                    grid.appendChild(card);
                });
            },

            render() {
                // Modal aksa gncelle
                this.renderModal();
                // Full view'i her zaman gncelle (view ak olmasa bile!)
                // Bylece inventory'ye tklandnda eyalar grnr
                this.renderFullView();
            },

            renderFullView() {
                // Reset new item badge when inventory is viewed
                gameState.player.newItemCount = 0;
                UI.updateNavBadges();

                const container = document.getElementById('view-inventory');
                if(!container) return;

                // Update count
                const countDisplay = document.getElementById('inventory-count-display');
                if(countDisplay) countDisplay.textContent = `${gameState.inventory.length}/100`;

                const title = container.querySelector('h1');
                if(title) title.innerHTML = ` Srt antas <span style="font-size:1rem; color:var(--text-secondary);">(${gameState.inventory.length}/100)</span>`;

                const grid = document.getElementById('inventory-grid-full');
                if(!grid) return;

                if(gameState.inventory.length === 0) {
                    grid.innerHTML = '<span class="text-muted" style="grid-column: 1/-1; text-align:center; padding:40px; font-size:1.2rem;">Heybendeki eyalar bitti. Maceraya devam et!</span>';
                    // Destroy virtual scroll if exists
                    VirtualScroller.destroy(grid);
                    return;
                }

                // Get current filter and sort
                const currentFilter = this.currentFilter || 'all';
                const currentSort = this.currentSort || 'newest';

                // Filter items
                let items = [...gameState.inventory];
                if(currentFilter !== 'all') {
                    const matchingCategories = Object.keys(ITEM_CATEGORIES).filter(
                        key => EQUIP_SLOTS[key] === currentFilter
                    );
                    items = items.filter(item =>
                        item.category === currentFilter ||
                        EQUIP_SLOTS[item.category] === currentFilter ||
                        matchingCategories.includes(item.category)
                    );
                }

                // Sort items
                if(currentSort === 'newest') items.sort((a,b) => b.craftedAt - a.craftedAt);
                else if(currentSort === 'rarity') {
                    const rarityOrder = { mythic: 6, legendary: 5, epic: 4, rare: 3, uncommon: 2, common: 1 };
                    items.sort((a,b) => rarityOrder[b.rarity] - rarityOrder[a.rarity]);
                }
                else if(currentSort === 'enchant') items.sort((a,b) => b.enchantLevel - a.enchantLevel);

                if(items.length === 0) {
                    grid.innerHTML = '<span class="text-muted" style="grid-column: 1/-1; text-align:center; padding:40px;">Bu kategoride eya yok.</span>';
                    VirtualScroller.destroy(grid);
                    return;
                }

                // Use Virtual Scroller for large inventories
                if (items.length > 50) {
                    Logger.debug('InventorySystem', 'Using virtual scroller for large inventory');
                    
                    // Item render function
                    const renderItem = (item, index) => {
                        const card = document.createElement('div');
                        
                        // Check if item is a chest
                        if(item.category === 'chest') {
                            const chestTier = CHEST_TIERS[item.chestTier];
                            card.className = 'inv-item-card chest-item';
                            card.style.borderColor = chestTier.color;
                            card.style.background = `linear-gradient(135deg, rgba(${hexToRgb(chestTier.color)}, 0.15), rgba(30, 30, 40, 0.9))`;
                            card.onclick = () => { this.showItemDetails(item); };
                            card.innerHTML = `
                                <div class="inv-item-icon" style="font-size:2.5rem; filter: drop-shadow(0 0 10px ${chestTier.color});">${chestTier.icon}</div>
                                <div class="inv-item-name" style="font-size:0.7rem; color:${chestTier.color}; font-weight:700;">${chestTier.name.split(' ')[0]}</div>
                            `;
                        } else {
                            const rarityData = RARITIES[item.rarity];
                            const isMythic = item.rarity === 'mythic' ? 'mythic-glow' : '';
                            const stars = item.enchantLevel > 0 ? ''.repeat(item.enchantLevel) : '';
                            const icon = ITEM_CATEGORIES[item.category]?.icon || '';

                            card.className = `inv-item-card ${item.rarity} ${isMythic}`;
                            card.style.borderColor = rarityData.color;
                            card.onclick = () => { this.showItemDetails(item); };

                            card.innerHTML = `
                                <div class="inv-item-icon">${icon}</div>
                                <div class="inv-item-enchant">${stars}</div>
                                <div class="inv-item-rarity">${item.rarity.charAt(0).toUpperCase()}</div>
                            `;
                        }
                        return card;
                    };

                    // Setup or update virtual scroll
                    if (!grid._virtualScroll) {
                        VirtualScroller.setupGrid(grid, items, renderItem, {
                            itemWidth: 100,
                            itemHeight: 120,
                            gap: 12
                        });
                    } else {
                        VirtualScroller.updateItems(grid, items);
                    }
                } else {
                    // Regular render for small inventories
                    Logger.debug('InventorySystem', 'Using regular render for small inventory');
                    VirtualScroller.destroy(grid);
                    grid.innerHTML = '';

                    items.forEach(item => {
                        const card = document.createElement('div');
                        
                        // Check if item is a chest
                        if(item.category === 'chest') {
                            const chestTier = CHEST_TIERS[item.chestTier];
                            card.className = 'inv-item-card chest-item';
                            card.style.borderColor = chestTier.color;
                            card.style.background = `linear-gradient(135deg, rgba(${hexToRgb(chestTier.color)}, 0.15), rgba(30, 30, 40, 0.9))`;
                            card.onclick = () => { this.showItemDetails(item); };
                            card.innerHTML = `
                                <div class="inv-item-icon" style="font-size:2.5rem; filter: drop-shadow(0 0 10px ${chestTier.color});">${chestTier.icon}</div>
                                <div class="inv-item-name" style="font-size:0.7rem; color:${chestTier.color}; font-weight:700;">${chestTier.name.split(' ')[0]}</div>
                            `;
                        } else {
                            const rarityData = RARITIES[item.rarity];
                            const isMythic = item.rarity === 'mythic' ? 'mythic-glow' : '';
                            const stars = item.enchantLevel > 0 ? ''.repeat(item.enchantLevel) : '';
                            const icon = ITEM_CATEGORIES[item.category]?.icon || '';

                            card.className = `inv-item-card ${item.rarity} ${isMythic}`;
                            card.style.borderColor = rarityData.color;
                            card.onclick = () => { this.showItemDetails(item); };

                            card.innerHTML = `
                                <div class="inv-item-icon">${icon}</div>
                                <div class="inv-item-enchant">${stars}</div>
                                <div class="inv-item-rarity">${item.rarity.charAt(0).toUpperCase()}</div>
                            `;
                        }
                        grid.appendChild(card);
                    });
                }
            },

            currentFilter: 'all',
            currentSort: 'newest',

            setFilter(filter) {
                this.currentFilter = filter;
                this.renderFullView();
                this.updateTabActiveState();
            },

            setSort(sort) {
                this.currentSort = sort;
                this.renderFullView();
            },

            updateTabActiveState() {
                document.querySelectorAll('.inv-tab').forEach(tab => {
                    tab.classList.remove('active');
                    const tabText = tab.textContent.toUpperCase();
                    if(
                        (this.currentFilter === 'all' && tabText.includes('TM')) ||
                        (this.currentFilter === 'weapon' && tabText.includes('SLAH')) ||
                        (this.currentFilter === 'armor' && tabText.includes('ZIRH')) ||
                        (this.currentFilter === 'ring' && tabText.includes('YZK')) ||
                        (this.currentFilter === 'amulet' && tabText.includes('TILSIM'))
                    ) {
                        tab.classList.add('active');
                    }
                });
            },

            showItemDetails(item, isEnchanting = false, isEquipped = false) {
                if(!item) {
                    console.warn('showItemDetails called with null item');
                    return UI.showToast("Eya bulunamad.", "error");
                }

                // Check if item is a chest
                if(item.category === 'chest') {
                    ChestSystem.showChestDetails(item);
                    return;
                }

                const cat = ITEM_CATEGORIES[item.category];
                const rarityData = RARITIES[item.rarity];
                const gradient = ItemSystem.getPatternGradient(item.patternId, item.rarity);
                const isMythic = item.rarity === 'mythic' ? 'mythic-glow' : '';

                // Check if item is equipped
                const slot = EQUIP_SLOTS[item.category];
                const eq = gameState.player.heroEquipped || {};
                const actuallyEquipped = isEquipped || (slot && eq[slot] && eq[slot].id === item.id);

                // Standard Detail Modal
                const modalHtml = `
                    <div style="display:flex; flex-direction:column; align-items:center;">
                        <h2 style="color:${rarityData.color}; ${item.rarity==='mythic'?'text-shadow: 0 0 10px red;':''} margin-bottom: 20px;">
                            ${item.enchantLevel > 0 ? `+${item.enchantLevel} ` : ''}${item.subtype}
                        </h2>

                        <div class="item-card ${isMythic}" style="width: 250px; border-color: ${rarityData.color}; cursor:default; margin-bottom: 20px;">
                            <div class="item-card-pattern" style="background: ${gradient}; height:120px; font-size:4rem;">
                                ${cat.icon}
                            </div>
                            <div class="item-card-body" style="text-align:left;">
                                <div style="display:flex; justify-content:space-between; border-bottom:1px solid #333; padding-bottom:5px; margin-bottom:5px;">
                                    <span class="text-muted">Desen #${item.patternId}</span>
                                    <span style="font-size:0.8rem; color:${item.qualityScore < 0.1 ? 'var(--rarity-uncommon)' : 'var(--text-secondary)'}">Q: ${item.qualityScore.toFixed(4)}</span>
                                </div>
                                <div style="margin-top: 10px; font-family:var(--font-display); font-size:1.1rem;">
                                    ${item.stats.attack > 0 ? `<div class="flex-between"><span>ATK</span> <span class="text-gold">${this.applyEnchantMult(item.stats.attack, item.enchantLevel)}</span></div>` : ''}
                                    ${item.stats.defense > 0 ? `<div class="flex-between"><span>DEF</span> <span class="text-gold">${this.applyEnchantMult(item.stats.defense, item.enchantLevel)}</span></div>` : ''}
                                    ${item.stats.magic > 0 ? `<div class="flex-between"><span>MAG</span> <span class="text-gold">${this.applyEnchantMult(item.stats.magic, item.enchantLevel)}</span></div>` : ''}
                                </div>
                            </div>
                        </div>

                        <div style="width: 100%; border-top: var(--border-subtle); padding-top: 15px; text-align: left; font-size: 0.9rem; color: var(--text-secondary)">
                            <div class="flex-between" style="margin-bottom:5px;"><span>Nadirlik:</span> <strong style="color:${rarityData.color}">${rarityData.name}</strong></div>
                            <div class="flex-between" style="margin-bottom:5px;"><span>reten:</span> <span>${item.craftedByName}</span></div>
                            <div class="flex-between" style="margin-bottom:5px;"><span>Tarih:</span> <span>${new Date(item.craftedAt).toLocaleDateString()}</span></div>
                        </div>

                        <div style="display:flex; gap: 10px; width: 100%; margin-top: 20px; flex-wrap:wrap;">
                            ${actuallyEquipped ? '' : `<button style="flex:1; min-width:120px;" onclick="MarketplaceSystem.showListingModal('${item.id}')">Pazarda Sat</button>`}
                            ${slot ? `<button style="flex:1; min-width:120px; background:${actuallyEquipped ? 'var(--rarity-mythic)' : 'var(--rarity-rare)'}; color:white;" onclick="InventorySystem.equipCurrentItem(${actuallyEquipped ? `'${slot}'` : `'${item.id}'`}, ${actuallyEquipped})">${actuallyEquipped ? LangSys.get('unequip') : LangSys.get('equip_hero')}</button>` : ''}
                        </div>
                    </div>
                `;

                UI.showModal(modalHtml);
            },
            getEquippedItem(slot) {
                return gameState.player.heroEquipped[slot];
            },
            equipCurrentItem(idOrSlot, isEquipped = false) {
                const item = isEquipped ? this.getEquippedItem(idOrSlot) : this.getItem(idOrSlot);
                if(!item) return UI.showToast("Eya bulunamad.", "error");
                HeroSystem.toggleEquip(item);
            },
            getItem(id) {
                const item = gameState.inventory.find(i => i && i.id === id);
                if(!item) {
                    console.warn(`Item not found: ${id}`);
                    return null;
                }
                return item;
            },

            /**
             * Centralized function to add item to inventory with validation
             * @param {Object} item - The item to add
             * @param {boolean} incrementBadge - Whether to increment newItemCount badge
             * @returns {boolean} - Success status
             */
            addToInventory(item, incrementBadge = true) {
                if(!item || !item.id) {
                    console.error('addToInventory: Invalid item');
                    return false;
                }
                // Check for duplicates
                const exists = gameState.inventory.some(i => i && i.id === item.id);
                if(exists) {
                    console.warn(`addToInventory: Item ${item.id} already exists`);
                    return false;
                }
                // Check inventory limit
                if(gameState.inventory.length >= 100) {
                    UI.showToast("Envanter dolu!", "error");
                    return false;
                }
                gameState.inventory.push(item);
                if(incrementBadge) {
                    gameState.player.newItemCount = (gameState.player.newItemCount || 0) + 1;
                }
                this.render();
                return true;
            },

            /**
             * Centralized function to remove item from inventory with validation
             * @param {string} itemId - The item ID to remove
             * @returns {boolean} - Success status
             */
            removeFromInventory(itemId) {
                if(!itemId) {
                    console.error('removeFromInventory: No item ID provided');
                    return false;
                }
                const idx = gameState.inventory.findIndex(i => i && i.id === itemId);
                if(idx === -1) {
                    console.warn(`removeFromInventory: Item ${itemId} not found`);
                    return false;
                }
                gameState.inventory.splice(idx, 1);
                this.render();
                return true;
            },

            applyEnchantMult(baseStat, level) {
                if(level === 0) return baseStat;
                return Math.floor(baseStat * Math.pow(1.15, level));
            }
        };

        // --- E. ENCHANT SYSTEM --- //
        const ENCHANT_RATES = {
            1: { success: 80, cost: 5,  risk: 'None (Safe)' },
            2: { success: 60, cost: 10, risk: '50% drop to +1' },
            3: { success: 35, cost: 20, risk: 'Auto drop to +2' },
            4: { success: 15, cost: 40, risk: '70% drop +2 / 30% drop +1' },
            5: { success: 5,  cost: 80, risk: '50% drop +3 / <span style="color:red">50% DESTROY</span>' }
        };

        const EnchantSystem = {
            currentItem: null,
            enchantHistory: [],

            setupEnchantView(item) {
                this.currentItem = item;
                const area = document.getElementById('enchant-main-area');
                if(!area) return;

                const cat = ITEM_CATEGORIES[item.category];
                const rarityData = RARITIES[item.rarity];
                const gradient = ItemSystem.getPatternGradient(item.patternId, item.rarity);
                const isMythic = item.rarity === 'mythic' ? 'mythic-glow' : '';

                const currentLvl = item.enchantLevel;
                const nextLvl = currentLvl + 1;

                if(currentLvl >= 5) {
                    area.innerHTML = `
                        <div class="enchant-chamber">
                            <div class="enchant-item-display">
                                <div class="enchant-item-card item-card ${isMythic}" style="border-color: ${rarityData.color}; display:inline-block;">
                                    <div class="item-card-pattern" style="background: ${gradient}; height:120px; font-size:4rem;">${cat.icon}</div>
                                    <div class="item-card-body" style="text-align:center;">
                                        <div class="item-card-title" style="color:${rarityData.color}; font-size:1.2rem;">+${currentLvl} ${item.subtype}</div>
                                    </div>
                                </div>
                            </div>
                            <h3 class="text-gold" style="text-align:center; margin-bottom:10px;"> Maksimum Gce Ulald </h3>
                            <p class="text-secondary" style="text-align:center;">Bu eya daha fazla bytlemez.</p>
                        </div>
                    `;
                    return;
                }

                const enchantData = ENCHANT_RATES[nextLvl];
                const towerLvl = gameState.buildings.enchant_tower.level;
                const finalSuccessRate = enchantData.success + (towerLvl * 1);

                // Requirement restrictions
                let reqMsg = '';
                let btnDisabled = false;
                if(nextLvl === 4 && towerLvl < 10) { reqMsg = '(Byc Seviye 10 Gerekir)'; btnDisabled = true; }
                if(nextLvl === 5 && towerLvl < 20) { reqMsg = '(Byc Seviye 20 Gerekir)'; btnDisabled = true; }
                if(gameState.player.crystal < enchantData.cost) { btnDisabled = true; }

                // Chance color class
                const chanceClass = finalSuccessRate >= 50 ? 'high' : (finalSuccessRate >= 25 ? 'medium' : 'low');

                // Progress track HTML
                const progressHtml = this.renderProgressTrack(currentLvl);

                area.innerHTML = `
                    <div class="enchant-chamber">
                        <!-- Item Display -->
                        <div class="enchant-item-display">
                            <div id="enchant-anim-wrapper" class="enchant-item-card item-card ${isMythic}" style="border-color: ${rarityData.color}; display:inline-block;">
                                <div class="item-card-pattern" style="background: ${gradient}; height:120px; font-size:4rem;">${cat.icon}</div>
                                <div class="item-card-body" style="text-align:center;">
                                    <div class="item-card-title" style="color:${rarityData.color}; font-size:1.2rem;">
                                        ${currentLvl > 0 ? `+${currentLvl} ` : ''}${item.subtype}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Progress Track -->
                        ${progressHtml}

                        <!-- Stats Panel -->
                        <div class="enchant-stats">
                            <div class="enchant-stat-row">
                                <span>Baar ans:</span>
                                <span class="enchant-chance ${chanceClass}">${finalSuccessRate}%</span>
                            </div>
                            <div class="enchant-stat-row">
                                <span>Maliyet:</span>
                                <span class="enchant-cost"> ${enchantData.cost} Kristal</span>
                            </div>
                            <div class="enchant-stat-row">
                                <span>Kule Seviyesi:</span>
                                <span style="color:var(--accent-gold);">Svy ${towerLvl} (+${towerLvl}%)</span>
                            </div>
                        </div>

                        <!-- Risk Warning -->
                        <div class="enchant-risk">
                            <div class="enchant-risk-title"> Baarszlk Riski</div>
                            <div>${enchantData.risk}</div>
                        </div>

                        <!-- Protection Seal -->
                        <div class="enchant-protection">
                            <div class="enchant-protection-title"> Koruma Mhr (Yaknda)</div>
                            <div class="enchant-protection-desc">Baarszlk durumunda eya seviyesi dmez. (Henz aktif deil)</div>
                        </div>

                        <!-- Enchant Button -->
                        <button class="btn-enchant" ${btnDisabled ? 'disabled' : ''} onclick="EnchantSystem.attemptEnchant()">
                             Byle ${reqMsg}
                        </button>

                        <!-- History -->
                        ${this.enchantHistory.length > 0 ? `
                            <div class="enchant-history">
                                <div class="enchant-history-title"> Son Byleme Gemii</div>
                                <div class="enchant-history-list">
                                    ${this.enchantHistory.slice(-5).reverse().map(entry => `
                                        <div class="enchant-history-entry ${entry.success ? 'enchant-success-entry' : 'enchant-fail-entry'}">
                                            <span>${entry.success ? '' : ''} +${entry.from}  +${entry.to}</span>
                                            <span>${new Date(entry.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;

                // Render inventory grid for enchant view
                const gridAfter = document.getElementById('enchant-inventory-grid');
                if(gridAfter) {
                    this.renderEnchantInventoryGrid(item);
                }
            },

            renderEnchantInventoryGrid(currentItem) {
                const grid = document.getElementById('enchant-inventory-grid');
                if(!grid) return;

                if(gameState.inventory.length === 0) {
                    grid.innerHTML = '<span class="text-muted" style="grid-column: 1/-1; text-align:center; padding:20px;">Envanter bo.</span>';
                    return;
                }

                // Sort items: currently selected item first, then by enchant level and quality
                // Filtre: Sadece enchantlanabilir itemler (chest deil ve EQUIP_SLOTS'ta var)
                const enchantableItems = [...gameState.inventory].filter(item => 
                    item.category !== 'chest' && 
                    ITEM_CATEGORIES[item.category] &&
                    EQUIP_SLOTS[item.category]
                ).sort((a, b) => {
                    if(currentItem && a.id === currentItem.id) return -1;
                    if(currentItem && b.id === currentItem.id) return 1;
                    if(b.enchantLevel !== a.enchantLevel) return b.enchantLevel - a.enchantLevel;
                    return b.qualityScore - a.qualityScore;
                });

                if(enchantableItems.length === 0) {
                    grid.innerHTML = '<span class="text-muted" style="grid-column: 1/-1; text-align:center; padding:40px;">Enchantlanabilir eya yok.</span>';
                    return;
                }

                grid.innerHTML = enchantableItems.map(item => {
                    const cat = ITEM_CATEGORIES[item.category];
                    const rarityData = RARITIES[item.rarity];
                    const gradient = ItemSystem.getPatternGradient(item.patternId, item.rarity);
                    const isSelected = currentItem && item.id === currentItem.id;
                    const stars = item.enchantLevel > 0 ? ''.repeat(item.enchantLevel) : '';

                    return `
                        <div class="item-card ${isSelected ? 'selected-item' : ''}" style="border-color: ${rarityData.color}; ${isSelected ? 'box-shadow: 0 0 15px ' + rarityData.color : ''}; max-height: 130px;" onclick="EnchantSystem.selectItemForEnchant('${item.id}')">
                            <div class="item-card-pattern" style="background: ${gradient}; height:60px; font-size:1.8rem;">${cat.icon}</div>
                            <div class="item-card-body" style="padding: 6px;">
                                <div class="item-card-title" style="font-size:0.7rem; color:${rarityData.color};">${stars} ${item.subtype}</div>
                                <div style="font-size:0.6rem; color:var(--text-muted);">+${item.enchantLevel || 0}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            },

            renderEnchantInventoryGridOnOpen() {
                // Tlsm Kulesi ilk aldnda envanteri gster
                // Filtre: Sadece enchantlanabilir itemler
                const enchantableItems = gameState.inventory.filter(item => 
                    item.category !== 'chest' && 
                    ITEM_CATEGORIES[item.category] &&
                    EQUIP_SLOTS[item.category]
                );

                if(enchantableItems.length === 0) {
                    this.renderEnchantInventoryGrid({ id: null });
                    return;
                }
                // Envanterdeki ilk enchantlanabilir item'i se
                const firstItem = enchantableItems[0];
                this.renderEnchantInventoryGrid(firstItem);
            },

            selectItemForEnchant(itemId) {
                const item = InventorySystem.getItem(itemId);
                if(!item) return UI.showToast("Eya bulunamad.", "error");
                // Just re-render the enchant view with the new item
                this.setupEnchantView(item);
            },

            renderProgressTrack(currentLvl) {
                let html = '<div class="enchant-progress-track">';
                for(let i = 0; i <= 5; i++) {
                    const nodeClass = i < currentLvl ? 'completed' : (i === currentLvl ? 'current' : 'locked');
                    const lineClass = i < currentLvl ? 'completed' : '';
                    
                    if(i > 0) {
                        html += `<div class="enchant-level-line ${lineClass}"></div>`;
                    }
                    html += `<div class="enchant-level-node ${nodeClass}">${i === 0 ? '0' : (i === 5 ? 'MAX' : '+'+i)}</div>`;
                }
                html += '</div>';
                return html;
            },

            attemptEnchant() {
                if(!this.currentItem) return;
                const nextLvl = this.currentItem.enchantLevel + 1;
                const enchantData = ENCHANT_RATES[nextLvl];
                
                if(gameState.player.crystal < enchantData.cost) return UI.showToast("Yeterli Kristal yok!", "error");
                
                // Deduct cost
                gameState.player.crystal -= enchantData.cost;
                DailySystem.trackProgress('enchants', 1);
                PlayerSystem.updateUI();

                const towerLvl = gameState.buildings.enchant_tower.level;
                const finalSuccessRate = enchantData.success + (towerLvl * 1);
                
                const diceRoll = Math.floor(Math.random() * 100) + 1; // 1 to 100
                const isSuccess = diceRoll <= finalSuccessRate;

                // Animation lock
                const wrapper = document.getElementById('enchant-anim-wrapper');
                const btn = document.querySelector('#enchant-main-area button');
                if(btn) btn.disabled = true;

                // Add pre-animation suspense (vibrate)
                wrapper.style.animation = 'revealShake 0.5s ease infinite';
                
                setTimeout(() => {
                    wrapper.style.animation = 'none';
                    if(isSuccess) {
                        wrapper.classList.add('anim-enchant-success');
                        this.handleSuccess(nextLvl);
                    } else {
                        this.handleFailure(nextLvl);
                    }
                }, 1000); // 1s suspense
            },

            handleSuccess(newLevel) {
                const oldLevel = this.currentItem.enchantLevel;
                UI.showToast(`Byleme BAARILI! Eya +${newLevel} oldu`, "success");
                this.currentItem.enchantLevel = newLevel;
                gameState.player.stats.enchantSuccesses = (gameState.player.stats.enchantSuccesses || 0) + 1;
                gameState.player.stats.totalEnchants = (gameState.player.stats.totalEnchants || 0) + 1;

                // XP Gain: Enchant_level  20 XP
                LevelSystem.addXp(newLevel * 20);

                // Add to history
                this.enchantHistory.push({
                    success: true,
                    from: oldLevel,
                    to: newLevel,
                    time: Date.now()
                });

                setTimeout(() => {
                    PlayerSystem.save();
                    InventorySystem.render();
                    this.setupEnchantView(this.currentItem);
                }, 1500);
            },

            handleFailure(attemptedLevel) {
                if(!this.currentItem) return; // Safety check: item may have been destroyed
                
                const wrapper = document.getElementById('enchant-anim-wrapper');
                const r = Math.random();
                let destroyed = false;
                let newLevel = this.currentItem.enchantLevel;
                const oldLevel = this.currentItem.enchantLevel;
                const oldItem = this.currentItem; // Referans sakla

                // Increment total enchants counter for failure too
                gameState.player.stats.totalEnchants = (gameState.player.stats.totalEnchants || 0) + 1;

                if(attemptedLevel === 2) {
                    if(r < 0.5) newLevel = 1;
                } else if (attemptedLevel === 3) {
                    newLevel = 2; // Auto drop
                } else if (attemptedLevel === 4) {
                    if(r < 0.7) newLevel = 2; else newLevel = 1;
                } else if (attemptedLevel === 5) {
                    if(r < 0.5) {
                        newLevel = 3;
                    } else {
                        destroyed = true;
                    }
                }

                if(destroyed) {
                    wrapper.classList.add('anim-enchant-destroy');
                    UI.showToast("Felaket! Eya parampara oldu.", "error");

                    // Add to history
                    this.enchantHistory.push({
                        success: false,
                        from: oldLevel,
                        to: -1, // -1 means destroyed
                        time: Date.now()
                    });

                    // Remove from inventory
                    const destroyedItemId = oldItem.id; // Save ID before removal
                    gameState.inventory = gameState.inventory.filter(i => i.id !== destroyedItemId);
                    this.currentItem = null;

                    // FIX: Don't reference this.currentItem in timeout after it's set to null
                    setTimeout(() => {
                        PlayerSystem.save();
                        InventorySystem.render();
                        BuildingSystem.selectBuilding('enchant_tower'); // reset view
                    }, 1500);

                } else {
                    wrapper.classList.add('anim-enchant-fail');
                    const dropMsg = newLevel < oldLevel ? ` Gc +${newLevel} seviyesine dt.` : '';
                    UI.showToast(`Byleme Baarsz!${dropMsg}`, "error");

                    // Add to history
                    this.enchantHistory.push({
                        success: false,
                        from: oldLevel,
                        to: newLevel,
                        time: Date.now()
                    });

                    if(this.currentItem) {
                        this.currentItem.enchantLevel = newLevel;
                    }

                    // FIX: Save currentItem reference before timeout
                    const itemToSetup = this.currentItem;
                    setTimeout(() => {
                        PlayerSystem.save();
                        InventorySystem.render();
                        if (itemToSetup) {
                            this.setupEnchantView(itemToSetup);
                        }
                    }, 1500);
                }
            }
        };

        // --- F. SOCIAL SYSTEMS (Marketplace, Chat, Trade) --- //

        // ========================================
        // RATE LIMITER (Spam Prevention)
        // ========================================
        const RateLimiter = {
            // Track actions per user
            _tracks: {},

            // Default limits
            _defaultLimits: {
                chat: { max: 5, window: 10000 },        // 5 messages per 10 seconds
                trade: { max: 10, window: 60000 },       // 10 trades per minute
                attack: { max: 100, window: 60000 },     // 100 attacks per minute
                craft: { max: 20, window: 60000 },       // 20 crafts per minute
                api: { max: 50, window: 60000 }          // 50 API calls per minute
            },

            // Check if action is allowed
            check(action, userId, limitOverride = null) {
                const limits = limitOverride || this._defaultLimits[action] || { max: 10, window: 60000 };
                const key = `${userId}:${action}`;
                const now = Date.now();

                // Initialize track if not exists
                if (!this._tracks[key]) {
                    this._tracks[key] = { timestamps: [], blocked: false, blockUntil: 0 };
                }

                const track = this._tracks[key];

                // Check if user is temporarily blocked
                if (track.blocked && now < track.blockUntil) {
                    const remaining = Math.ceil((track.blockUntil - now) / 1000);
                    Logger.warn('RateLimiter', `User ${userId} blocked for ${action}`, { remaining });
                    return {
                        allowed: false,
                        reason: 'blocked',
                        retryAfter: remaining
                    };
                }

                // Clear old timestamps
                track.timestamps = track.timestamps.filter(ts => now - ts < limits.window);

                // Check if limit exceeded
                if (track.timestamps.length >= limits.max) {
                    // Block user for 2x the window if they exceed limit by 2x
                    if (track.timestamps.length >= limits.max * 2) {
                        track.blocked = true;
                        track.blockUntil = now + (limits.window * 2);
                        Logger.warn('RateLimiter', `User ${userId} temporarily blocked`, { action, blockUntil: track.blockUntil });
                        
                        return {
                            allowed: false,
                            reason: 'blocked',
                            retryAfter: Math.ceil((track.blockUntil - now) / 1000)
                        };
                    }

                    const oldestTimestamp = track.timestamps[0];
                    const retryAfter = Math.ceil((oldestTimestamp + limits.window - now) / 1000);

                    Logger.warn('RateLimiter', `Rate limit exceeded`, { userId, action, retryAfter });

                    return {
                        allowed: false,
                        reason: 'limit_exceeded',
                        retryAfter
                    };
                }

                // Record this action
                track.timestamps.push(now);

                // Reset block if expired
                if (track.blocked && now >= track.blockUntil) {
                    track.blocked = false;
                    track.blockUntil = 0;
                    Logger.info('RateLimiter', `User ${userId} block expired`, { action });
                }

                return {
                    allowed: true,
                    remaining: limits.max - track.timestamps.length,
                    resetIn: Math.ceil(limits.window / 1000)
                };
            },

            // Get current rate limit status
            getStatus(action, userId) {
                const key = `${userId}:${action}`;
                const track = this._tracks[key];
                const limits = this._defaultLimits[action] || { max: 10, window: 60000 };

                if (!track) {
                    return {
                        allowed: true,
                        remaining: limits.max,
                        blocked: false
                    };
                }

                const now = Date.now();
                const recentCount = track.timestamps.filter(ts => now - ts < limits.window).length;

                return {
                    allowed: !track.blocked && recentCount < limits.max,
                    remaining: Math.max(0, limits.max - recentCount),
                    blocked: track.blocked && now < track.blockUntil,
                    blockUntil: track.blocked ? track.blockUntil : null,
                    resetIn: Math.ceil(limits.window / 1000)
                };
            },

            // Clear rate limit data for user
            clear(userId) {
                Object.keys(this._tracks).forEach(key => {
                    if (key.startsWith(`${userId}:`)) {
                        delete this._tracks[key];
                    }
                });
            },

            // Clear all (for cleanup)
            clearAll() {
                this._tracks = {};
            }
        };

        const ChatSystem = {
            messages: [],
            isPanelOpen: false,
            currentChannel: 'Global',
            unsub: null,
            MAX_MESSAGES: 100,
            MESSAGE_EXPIRY_MS: 3 * 60 * 1000, // 3 minutes
            cleanupInterval: null,
            lastReadMessageId: null,
            unreadCount: 0,
            lastRenderedCount: 0,
            lastMessageTimestamp: 0, // FIX #22: Track last message for incremental updates

            // Debounced send message (for input typing)
            debouncedSendMessage: Utils.debounce(function() {
                this.sendMessage();
            }, 300),

            init() {
                this.messages = [];
                this.lastReadMessageId = null;
                this.unreadCount = 0;
                this.lastMessageTimestamp = 0;
                this.render();
                UI.updateNavBadges();

                if(window.FB) {
                    // FIX #22: Use subcollection architecture for better performance
                    // Instead of listening to entire document, query last N messages
                    this.loadRecentMessages();
                    
                    // Set up real-time listener for new messages only
                    this.setupRealTimeListener();
                }

                this.cleanupInterval = setInterval(() => {
                    this.cleanupExpiredMessages();
                }, 30000);

                window.addEventListener('beforeunload', () => {
                    this.destroy();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if(e.key === 'c' || e.key === 'C') {
                        if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                            this.togglePanel();
                        }
                    }
                    if(e.key === 'Escape' && this.isPanelOpen) {
                        this.togglePanel();
                    }
                });
            },

            // FIX #22: Load only recent messages using query with limit
            async loadRecentMessages() {
                try {
                    const chatRef = window.FB.collection(window.FB.db, 'shared_data', 'global', 'chat-messages');
                    // Query: Order by timestamp descending, limit to MAX_MESSAGES
                    const q = window.FB.query(
                        chatRef,
                        window.FB.orderBy('timestamp', 'desc'),
                        window.FB.limit(this.MAX_MESSAGES)
                    );
                    
                    const snapshot = await window.FB.getDocs(q);
                    const now = Date.now();
                    
                    this.messages = [];
                    snapshot.forEach(doc => {
                        const msg = doc.data();
                        // Filter expired messages
                        if((now - msg.timestamp) < this.MESSAGE_EXPIRY_MS) {
                            this.messages.unshift(msg); // Add to beginning (oldest first)
                        }
                    });
                    
                    this.updateUnreadCount();
                    this.render();
                    UI.updateNavBadges();
                } catch(e) {
                    console.error('Failed to load chat messages:', e);
                }
            },

            // FIX #22: Real-time listener for new messages only
            setupRealTimeListener() {
                const chatRef = window.FB.collection(window.FB.db, 'shared_data', 'global', 'chat-messages');

                // Listen for new messages added after our last loaded message
                const q = window.FB.query(
                    chatRef,
                    window.FB.where('timestamp', '>', this.lastMessageTimestamp),
                    window.FB.orderBy('timestamp', 'asc')
                );
                
                this.unsub = window.FB.onSnapshot(q, (snapshot) => {
                    const now = Date.now();
                    let hasNewMessages = false;
                    
                    snapshot.forEach(doc => {
                        const msg = doc.data();
                        // Only add if not expired and not already in list
                        if((now - msg.timestamp) < this.MESSAGE_EXPIRY_MS && 
                           !this.messages.find(m => m.id === msg.id)) {
                            this.messages.push(msg);
                            hasNewMessages = true;
                            this.lastMessageTimestamp = Math.max(this.lastMessageTimestamp, msg.timestamp);
                        }
                    });
                    
                    // Keep only last MAX_MESSAGES
                    if(this.messages.length > this.MAX_MESSAGES) {
                        this.messages = this.messages.slice(this.messages.length - this.MAX_MESSAGES);
                    }
                    
                    if(hasNewMessages) {
                        this.updateUnreadCount();
                        this.render();
                        UI.updateNavBadges();
                    }
                });
            },

            updateUnreadCount() {
                if (!this.lastReadMessageId) {
                    this.unreadCount = 0;
                } else {
                    const lastReadIndex = this.messages.findIndex(msg => msg.id === this.lastReadMessageId);
                    if (lastReadIndex === -1) {
                        this.unreadCount = 0;
                    } else {
                        this.unreadCount = this.messages.length - lastReadIndex - 1;
                    }
                }
                this.updateFabBadge();
            },

            markAsRead() {
                if (this.messages.length > 0) {
                    this.lastReadMessageId = this.messages[this.messages.length - 1].id;
                    this.unreadCount = 0;
                    this.updateFabBadge();
                }
            },

            destroy() {
                // Cleanup intervals and listeners
                if (this.cleanupInterval) {
                    clearInterval(this.cleanupInterval);
                    this.cleanupInterval = null;
                }
                if (this.unsub) {
                    this.unsub();
                    this.unsub = null;
                }
            },

            cleanupExpiredMessages() {
                // FIX #22: Clean up expired messages from local array
                const now = Date.now();
                const beforeCount = this.messages.length;
                this.messages = this.messages.filter(msg =>
                    (now - msg.timestamp) < this.MESSAGE_EXPIRY_MS
                );

                // Delete expired messages from Firestore subcollection
                if (this.messages.length !== beforeCount) {
                    // Batch delete expired messages
                    const expiredIds = [];
                    for(let i = 0; i < beforeCount; i++) {
                        const msg = this.messages[i];
                        if(!msg || (now - msg.timestamp) >= this.MESSAGE_EXPIRY_MS) {
                            expiredIds.push(msg.id);
                        }
                    }

                    // Delete in batches of 500 (Firestore batch limit)
                    const batchSize = 500;
                    for(let i = 0; i < expiredIds.length; i += batchSize) {
                        const batch = expiredIds.slice(i, i + batchSize);
                        batch.forEach(id => {
                            const msgRef = window.FB.doc(window.FB.db, `shared_data/global/chat-messages/${id}`);
                            window.FB.deleteDoc(msgRef);
                        });
                    }

                    this.render();
                    UI.updateNavBadges();
                }
            },

            clearOnLogout() {
                // Called when player logs out - no need to persist
            },

            togglePanel() {
                const panel = document.getElementById('chat-side-panel');
                const overlay = document.getElementById('chat-panel-overlay');
                
                this.isPanelOpen = !this.isPanelOpen;

                if(this.isPanelOpen) {
                    panel.classList.add('active');
                    overlay.classList.add('active');
                    // Mark messages as read when panel is opened
                    this.markAsRead();
                    UI.updateNavBadges();
                    this.updateFabBadge();
                    // Scroll to bottom
                    const container = document.getElementById('chat-panel-messages');
                    if(container) {
                        setTimeout(() => {
                            container.scrollTop = container.scrollHeight;
                        }, 100);
                    }
                } else {
                    panel.classList.remove('active');
                    overlay.classList.remove('active');
                }
            },

            updateFabBadge() {
                const badge = document.getElementById('chat-fab-badge');
                if(badge) {
                    if(this.unreadCount > 0) {
                        badge.style.display = 'block';
                        badge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount;
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },

            setChannel(channel, btn) {
                this.currentChannel = channel;
                // Update button styles
                document.querySelectorAll('.chat-channel-btn').forEach(b => b.classList.remove('active'));
                if(btn) btn.classList.add('active');
            },

            async sendMessage() {
                const input = document.getElementById('chat-panel-input-text');
                let text = input.value.trim();
                const channel = this.currentChannel;
                if(!text) return;

                // Rate limit check
                if (gameState.player && gameState.player.id) {
                    const rateCheck = RateLimiter.check('chat', gameState.player.id);
                    if (!rateCheck.allowed) {
                        if (rateCheck.reason === 'blocked') {
                            return UI.showToast(`ok fazla mesaj! ${rateCheck.retryAfter} saniye bekleyin.`, "error");
                        } else {
                            return UI.showToast(`Mesaj limiti! ${rateCheck.retryAfter} saniye sonra tekrar deneyin.`, "error");
                        }
                    }
                }

                if(text.length > 200) {
                    return UI.showToast("Mesaj ok uzun!", "error");
                }

                // Sanitize message (Security)
                text = Security.sanitize(text);

                // Check for [item] tag
                if(text.includes('[item]')) {
                    if(gameState.inventory.length > 0) {
                        const topItem = [...gameState.inventory].sort((a,b)=>b.qualityScore - a.qualityScore)[0];
                        text = text.replace('[item]', `[${topItem.rarity.toUpperCase()} ${topItem.subtype} +${topItem.enchantLevel}]`);
                    } else {
                        text = text.replace('[item]', '[Empty Hands]');
                    }
                }

                const newMsg = {
                    id: 'msg_' + Date.now() + Math.random().toString(36).substr(2, 5),
                    playerId: gameState.player.id,
                    playerName: Security.sanitize(gameState.player.name),
                    channel: channel,
                    message: text,
                    timestamp: Date.now()
                };

                input.value = '';

                // FIX #22: Use subcollection architecture - each message is a separate document
                // This eliminates the need to download entire chat history on every update
                try {
                    // Save message as individual document in subcollection
                    const msgRef = window.FB.doc(window.FB.db, `shared_data/global/chat-messages/${newMsg.id}`);
                    await window.FB.setDoc(msgRef, newMsg);

                    this.markAsRead();
                    this.render();
                } catch(e) {
                    console.error('Chat sendMessage error', e);
                    UI.showToast("Mesaj gnderilemedi. Ltfen tekrar deneyin.", "error");
                }
            },

            render() {
                const container = document.getElementById('chat-panel-messages');
                if(!container) return;

                if(this.messages.length === 0) {
                    container.innerHTML = `
                        <div class="chat-empty-state">
                            <div class="chat-empty-state-icon"></div>
                            <p>Henz hi mesaj yok.</p>
                            <p style="font-size:0.85rem; margin-top:8px;">Merhaba diyen ilk sen ol!</p>
                        </div>
                    `;
                    this.lastRenderedCount = 0;
                    return;
                }

                // Get existing message elements
                const existingMsgs = container.querySelectorAll('.chat-message');
                const now = Date.now();
                
                // OPTIMIZATION: Limit initial render to last 20 messages for performance
                const INITIAL_RENDER_COUNT = 20;
                const messagesToRender = this.messages.slice(-INITIAL_RENDER_COUNT);

                // If no messages exist, render limited set
                if(existingMsgs.length === 0) {
                    messagesToRender.forEach(msg => {
                        const el = this.createMessageElement(msg, now);
                        container.appendChild(el);
                    });
                    this.lastRenderedCount = messagesToRender.length;
                    
                    // Add "load older" button if there are more messages
                    if (this.messages.length > INITIAL_RENDER_COUNT) {
                        const loadOlderBtn = document.createElement('div');
                        loadOlderBtn.className = 'text-center';
                        loadOlderBtn.style.cssText = 'text-align:center; padding:10px; color:var(--text-secondary); font-size:0.85rem; cursor:pointer;';
                        loadOlderBtn.textContent = ` ${this.messages.length - INITIAL_RENDER_COUNT} eski mesaj ykle`;
                        loadOlderBtn.onclick = () => {
                            // Load all messages on click
                            container.innerHTML = '';
                            this.messages.forEach(msg => {
                                const el = this.createMessageElement(msg, now);
                                container.appendChild(el);
                            });
                            this.lastRenderedCount = this.messages.length;
                        };
                        container.insertBefore(loadOlderBtn, container.firstChild);
                    }
                } else {
                    // Only add new messages that don't exist yet
                    const existingIds = Array.from(existingMsgs).map(el => el.dataset.msgId);

                    this.messages.forEach(msg => {
                        if(!existingIds.includes(msg.id)) {
                            const el = this.createMessageElement(msg, now);
                            container.appendChild(el);
                        }
                    });

                    // Remove any messages that no longer exist (in case of cleanup)
                    Array.from(existingMsgs).forEach(el => {
                        if(!this.messages.find(msg => msg.id === el.dataset.msgId)) {
                            el.remove();
                        }
                    });
                    
                    this.lastRenderedCount = container.querySelectorAll('.chat-message').length;
                }

                // Auto scroll to bottom if panel is open
                if(this.isPanelOpen) {
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 50);
                }
            },

            createMessageElement(msg, now) {
                const el = document.createElement('div');
                const time = new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const isRecent = (now - msg.timestamp) < 60000;
                const msgClass = msg.channel === 'Trade' ? 'trade' : (isRecent ? 'system' : '');

                el.className = `chat-message ${msgClass}`;
                el.dataset.msgId = msg.id;

                // SECURITY FIX: Sanitize ALL data from Firebase (not just outgoing messages)
                // This prevents XSS attacks via direct Firestore manipulation
                const safePlayerName = Security.sanitize(msg.playerName);
                const safeMessage = Security.sanitize(msg.message);
                const safeChannel = Security.sanitize(msg.channel);

                // FIX #24: Use textContent and addEventListener instead of innerHTML with onclick
                // to prevent XSS injection via playerId parameter
                const headerDiv = document.createElement('div');
                headerDiv.className = 'chat-msg-header';

                const authorSpan = document.createElement('span');
                authorSpan.className = 'chat-msg-author';
                authorSpan.textContent = safePlayerName;
                authorSpan.style.cursor = 'pointer';
                authorSpan.dataset.playerId = msg.playerId; // Store raw ID for click handler
                authorSpan.addEventListener('click', function() {
                    const playerId = this.dataset.playerId;
                    if(playerId) ProfileSystem.showProfile(playerId);
                });

                const timeSpan = document.createElement('span');
                timeSpan.className = 'chat-msg-time';
                timeSpan.textContent = time;

                headerDiv.appendChild(authorSpan);
                headerDiv.appendChild(timeSpan);

                const textDiv = document.createElement('div');
                textDiv.className = 'chat-msg-text';

                const channelSpan = document.createElement('span');
                channelSpan.style.color = 'var(--accent-gold)';
                channelSpan.style.fontSize = '0.8rem';
                channelSpan.textContent = `[${safeChannel}]`;

                const messageSpan = document.createElement('span');
                messageSpan.innerHTML = safeMessage; // Safe because it's already sanitized

                textDiv.appendChild(channelSpan);
                textDiv.appendChild(messageSpan);

                el.appendChild(headerDiv);
                el.appendChild(textDiv);

                return el;
            }
        };

        const MarketplaceSystem = {
            async showListingModal(itemId) {
                const item = InventorySystem.getItem(itemId);
                if(!item) return;

                // Check if item is equipped on hero
                const eq = gameState.player.heroEquipped || {};
                const slot = EQUIP_SLOTS[item.category];
                if(slot && eq[slot] && eq[slot].id === item.id) {
                    return UI.showToast("Bu eya kahraman zerinde takl! nce karmalsnz.", "error");
                }

                // Check allowed listings limit
                const activeListingsStr = await StorageAPI.get('market-listings', true) || [];
                const myListings = activeListingsStr.filter(l => l.sellerId === gameState.player.id && l.status === 'active');

                const lLevel = gameState.buildings.trade_port.level;
                const maxListings = 3 + (lLevel * 2);

                if(myListings.length >= maxListings) {
                    return UI.showToast(`Pazar Dolu! Ticaret Liman Seviye ${lLevel} iken sadece ${maxListings} aktif ilannz olabilir.`, "error");
                }

                const feeRate = lLevel >= 20 ? 0.05 : lLevel >= 10 ? 0.07 : 0.10;

                // Check if item is a chest
                const isChest = item.category === 'chest';
                const chestTier = isChest ? CHEST_TIERS[item.chestTier] : null;

                UI.showModal(`
                    <h3 class="text-gold" style="margin-bottom: 20px;">${isChest ? 'Sandk Sat' : 'Eya Sat'}</h3>
                    ${isChest ? `
                        <div style="text-align:center; margin-bottom: 15px;">
                            <div style="font-size:4rem; filter: drop-shadow(0 0 20px ${chestTier.color});">${chestTier.icon}</div>
                            <strong style="color: ${chestTier.color}; font-size:1.2rem;">${chestTier.name}</strong>
                        </div>
                    ` : `
                        <p class="text-secondary" style="margin-bottom: 10px;">Item: <strong>${item.subtype} (+${item.enchantLevel})</strong></p>
                    `}
                    <p class="text-secondary" style="margin-bottom: 15px;">${isChest ? 'Almam' : 'stediiniz'} ${isChest ? 'sandk' : 'altn'} miktarn belirleyin.</p>

                    <input type="number" id="market-price-input" min="1" max="1000000" placeholder="Altn Cinsinden Fiyat" style="width:100%; font-size:1.2rem; padding:10px; margin-bottom: 10px;">

                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 20px;">
                        Pazar creti: <strong>${(feeRate*100).toFixed(0)}%</strong><br>
                        Ayrca baarl bir satta sat deerinin <strong>%2</strong>'sini Elmas () olarak kazanrsnz!
                    </div>

                    <div style="display:flex; gap:10px;">
                        <button style="flex:1" onclick="UI.hideModal()">ptal</button>
                        <button style="flex:1; background:var(--accent-gold); color:black;" id="btn-confirm-listing" onclick="MarketplaceSystem.confirmListing('${itemId}', ${feeRate})">Pazara Ekle</button>
                    </div>
                `);

                // Auto focus
                setTimeout(() => document.getElementById('market-price-input').focus(), 100);
            },

            async confirmListing(itemId, feeRate) {
                const priceInput = document.getElementById('market-price-input').value;
                const price = Math.floor(Number(priceInput));
                
                if(isNaN(price) || price <= 0) return UI.showToast("Geersiz fiyat.", "error");

                const btn = document.getElementById('btn-confirm-listing');
                btn.disabled = true;
                btn.innerText = "leniyor...";

                try {
                    const item = InventorySystem.getItem(itemId);
                    // Remove from local inventory
                    gameState.inventory = gameState.inventory.filter(i => i.id !== itemId);
                    PlayerSystem.save();
                    InventorySystem.render();

                    const newListing = {
                        listingId: 'list_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                        sellerId: gameState.player.id,
                        sellerName: gameState.player.name,
                        item: item,
                        price: price,
                        feeRate: feeRate, // store fee rate at time of listing
                        listedAt: Date.now(),
                        status: 'active'
                    };

                    let currentListings = await StorageAPI.get('market-listings', true) || [];
                    currentListings.push(newListing);
                    await StorageAPI.set('market-listings', currentListings, true);

                    UI.hideModal();
                    UI.showToast(item.category === 'chest' ? "Sandk Byk Pazar'a eklendi!" : "Eya Byk Pazar'a eklendi!", "success");

                    // Daily quest tracking
                    gameState.player.stats.totalItemsSold = (gameState.player.stats.totalItemsSold || 0) + 1;
                    AchievementSystem.check('totalItemsSold', gameState.player.stats.totalItemsSold);
                    DailySystem.trackProgress('sells', 1);

                    // If marketplace is open, refresh
                    if (document.getElementById('view-title').innerText === 'Grand Marketplace') {
                        this.openMarket();
                    }
                } catch (e) {
                    console.error(e);
                    UI.showToast("Failed to list item!", "error");
                }
            },

            async openMarket() {
                // Update navigation active state
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                const navMarket = document.getElementById('nav-market');
                if(navMarket) navMarket.classList.add('active');

                // Show town view (market is displayed within town view)
                document.querySelectorAll('.view-section').forEach(v => v.classList.add('hidden'));
                const townView = document.getElementById('view-town');
                if(townView) townView.classList.remove('hidden');

                document.getElementById('view-title').innerText = "Grand Marketplace";
                const container = document.getElementById('view-container');
                container.innerHTML = `<div style="text-align:center; margin-top:50px;"><h3 class="text-gold">Kresel Pazarlar Ykleniyor...</h3></div>`;

                try {
                    const listingsRaw = await StorageAPI.get('market-listings', true) || [];
                    
                    // CLEANUP: Remove sold/cancelled listings older than 24 hours to prevent 1MB doc limit
                    const now = Date.now();
                    const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;
                    const needsCleanup = listingsRaw.some(l => 
                        (l.status === 'sold' || l.status === 'cancelled') && 
                        (now - (l.soldAt || l.cancelledAt || l.listedAt)) > TWENTY_FOUR_HOURS
                    );
                    
                    if (needsCleanup) {
                        const cleanedListings = listingsRaw.filter(l => 
                            l.status === 'active' || 
                            (now - (l.soldAt || l.cancelledAt || l.listedAt)) <= TWENTY_FOUR_HOURS
                        );
                        // Save cleaned list in background (don't block UI)
                        StorageAPI.set('market-listings', cleanedListings, true).catch(console.error);
                    }
                    
                    const activeListings = listingsRaw.filter(l => l.status === 'active').sort((a,b) => b.listedAt - a.listedAt); // Newest first

                    let html = `
                        <div style="margin-top: 20px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom: 20px; align-items:center;">
                                <span class="text-secondary">${activeListings.length} Aktif Kresel lanlar</span>
                                <button onclick="MarketplaceSystem.openMarket()"> Yenile</button>
                            </div>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                    `;

                    if(activeListings.length === 0) {
                        html += `<div style="grid-column: 1/-1; text-align:center; padding: 40px;" class="card text-muted">Pazar u anda bo. lk ilan veren siz olun!</div>`;
                    }

                    activeListings.forEach(list => {
                        const i = list.item;
                        const isChest = i.category === 'chest';
                        const chestTier = isChest ? CHEST_TIERS[i.chestTier] : null;
                        const rarityData = isChest ? { color: chestTier.color } : RARITIES[i.rarity];
                        const isOwn = list.sellerId === gameState.player.id;

                        html += `
                            <div class="card item-card" style="border-color:${rarityData.color}; cursor:default;">
                                <div class="item-card-pattern" style="background: ${isChest ? 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(30,30,40,0.9))' : ItemSystem.getPatternGradient(i.patternId, i.rarity)}; height:80px; font-size:2.5rem; display:flex; align-items:center; justify-content:center;">
                                    ${isChest ? `<span style="filter: drop-shadow(0 0 15px ${chestTier.color});">${chestTier.icon}</span>` : (ITEM_CATEGORIES[i.category]?.icon || '')}
                                </div>
                                <div class="item-card-body" style="text-align:center;">
                                    <div class="item-card-title" style="color:${rarityData.color};">${isChest ? chestTier.name : (i.enchantLevel>0?`+${i.enchantLevel} `:''+i.subtype)}</div>
                                    <div style="font-size:0.75rem; color:var(--text-secondary); margin-bottom:10px;">By: <span class="msg-author" onclick="ProfileSystem.showProfile('${list.sellerId}')">${list.sellerName}</span></div>

                                    <div style="background:var(--bg-primary); padding: 5px; border-radius: 4px; margin-bottom: 10px;">
                                        <b class="text-gold"> ${UI.formatNumber(list.price)}</b>
                                    </div>

                                    ${isOwn ?
                                        `<button style="width:100%; padding: 5px; font-size: 0.8rem; border-color:var(--rarity-mythic); color:var(--rarity-mythic)" onclick="MarketplaceSystem.cancelListing('${list.listingId}')">ptal</button>` :
                                        `<button style="width:100%; padding: 5px; font-size: 0.8rem; background:var(--accent-gold); color:black;"
                                            ${gameState.player.gold < list.price ? 'disabled opacity:0.5;' : ''}
                                            onclick="MarketplaceSystem.buyListing('${list.listingId}', ${list.price})">Satn Al</button>`
                                    }
                                </div>
                            </div>
                        `;
                    });

                    html += `</div></div>`;
                    container.innerHTML = html;

                } catch (e) {
                    console.error(e);
                    container.innerHTML = `<p class="text-mythic">Failed to load marketplace data. Storage may be unavailable.</p>`;
                }
            },

            async buyListing(listingId, expectedPrice) {
                if(gameState.player.gold < expectedPrice) return UI.showToast("Yeterli Altn yok!", "error");

                // Critical Region - Firebase Transaction for Race Conditions
                try {
                    const marketRef = window.FB.doc(window.FB.db, 'shared_data/market-listings');
                    const inboxRef = window.FB.doc(window.FB.db, 'shared_data/player-inbox');

                    const boughtListingData = await window.FB.runTransaction(window.FB.db, async (transaction) => {
                        const marketDoc = await transaction.get(marketRef);
                        const inboxDoc = await transaction.get(inboxRef);

                        let allListings = marketDoc.exists() ? marketDoc.data().value || [] : [];
                        let inbox = inboxDoc.exists() ? inboxDoc.data().value || [] : [];

                        const listIndex = allListings.findIndex(l => l.listingId === listingId);
                        if(listIndex === -1 || allListings[listIndex].status !== 'active') {
                            throw new Error("ALREADY_SOLD");
                        }

                        const activeListing = allListings[listIndex];
                        if(activeListing.price !== expectedPrice) {
                            throw new Error("PRICE_CHANGED");
                        }

                        // Update shared state
                        allListings[listIndex].status = 'sold';
                        allListings[listIndex].buyerId = gameState.player.id;
                        allListings[listIndex].soldAt = Date.now();
                        
                        // Distribute cash to seller
                        const feeAmount = Math.floor(expectedPrice * activeListing.feeRate);
                        const netGold = expectedPrice - feeAmount;
                        const bonusGems = Math.floor(expectedPrice * 0.02); // 2% gems
                        
                        inbox.push({
                            id: 'inb_' + Date.now() + Math.random().toString(36).substr(2, 5),
                            playerId: activeListing.sellerId,
                            gold: netGold,
                            gems: bonusGems,
                            message: `Item Sold: ${activeListing.item.subtype} for ${UI.formatNumber(expectedPrice)} Gold (Fee: ${UI.formatNumber(feeAmount)})`
                        });

                        transaction.set(marketRef, { value: allListings }, { merge: true });
                        transaction.set(inboxRef, { value: inbox }, { merge: true });

                        return activeListing; // Pass item back to local runtime
                    });

                    // Transaction successful! Process local state changes
                    if(!SecuritySys.spendGold(expectedPrice)) {
                        UI.showToast("Yetersiz altn!", "error");
                        return;
                    }

                    const boughtItem = boughtListingData.item;
                    boughtItem.tradeHistory.push({ from: boughtListingData.sellerId, to: gameState.player.id, price: expectedPrice, date: Date.now() });
                    // FIX #10: Use centralized addToInventory for limit check consistency
                    InventorySystem.addToInventory(boughtItem, true);

                    PlayerSystem.save();

                    UI.showToast("Purchase successful!", "success");
                    this.openMarket(); // refresh

                } catch (e) {
                    console.error("Purchase error", e);
                    UI.showToast("Transaction failed.", "error");
                }
            },

            async cancelListing(listingId) {
                try {
                    // SECURITY FIX: Use transaction to prevent race condition and item duplication
                    const marketRef = window.FB.doc(window.FB.db, 'shared_data/market-listings');
                    
                    const result = await window.FB.runTransaction(window.FB.db, async (transaction) => {
                        const marketDoc = await transaction.get(marketRef);
                        
                        let allListings = marketDoc.exists() ? marketDoc.data().value || [] : [];
                        const listIndex = allListings.findIndex(l => l.listingId === listingId);

                        // Validate listing exists and is active
                        if(listIndex === -1 || allListings[listIndex].status !== 'active') {
                            throw new Error("LISTING_NOT_FOUND");
                        }

                        // Validate ownership
                        if(allListings[listIndex].sellerId !== gameState.player.id) {
                            throw new Error("NOT_YOUR_LISTING");
                        }

                        const listItem = allListings[listIndex].item;
                        
                        // Mark as cancelled in Firestore (atomically)
                        allListings[listIndex].status = 'cancelled';
                        allListings[listIndex].cancelledAt = Date.now();
                        
                        transaction.set(marketRef, { value: allListings }, { merge: true });
                        
                        return { item: listItem, success: true };
                    });

                    // After successful transaction, add item to local inventory
                    if (result.item) {
                        const listItem = result.item;
                        // Server-side duplicate check (in case of concurrent cancellations)
                        const alreadyInInventory = gameState.inventory.some(i => i.id === listItem.id);
                        if(!alreadyInInventory) {
                            gameState.inventory.push(listItem);
                            gameState.player.newItemCount = (gameState.player.newItemCount || 0) + 1;
                        } else {
                            // Item already in inventory (concurrent cancel detected)
                            console.warn('Item already in inventory - concurrent cancel detected');
                        }
                        PlayerSystem.save();
                        InventorySystem.render();
                    }

                    UI.showToast("Listing cancelled. Item returned.", "success");
                    this.openMyListings(); // Refresh
                } catch(e) {
                    console.error(e);
                    if (e.message === "LISTING_NOT_FOUND") {
                        UI.showToast("Listing not found or already cancelled.", "error");
                    } else if (e.message === "NOT_YOUR_LISTING") {
                        UI.showToast("This listing does not belong to you.", "error");
                    } else {
                        UI.showToast("Failed to cancel listing.", "error");
                    }
                }
            },

            async openMyListings() {
                document.getElementById('view-title').innerText = "My Active Listings";
                const container = document.getElementById('view-container');
                container.innerHTML = `<div style="text-align:center; margin-top:50px;"><h3 class="text-gold">Loading...</h3></div>`;

                try {
                    const listingsRaw = await StorageAPI.get('market-listings', true) || [];
                    const myListings = listingsRaw.filter(l => l.sellerId === gameState.player.id && l.status === 'active').sort((a,b) => b.listedAt - a.listedAt);

                    let html = `
                        <div style="margin-top: 20px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom: 20px; align-items:center;">
                                <span class="text-secondary">${myListings.length} Active Listings</span>
                                <button onclick="MarketplaceSystem.openMyListings()"> Yenile</button>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">
                    `;

                    if(myListings.length === 0) {
                        html += `<div style="grid-column: 1/-1; text-align:center; padding: 40px;" class="card text-muted">You have no active listings. Go to your inventory to sell an item!</div>`;
                    }

                    myListings.forEach(list => {
                        const i = list.item;
                        const isChest = i.category === 'chest';
                        const chestTier = isChest ? CHEST_TIERS[i.chestTier] : null;
                        const rarityData = isChest ? { color: chestTier.color } : RARITIES[i.rarity];

                        html += `
                            <div class="card item-card" style="border-color:${rarityData.color}; cursor:default;">
                                <div class="item-card-pattern" style="background: ${isChest ? 'linear-gradient(135deg, rgba(255,215,0,0.2), rgba(30,30,40,0.9))' : ItemSystem.getPatternGradient(i.patternId, i.rarity)}; height:80px; font-size:2.5rem; display:flex; align-items:center; justify-content:center;">
                                    ${isChest ? `<span style="filter: drop-shadow(0 0 15px ${chestTier.color});">${chestTier.icon}</span>` : (ITEM_CATEGORIES[i.category]?.icon || '')}
                                </div>
                                <div class="item-card-body" style="text-align:center;">
                                    <div class="item-card-title" style="color:${rarityData.color};">${isChest ? chestTier.name : (i.enchantLevel>0?`+${i.enchantLevel} `:''+i.subtype)}</div>
                                    <div style="background:var(--bg-primary); padding: 5px; border-radius: 4px; margin-bottom: 10px;">
                                        <b class="text-gold"> ${UI.formatNumber(list.price)}</b>
                                    </div>
                                    <button style="width:100%; padding: 5px; font-size: 0.8rem; border-color:var(--rarity-mythic); color:var(--rarity-mythic)" onclick="MarketplaceSystem.cancelListing('${list.listingId}')">lan ptal Et</button>
                                </div>
                            </div>
                        `;
                    });

                    html += `</div></div>`;
                    container.innerHTML = html;

                } catch (e) {
                    container.innerHTML = `<p class="text-mythic">Failed to load listings.</p>`;
                }
            }
        };

        const TradeSystem = {
            async initiateTradeSetup() {
                const targetId = document.getElementById('trade-target-id').value.trim();
                if(!targetId || targetId === gameState.player.id) return UI.showToast("Invalid Player ID.", "error");

                // Generate inventory options
                let invHtml = '<option value="">-- Select an Item --</option>';
                gameState.inventory.forEach(i => {
                    invHtml += `<option value="${i.id}">[${i.rarity.toUpperCase()}] ${i.subtype} +${i.enchantLevel}</option>`;
                });

                UI.showModal(`
                    <h3 class="text-gold" style="margin-bottom: 20px;">Create Trade Offer</h3>
                    <p class="text-secondary" style="margin-bottom: 15px;">Sending offer to: <strong class="text-gold">${targetId}</strong></p>
                    
                    <div style="margin-bottom:15px;">
                        <label style="display:block; margin-bottom:5px;">Offer Gold:</label>
                        <input type="number" id="trade-offer-gold" min="0" value="0" max="${gameState.player.gold}" style="width:100%; padding:10px;">
                        <span style="font-size:0.8rem; color:var(--text-muted)">Max: ${UI.formatNumber(gameState.player.gold)}</span>
                    </div>

                    <div style="margin-bottom:20px;">
                        <label style="display:block; margin-bottom:5px;">Offer Item (Optional):</label>
                        <select id="trade-offer-item" style="width:100%; padding:10px; background:var(--bg-secondary); color:var(--text-primary); border:var(--border-subtle)">
                            ${invHtml}
                        </select>
                    </div>

                    <div style="margin-bottom:15px;">
                        <label style="display:block; margin-bottom:5px;">Request Gold:</label>
                        <input type="number" id="trade-req-gold" min="0" value="0" style="width:100%; padding:10px;">
                    </div>

                    <div style="display:flex; gap:10px;">
                        <button style="flex:1" onclick="UI.hideModal()">ptal</button>
                        <button style="flex:1; background:var(--accent-purple); color:white;" id="btn-send-trade" onclick="TradeSystem.sendTrade('${targetId}')">Send Offer</button>
                    </div>
                `);
            },

            async sendTrade(targetId) {
                const offerGold = parseInt(document.getElementById('trade-offer-gold').value) || 0;
                const reqGold = parseInt(document.getElementById('trade-req-gold').value) || 0;
                const itemId = document.getElementById('trade-offer-item').value;

                if(offerGold > gameState.player.gold) return UI.showToast("Not enough Gold to offer.", "error");

                let offerItem = null;
                if(itemId) {
                    offerItem = InventorySystem.getItem(itemId);
                    if(!offerItem) return UI.showToast("Item not found.", "error");
                }

                if(offerGold === 0 && reqGold === 0 && !offerItem) return UI.showToast("Offer cannot be completely empty.", "error");

                const btn = document.getElementById('btn-send-trade');
                btn.disabled = true;
                btn.innerText = "Sending...";

                try {
                    // SECURITY FIX: Use transaction to prevent item duplication on network failure
                    const tradeId = 'trd_' + Date.now() + Math.random().toString(36).substr(2, 5);
                    const docRef = window.FB.doc(window.FB.db, `shared_data/trades_${targetId}_${tradeId}`);
                    
                    await window.FB.runTransaction(window.FB.db, async (transaction) => {
                        // Verify player has enough gold (server-side check via local state)
                        if(offerGold > gameState.player.gold) {
                            throw new Error("INSUFFICIENT_GOLD");
                        }
                        
                        // Verify item exists in inventory
                        if(offerItem) {
                            const itemExists = gameState.inventory.some(i => i.id === offerItem.id);
                            if(!itemExists) {
                                throw new Error("ITEM_NOT_FOUND");
                            }
                        }
                        
                        // Create trade document
                        const newTrade = {
                            tradeId: tradeId,
                            senderId: gameState.player.id,
                            senderName: gameState.player.name,
                            targetId: targetId,
                            offerGold: offerGold,
                            offerItem: offerItem,
                            reqGold: reqGold,
                            status: 'pending',
                            createdAt: Date.now()
                        };
                        
                        transaction.set(docRef, { value: newTrade }, { merge: true });
                    });

                    // After successful transaction, deduct resources locally
                    if(!SecuritySys.spendGold(offerGold)) {
                        UI.showToast("Yetersiz altn!", "error");
                        return;
                    }
                    if(offerItem) {
                        gameState.inventory = gameState.inventory.filter(i => i.id !== offerItem.id);
                    }
                    PlayerSystem.save();
                    PlayerSystem.updateUI();
                    InventorySystem.render();

                    UI.hideModal();
                    UI.showToast("Trade offer sent!", "success");
                } catch(e) {
                    console.error("Trade Error", e);
                    if (e.message === "INSUFFICIENT_GOLD") {
                        UI.showToast("Not enough Gold to offer.", "error");
                    } else if (e.message === "ITEM_NOT_FOUND") {
                        UI.showToast("Item not found in inventory.", "error");
                    } else {
                        UI.showToast("Failed to send trade.", "error");
                    }
                    // Re-enable button
                    btn.disabled = false;
                    btn.innerText = "Send Offer";
                }
            },

            async openIncoming() {
                document.getElementById('view-title').innerText = "Takas Teklifleri";
                const container = document.getElementById('view-container');
                container.innerHTML = `<div style="text-align:center; margin-top:50px;"><h3 class="text-gold">Loading Offers...</h3></div>`;

                try {
                    // FIX #25: Use targeted query instead of fetching entire shared_data collection
                    // Query trades where current player is either sender or target
                    const playerId = gameState.player.id;
                    
                    // Fetch incoming trades (player is target): trades_{playerId}_{tradeId}
                    const incomingQ = window.FB.query(
                        window.FB.collection(window.FB.db, 'shared_data'),
                        window.FB.where('__name__', '>=', `trades_${playerId}_`),
                        window.FB.where('__name__', '<=', `trades_${playerId}_\uf8ff`)
                    );
                    
                    // Fetch outgoing trades (player is sender): Need to filter by senderId
                    // Since we can't query by value without index, fetch all trades and filter client-side
                    // For better performance, consider using a subcollection or composite index
                    const allTradesQ = window.FB.query(
                        window.FB.collection(window.FB.db, 'shared_data'),
                        window.FB.where('__name__', '>=', 'trades_'),
                        window.FB.where('__name__', '<=', 'trades_\uf8ff')
                    );
                    
                    const [incomingSnap, allTradesSnap] = await Promise.all([
                        window.FB.getDocs(incomingQ),
                        window.FB.getDocs(allTradesQ)
                    ]);

                    let offers = [];
                    
                    // Process incoming trades
                    incomingSnap.forEach(doc => {
                        if(doc.data().value) {
                            const trd = doc.data().value;
                            if(trd.status === 'pending') {
                                offers.push(trd);
                            }
                        }
                    });
                    
                    // Process outgoing trades (where player is sender)
                    allTradesSnap.forEach(doc => {
                        if(doc.data().value) {
                            const trd = doc.data().value;
                            if(trd.senderId === playerId && trd.status === 'pending') {
                                // Avoid duplicates
                                if(!offers.find(o => o.tradeId === trd.tradeId)) {
                                    offers.push(trd);
                                }
                            }
                        }
                    });

                    offers.sort((a,b) => b.createdAt - a.createdAt);

                    let html = `
                        <div style="margin-top: 20px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom: 20px; align-items:center;">
                                <span class="text-secondary">${offers.length} Pending Offers</span>
                                <button onclick="TradeSystem.openIncoming()"> Yenile</button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 15px;">
                    `;

                    if(offers.length === 0) {
                        html += `<div style="padding: 40px; text-align:center;" class="card text-muted">You have no active trade offers.</div>`;
                    }

                    offers.forEach(trd => {
                        const isIncoming = trd.targetId === gameState.player.id;
                        const directionLabel = isIncoming ? `<span class="text-rarity-uncommon">Incoming from ${trd.senderName}</span>` : `<span class="text-secondary">Sent to ${trd.targetId}</span>`;
                        
                        let itemHtml = '';
                        if(trd.offerItem) {
                            const rarityData = RARITIES[trd.offerItem.rarity];
                            itemHtml = `<div style="margin-bottom:10px; padding:5px; border:1px solid ${rarityData.color}; display:inline-block; border-radius:4px;">
                                <span style="color:${rarityData.color}">[${rarityData.name}]</span> ${trd.offerItem.subtype} +${trd.offerItem.enchantLevel}
                            </div>`;
                        }

                        html += `
                            <div class="card" style="border:1px solid ${isIncoming ? 'var(--accent-gold)' : '#444'}">
                                <h4 style="margin-bottom:10px">${directionLabel}</h4>
                                <div style="display:flex; justify-content:space-between; background:var(--bg-primary); padding:10px; border-radius:4px; margin-bottom:10px;">
                                    <div>
                                        <div class="text-secondary" style="font-size:0.8rem">They Offer:</div>
                                        ${itemHtml}
                                        ${trd.offerGold > 0 ? `<div class="text-gold"> ${UI.formatNumber(trd.offerGold)}</div>` : (!trd.offerItem ? 'Nothing' : '')}
                                    </div>
                                    <div style="text-align:right">
                                        <div class="text-secondary" style="font-size:0.8rem">They Request:</div>
                                        ${trd.reqGold > 0 ? `<div class="text-gold"> ${UI.formatNumber(trd.reqGold)}</div>` : 'Nothing'}
                                    </div>
                                </div>
                                
                                ${isIncoming ? `
                                    <div style="display:flex; gap:10px;">
                                        <button style="flex:1; border-color:var(--rarity-mythic); color:var(--rarity-mythic)" onclick="TradeSystem.resolveTrade('${trd.tradeId}', '${trd.targetId}', false)">Reject</button>
                                        <button style="flex:1; background:var(--accent-gold); color:black" onclick="TradeSystem.resolveTrade('${trd.tradeId}', '${trd.targetId}', true)">Accept</button>
                                    </div>
                                ` : `
                                    <button style="width:100%; border-color:var(--rarity-mythic); color:var(--rarity-mythic)" onclick="TradeSystem.resolveTrade('${trd.tradeId}', '${trd.targetId}', false)">Cancel Sent Offer</button>
                                `}
                            </div>
                        `;
                    });

                    html += `</div></div>`;
                    container.innerHTML = html;

                } catch(e) {
                    container.innerHTML = `<p class="text-mythic">Failed to load trades.</p>`;
                }
            },

            async resolveTrade(tradeId, targetDocId, isAccept) {
                const docId = `trades_${targetDocId}_${tradeId}`;
                const docRef = window.FB.doc(window.FB.db, `shared_data/${docId}`);

                try {
                    UI.showToast("leniyor...", "info");

                    // Client-side transaction for trade resolution
                    await window.FB.runTransaction(window.FB.db, async (transaction) => {
                        const trdDoc = await transaction.get(docRef);
                        if(!trdDoc.exists() || trdDoc.data().value.status !== 'pending') {
                            throw new Error("Trade no longer valid.");
                        }

                        const trd = trdDoc.data().value;

                        if(!isAccept) {
                            // Rejecting / Cancelling
                            trd.status = 'rejected';
                            transaction.update(docRef, { "value.status": 'rejected' });

                            // Send inbox message to sender to refund their stuff
                            const inboxRef = window.FB.doc(window.FB.db, 'shared_data/player-inbox');
                            const inboxDoc = await transaction.get(inboxRef);
                            let inbox = inboxDoc.exists() ? inboxDoc.data().value || [] : [];

                            inbox.push({
                                id: 'inb_' + Date.now() + Math.random().toString(36).substr(2, 5),
                                playerId: trd.senderId,
                                gold: trd.offerGold,
                                itemReturn: trd.offerItem,
                                message: `Trade Rejected/Cancelled. Your items and gold have been returned.`
                            });

                            transaction.set(inboxRef, { value: inbox }, { merge: true });
                            return;
                        }

                        // Accepting - server-side validation preferred
                        if(gameState.player.gold < trd.reqGold) {
                            throw new Error("INSUFFICIENT_FUNDS");
                        }

                        trd.status = 'completed';
                        transaction.update(docRef, { "value.status": 'completed' });

                        // Distribute to sender via inbox
                        const inboxRef = window.FB.doc(window.FB.db, 'shared_data/player-inbox');
                        const inboxDoc = await transaction.get(inboxRef);
                        let inbox = inboxDoc.exists() ? inboxDoc.data().value || [] : [];

                        inbox.push({
                            id: 'inb_' + Date.now() + Math.random().toString(36).substr(2, 5),
                            playerId: trd.senderId,
                            gold: trd.reqGold,
                            message: `Trade Accepted! You received ${UI.formatNumber(trd.reqGold)} Gold.`
                        });
                        transaction.set(inboxRef, { value: inbox }, { merge: true });

                        // Distribute to target (US) locally
                        SecuritySys.spendGold(trd.reqGold);
                        SecuritySys.addGold(trd.offerGold);
                        if(trd.offerItem) {
                            trd.offerItem.tradeHistory.push({ from: trd.senderId, to: gameState.player.id, price: trd.reqGold, date: Date.now() });
                            // FIX #10: Use centralized addToInventory for limit check consistency
                            InventorySystem.addToInventory(trd.offerItem, true);
                        }

                        PlayerSystem.save();
                    });

                    UI.showToast(isAccept ? "Trade Successful!" : "Trade closed.", isAccept ? "success" : "info");
                    this.openIncoming();

                } catch(e) {
                    console.error(e);
                    if(e.message === "INSUFFICIENT_FUNDS") UI.showToast("You don't have enough Gold to accept this trade.", "error");
                    else UI.showToast("Trade processing failed. It may have been rescinded.", "error");
                }
            }
        };

        const ProfileSystem = {
            async showProfile(playerId) {
                // Fetch public profile
                UI.showToast(`Loading profile for ${playerId}...`, "info");
                try {
                    const prof = await StorageAPI.get(`public-profile:${playerId}`, true);
                    if(!prof) return UI.showToast("Profile not found.", "error");

                    // For now, just a simple showcase modal
                    let showcaseHtml = '';
                    if(prof.showcase && prof.showcase.length > 0) {
                        prof.showcase.forEach(i => {
                            const rarityData = RARITIES[i.rarity];
                            const gradient = ItemSystem.getPatternGradient(i.patternId, i.rarity);
                            showcaseHtml += `
                                <div class="item-card" style="border-color:${rarityData.color}; width:120px; cursor:default;">
                                    <div class="item-card-pattern" style="background: ${gradient}; height:60px; font-size:2rem;">${ITEM_CATEGORIES[i.category]?.icon}</div>
                                    <div class="item-card-body" style="text-align:center; padding: 5px;">
                                        <div class="item-card-title" style="color:${rarityData.color}; font-size:0.75rem;">${i.enchantLevel>0?`+${i.enchantLevel} `:''}${i.subtype}</div>
                                    </div>
                                </div>
                            `;
                        });
                    } else {
                        showcaseHtml = '<p class="text-muted">No items showcased.</p>';
                    }

                    UI.showModal(`
                        <h2 class="text-gold" style="margin-bottom:5px;">${prof.name}</h2>
                        <p class="text-secondary" style="font-size:0.85rem; margin-bottom:20px;">Joined: ${new Date(prof.joinedAt).toLocaleDateString()}</p>
                        
                        <div style="background:var(--bg-secondary); padding:15px; border-radius:8px; border:var(--border-subtle); margin-bottom:20px; text-align:left;">
                            <h4 style="margin-bottom:10px;">Statistics</h4>
                            <div class="flex-between"><span>Items Crafted:</span> <span>${prof.stats?.totalCrafted || 0}</span></div>
                            <div class="flex-between"><span>Rarest Item:</span> <span style="color:var(--rarity-${prof.stats?.rarest_item || 'common'})">${prof.stats?.rarest_item || 'None'}</span></div>
                        </div>

                        <h4 style="text-align:left; margin-bottom:10px;">Showcase</h4>
                        <div style="display:flex; gap:10px; overflow-x:auto; padding-bottom:10px;">
                            ${showcaseHtml}
                        </div>
                    `);
                } catch(e) {
                    UI.showToast("Error loading profile", "error");
                }
            }
        }


        // Override load to process Inbox logic (Player receiving gold/items from offline sales or rejected trades)
        const __originalOnLoad = PlayerSystem.onLoadGame;
        PlayerSystem.onLoadGame = async function() {
            __originalOnLoad.call(this);
            
            // Check inbox
            try {
                let inbox = await StorageAPI.get('player-inbox', true) || [];
                let myMsgs = inbox.filter(m => m.playerId === gameState.player.id);
                
                if(myMsgs.length > 0) {
                    let totalGold = 0; let totalGems = 0;
                    let returnedItems = [];

                    myMsgs.forEach(m => {
                        if(m.gold) totalGold += m.gold;
                        if(m.gems) totalGems += m.gems;
                        if(m.itemReturn) {
                            returnedItems.push(m.itemReturn);
                            gameState.inventory.push(m.itemReturn);
                            // Increment new item counter for notification badge
                            gameState.player.newItemCount = (gameState.player.newItemCount || 0) + 1;
                        }
                    });

                    SecuritySys.addGold(totalGold);
                    gameState.player.gems += totalGems;
                    this.updateUI();
                    if(returnedItems.length > 0) {
                        InventorySystem.render();
                    }
                    this.save();
                    
                    let itemsHtml = '';
                    if(returnedItems.length > 0) {
                        itemsHtml = `<div style="margin-top:10px; font-size:0.9rem; color:var(--text-secondary);">Items Returned: ${returnedItems.map(i => i.subtype).join(', ')}</div>`;
                    }

                    UI.showModal(`
                        <h2 class="text-gold" style="margin-bottom:15px;">Inbox Messages</h2>
                        <p>While you were away, you received activities from the community (Sales or Trades).</p>
                        <div style="margin:20px 0; padding:15px; border:1px solid var(--accent-gold); background:var(--bg-tertiary); border-radius:4px;">
                            ${totalGold > 0 ? `<div class="flex-between" style="font-size:1.2rem; margin-bottom:10px;"><span>Gold Received:</span> <strong class="text-gold">+${UI.formatNumber(totalGold)}</strong></div>` : ''}
                            ${totalGems > 0 ? `<div class="flex-between" style="font-size:1.2rem;"><span>Gems Earned:</span> <strong style="color:var(--rarity-epic)">+${UI.formatNumber(totalGems)}</strong></div>` : ''}
                            ${itemsHtml}
                        </div>
                    `);

                    // Clean inbox
                    let remainingInbox = inbox.filter(m => m.playerId !== gameState.player.id);
                    await StorageAPI.set('player-inbox', remainingInbox, true);
                }
            } catch(e) { console.error("Inbox load error", e); }
        };

        // --- 3. CORE LOOP --- //
        const GameLoop = {
            intervalId: null,
            lastSave: Date.now(),

            start() {
                gameState.lastTick = Date.now();
                this.intervalId = setInterval(() => this.tick(), 1000);
            },

            tick() {
                const now = Date.now();
                let dt = (now - gameState.lastTick) / 1000;
                if(dt > 86400) dt = 86400;
                gameState.lastTick = now;

                if (gameState.player) {
                    PlayerSystem.updateUI();
                    ItemSystem.updateCraftTimers();

                    // Hero HP regeneration: 1 HP every 15 seconds (only outside combat)
                    // Regen rate scales with level: 1 HP per (15 / level) seconds, min 1 sec
                    // SECURITY FIX: Use _inCombatLock timestamp to prevent client-side manipulation
                    const heroLevel = gameState.player.level || 1;
                    const maxHp = LevelSystem.getMaxHp(heroLevel);
                    const currentHp = gameState.player.heroHp !== undefined ? gameState.player.heroHp : maxHp;
                    
                    // Check combat status with timestamp lock (prevents inCombat = false exploit)
                    const combatLock = gameState.player._combatLock || 0;
                    const isInCombat = DungeonSystem.inCombat || (Date.now() - combatLock < 5000);
                    
                    if(!isInCombat && gameState.player && currentHp < maxHp) {
                        const lastRegen = gameState.player._lastHpRegen || 0;
                        const regenInterval = Math.max(1000, Math.floor(15000 / heroLevel)); // Faster regen at higher levels
                        if(now - lastRegen >= regenInterval) {
                            gameState.player.heroHp = Math.min(maxHp, currentHp + 1);
                            gameState.player._lastHpRegen = now;
                            PlayerSystem.updateHeroHPDisplay();
                        }
                    }

                    // Leaderboard push (throttled to once per minute)
                    LeaderboardSystem.pushMyScore();
                }

                // Auto save every 10 seconds
                if(now - this.lastSave > 10000) {
                    PlayerSystem.save();
                    StorageAPI.set('last-save-time', now);
                    this.lastSave = now;
                }
            }
        };

        // Offline integration inside PlayerSystem
        // FIX #21: Removed duplicate empty function - offline progress is now handled in PlayerSystem.start()
        // Passive income was removed in Phase 11 (Active RPG Transition)

        // --- DAILY SYSTEM --- //
        const DailySystem = {
            checkLoginStreak() {
                const p = gameState.player;
                if(!p || !p.dailyData) return;
                const d = p.dailyData;
                const now = Date.now();
                const todayMidnight = new Date(); todayMidnight.setHours(0,0,0,0); const todayStamp = todayMidnight.getTime();
                const lastLoginMidnight = d.lastLogin ? new Date(d.lastLogin) : null;
                if(lastLoginMidnight) lastLoginMidnight.setHours(0,0,0,0);
                const lastStamp = lastLoginMidnight ? lastLoginMidnight.getTime() : 0;
                const yesterday = todayStamp - 86400000;

                if(lastStamp === todayStamp) return; // Already logged in today

                if(lastStamp === yesterday) {
                    d.streakCount = (d.streakCount || 0) + 1;
                } else if(lastStamp < yesterday) {
                    d.streakCount = 1; // streak broken, restart
                }

                d.lastLogin = now;
                const dayIdx = ((d.streakCount - 1) % 7);
                const reward = STREAK_REWARDS[dayIdx];

                // Apply reward
                for(const [res, amt] of Object.entries(reward)) {
                    p[res] = (p[res] || 0) + amt;
                }

                // Reset daily quests if new day
                if(!d.lastQuestsReset || d.lastQuestsReset < todayStamp) {
                    d.questsProgress = { kills: 0, crafts: 0, sells: 0, enchants: 0 };
                    d.questsCompleted = [];
                    d.lastQuestsReset = todayStamp;
                }

                PlayerSystem.save();
                PlayerSystem.updateUI();

                const rewardText = Object.entries(reward).map(([k,v])=>`+${v} ${LangSys.get('res_'+k)||k}`).join(', ');
                UI.showModal(`
                    <div style="text-align:center;">
                        <h2 class="text-gold" style="margin-bottom:10px;">${LangSys.get('streak_reward')}</h2>
                        <div style="font-size:3rem; margin-bottom:10px;"></div>
                        <p style="color:var(--rarity-legendary); font-size:1.3rem; margin-bottom:5px;">${LangSys.get('streak_day')} ${d.streakCount}</p>
                        ${d.streakCount % 7 === 0 ? '<p style="color:var(--rarity-mythic); font-weight:bold;"> Week Complete Bonus!</p>' : ''}
                        <div style="background:var(--bg-tertiary); padding:15px; border-radius:8px; margin:15px 0; border:1px solid var(--accent-gold);">
                            <strong>${rewardText}</strong>
                        </div>
                        <button style="width:100%; margin-top:10px;" onclick="UI.hideModal()">Claim!</button>
                    </div>
                `);
            },

            trackProgress(type, amount) {
                const p = gameState.player;
                if(!p || !p.dailyData) return;
                const d = p.dailyData;
                const now = Date.now();
                const todayMidnight = new Date(); todayMidnight.setHours(0,0,0,0);
                // Reset if day changed
                if(!d.lastQuestsReset || d.lastQuestsReset < todayMidnight.getTime()) {
                    d.questsProgress = { kills: 0, crafts: 0, sells: 0, enchants: 0 };
                    d.questsCompleted = [];
                    d.lastQuestsReset = todayMidnight.getTime();
                }
                if(!d.questsProgress) d.questsProgress = { kills: 0, crafts: 0, sells: 0, enchants: 0 };
                d.questsProgress[type] = (d.questsProgress[type] || 0) + amount;

                // Check quest completion
                DAILY_QUESTS.forEach(q => {
                    if(!d.questsCompleted.includes(q.id) && d.questsProgress[q.reqKey] >= q.target) {
                        d.questsCompleted.push(q.id);
                        p[q.rewardKey] = (p[q.rewardKey] || 0) + q.rewardAmt;
                        PlayerSystem.updateUI();
                        const questName = LangSys.get(q.nameKey) || q.id;
                        UI.showToast(` ${LangSys.get('daily_quests')}: ${questName}  +${q.rewardAmt} ${LangSys.get('res_'+q.rewardKey)||q.rewardKey}`, 'success');
                    }
                });

                // All quests bonus
                if(d.questsCompleted.length === DAILY_QUESTS.length && !d.allQuestsBonusClaimed) {
                    d.allQuestsBonusClaimed = true;
                    p.gems = (p.gems || 0) + 3;
                    PlayerSystem.updateUI();
                    UI.showToast(` ${LangSys.get('quests_complete')} +3`, 'achievement');
                    AudioSystem.achievement();
                }
            },

            renderQuestPanel() {
                const p = gameState.player;
                if(!p || !p.dailyData) return '<em class="text-muted">Login required for daily quests.</em>';
                const d = p.dailyData;
                const streak = d.streakCount || 0;
                let html = `
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                        <h4 class="text-gold">${LangSys.get('daily_quests')}</h4>
                        <span style="color:var(--rarity-legendary); font-family:var(--font-display);"> ${LangSys.get('login_streak')}: ${streak}</span>
                    </div>
                `;
                DAILY_QUESTS.forEach(q => {
                    const done = d.questsCompleted && d.questsCompleted.includes(q.id);
                    const progress = (d.questsProgress && d.questsProgress[q.reqKey]) || 0;
                    const pct = Math.min(100, (progress / q.target) * 100);
                    const questName = LangSys.get(q.nameKey) || q.id;
                    html += `
                        <div class="quest-item ${done ? 'done' : 'active'}">
                            <div>
                                <div style="font-size:0.9rem; ${done?'text-decoration:line-through; color:var(--text-muted)':''}">${done ? ' ' : ''}${questName}</div>
                                ${!done ? `<div style="font-size:0.75rem; color:var(--text-secondary); margin-top:3px;">${progress}/${q.target}</div>` : ''}
                            </div>
                            <div style="text-align:right; font-size:0.8rem; color:var(--accent-gold);">+${q.rewardAmt} ${LangSys.get('res_'+q.rewardKey)||q.rewardKey}</div>
                        </div>
                    `;
                });
                const nextDay = ((streak % 7) + 1);
                const nextReward = STREAK_REWARDS[nextDay - 1] || STREAK_REWARDS[0];
                const nextRewardText = Object.entries(nextReward).map(([k,v])=>`+${v} ${LangSys.get('res_'+k)||k}`).join(', ');
                html += `<div style="margin-top:12px; font-size:0.8rem; color:var(--text-muted);">Next streak reward (Day ${nextDay}): ${nextRewardText}</div>`;
                return html;
            }
        };

        // --- ACHIEVEMENT SYSTEM --- //
        const AchievementSystem = {
            check(statKey, newValue) {
                if(!gameState.player || !gameState.player.stats) return;
                const unlocked = gameState.player.stats.unlockedAchievements || [];
                ACHIEVEMENTS.forEach(ach => {
                    if(ach.req.stat === statKey && newValue >= ach.req.val && !unlocked.includes(ach.id)) {
                        this.unlock(ach);
                    }
                });
            },
            unlock(ach) {
                if(!gameState.player.stats.unlockedAchievements) gameState.player.stats.unlockedAchievements = [];
                gameState.player.stats.unlockedAchievements.push(ach.id);
                for(const [res, amt] of Object.entries(ach.reward)) {
                    gameState.player[res] = (gameState.player[res] || 0) + amt;
                }
                AudioSystem.achievement();
                const name = LangSys.get(ach.nameKey) || ach.nameKey;
                UI.showToast(`${ach.icon} ${LangSys.get('achievement_unlocked')}: ${name}`, 'achievement');
                PlayerSystem.save();
                PlayerSystem.updateUI();
            },
            renderPanel() {
                if(!gameState.player) return '';
                const unlocked = gameState.player.stats.unlockedAchievements || [];
                let html = `<h4 class="text-gold" style="margin-bottom:12px;">${LangSys.get('achievements')}</h4><div style="display:flex; flex-direction:column; gap:8px;">`;
                ACHIEVEMENTS.forEach(ach => {
                    const done = unlocked.includes(ach.id);
                    const name = LangSys.get(ach.nameKey) || ach.nameKey;
                    const rewardText = Object.entries(ach.reward).map(([k,v])=>`+${v} ${LangSys.get('res_'+k)||k}`).join(', ');
                    html += `<div class="quest-item ${done ? 'done' : ''}" style="${done ? '' : 'opacity:0.6'}">
                        <div><span style="font-size:1.2rem; margin-right:6px;">${ach.icon}</span>${done ? ' ' : ' '}<strong>${name}</strong></div>
                        <div style="font-size:0.8rem; color:var(--accent-gold);">${rewardText}</div>
                    </div>`;
                });
                html += '</div>';
                return html;
            }
        };

        // --- HERO SYSTEM --- //
        const HeroSystem = {
            toggleEquip(item) {
                if(!item) return;
                const slot = EQUIP_SLOTS[item.category];
                if(!slot) return UI.showToast("This item cannot be equipped.", 'error');
                if(!gameState.player.heroEquipped) gameState.player.heroEquipped = { weapon: null, armor: null, ring: null, amulet: null };
                const current = gameState.player.heroEquipped[slot];
                if(current && current.id === item.id) {
                    // Unequip: Return item to inventory
                    gameState.player.heroEquipped[slot] = null;
                    InventorySystem.addToInventory(item, true);
                    UI.showToast(`${item.subtype} ${LangSys.get('unequip')}.`, 'info');
                } else {
                    // Equip: First return current equipped item to inventory (if any)
                    if(current) {
                        gameState.player.heroEquipped[slot] = null;
                        InventorySystem.addToInventory(current, true);
                        UI.showToast(`${current.subtype} karld, ${item.subtype} giyildi.`, 'info');
                    } else {
                        UI.showToast(`${item.subtype} ${LangSys.get('equip_hero')}!`, 'success');
                    }
                    // Then equip new item
                    InventorySystem.removeFromInventory(item.id);
                    gameState.player.heroEquipped[slot] = item;
                }
                UI.hideModal();
                PlayerSystem.save();
                // Refresh UI - re-render enchant tower if open
                const enchantArea = document.getElementById('enchant-main-area');
                if(enchantArea && EnchantSystem.currentItem) {
                    EnchantSystem.setupEnchantView(EnchantSystem.currentItem);
                }
                // Refresh hero view if open
                const heroView = document.getElementById('hero-view-content');
                if(heroView) {
                    this.renderFullView();
                }
                // Refresh forge/enchant tower view if open
                const viewTitle = document.getElementById('view-title');
                if(viewTitle && viewTitle.innerText.includes('Byc')) {
                    BuildingSystem.selectBuilding('enchant_tower');
                }
            },
            showEquippedItem(slot) {
                const item = gameState.player.heroEquipped[slot];
                if(!item) return;
                // Pass item directly with a flag indicating it's equipped
                InventorySystem.showItemDetails(item, false, true);
            },
            renderEquipPanel() {
                const eq = gameState.player.heroEquipped || {};
                const slots = ['weapon', 'armor', 'ring', 'amulet'];
                const slotIcons = { weapon: '', armor: '', ring: '', amulet: '' };
                let bonusAtk = 0, bonusDef = 0, bonusMag = 0;
                let html = `<h4 class="text-gold" style="margin-bottom:12px;">${LangSys.get('hero_equipment')}</h4>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:12px;">`;
                slots.forEach(slot => {
                    const item = eq[slot];
                    if(item) {
                        const effAtk = InventorySystem.applyEnchantMult(item.stats.attack, item.enchantLevel || 0);
                        const effDef = InventorySystem.applyEnchantMult(item.stats.defense, item.enchantLevel || 0);
                        const effMag = InventorySystem.applyEnchantMult(item.stats.magic, item.enchantLevel || 0);
                        bonusAtk += effAtk; bonusDef += effDef; bonusMag += effMag;
                        const rarityData = RARITIES[item.rarity];
                        html += `<div class="equip-slot filled" style="border-color:${rarityData.color};" onclick="HeroSystem.showEquippedItem('${slot}')">
                            <div style="font-size:1.4rem;">${ITEM_CATEGORIES[item.category]?.icon || ''}</div>
                            <div style="font-size:0.7rem; color:${rarityData.color}; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:80px;">${item.subtype}</div>
                            <div style="font-size:0.65rem; color:var(--text-muted);">${slotIcons[slot]} ${LangSys.get('slot_'+slot)}</div>
                        </div>`;
                    } else {
                        html += `<div class="equip-slot"><div style="font-size:1.4rem; color:#444;">${slotIcons[slot]}</div><div style="font-size:0.75rem; color:var(--text-muted);">${LangSys.get('slot_'+slot)}</div><div style="font-size:0.7rem; color:#333;">${LangSys.get('slot_empty')}</div></div>`;
                    }
                });
                html += `</div>`;
                if(bonusAtk > 0 || bonusDef > 0 || bonusMag > 0) {
                    html += `<div style="background:var(--bg-secondary); padding:10px; border-radius:6px; font-size:0.85rem; border:var(--border-subtle);">
                        <div style="font-size:0.8rem; color:var(--text-muted); margin-bottom:5px;">${LangSys.get('equipped_bonus')}:</div>
                        ${bonusAtk > 0 ? `<div class="flex-between"><span>ATK</span><span class="text-gold">+${bonusAtk}</span></div>` : ''}
                        ${bonusDef > 0 ? `<div class="flex-between"><span>DEF</span><span class="text-gold">+${bonusDef}</span></div>` : ''}
                        ${bonusMag > 0 ? `<div class="flex-between"><span>MAG</span><span class="text-gold">+${bonusMag}</span></div>` : ''}
                    </div>`;
                }
                return html;
            },
            renderFullView() {
                const container = document.getElementById('hero-view-content');
                if(!container) return;
                
                let html = `
                    <div class="card" style="padding: 30px;">
                        ${this.renderEquipPanel()}
                    </div>
                    <div class="card" style="padding: 30px;">
                        <h4 class="text-gold" style="margin-bottom: 20px;">Hero Statistics</h4>
                        <div style="display:flex; flex-direction:column; gap:15px;">
                            <div class="flex-between"><span>Level:</span> <strong class="text-gold">${gameState.player.level || 1}</strong></div>
                            <div style="padding:8px 0;">
                                <div style="display:flex; justify-content:space-between; font-size:0.85rem; margin-bottom:4px;">
                                    <span style="color:var(--text-secondary);">Experience</span>
                                    <span style="color:var(--accent-gold);">${gameState.player.xp || 0} / ${LevelSystem.getXpRequired(gameState.player.level)} XP</span>
                                </div>
                                <div style="width:100%; height:10px; background:#222; border-radius:5px; overflow:hidden;">
                                    <div style="height:100%; background:linear-gradient(to right, var(--accent-gold), var(--accent-gold-bright)); width:${LevelSystem.getXpProgress()}%; transition:width 0.3s;"></div>
                                </div>
                            </div>
                            <div class="flex-between"><span>Monsters Defeated:</span> <strong class="text-gold">${gameState.player.stats.monstersKilled || 0}</strong></div>
                            <div class="flex-between"><span>Items Crafted:</span> <strong class="text-gold">${gameState.player.stats.totalItemsCrafted || 0}</strong></div>
                            <div class="flex-between"><span>Legendaries Found:</span> <strong style="color:var(--rarity-legendary)">${gameState.player.stats.legendaryFound || 0}</strong></div>
                            <div class="flex-between"><span>Success Rate:</span> <strong class="text-uncommon">${((gameState.player.stats.enchantSuccesses / (gameState.player.stats.totalEnchants || 1)) * 100).toFixed(1)}%</strong></div>
                        </div>
                        <div style="margin-top: 30px;">
                             ${AchievementSystem.renderPanel()}
                        </div>
                    </div>
                `;
                container.innerHTML = html;
            }
        };

        // --- LEADERBOARD SYSTEM --- //
        const LeaderboardSystem = {
            lastPush: 0,
            currentTab: 'gold',

            async pushMyScore() {
                const now = Date.now();
                if(now - this.lastPush < 60000) return; // Max once per minute
                if(!gameState.player) return;
                this.lastPush = now;

                try {
                    const p = gameState.player;

                    // FIX #8: Use client-side StorageAPI (Cloud Functions require Blaze plan)
                    // Direct write to leaderboard-data with checksum validation
                    let lb = await StorageAPI.get('leaderboard-data', true) || { gold: [], crafts: [], kills: [] };
                    ['gold', 'crafts', 'kills'].forEach(cat => {
                        if(!Array.isArray(lb[cat])) lb[cat] = [];
                        const val = cat === 'gold' ? Math.floor(p.gold) : (cat === 'crafts' ? (p.stats.totalItemsCrafted || 0) : (p.stats.monstersKilled || 0));
                        const entry = { playerId: p.id, playerName: p.name, value: val, updatedAt: now };
                        const idx = lb[cat].findIndex(e => e.playerId === p.id);
                        if(idx >= 0) lb[cat][idx] = entry; else lb[cat].push(entry);
                        lb[cat].sort((a,b) => b.value - a.value);
                        lb[cat] = lb[cat].slice(0, 20);
                    });
                    await StorageAPI.set('leaderboard-data', lb, true);
                } catch(e) { console.warn('Leaderboard push failed', e); }
            },

            async openLeaderboard() {
                document.getElementById('view-title').innerText = LangSys.get('leaderboard');
                const container = document.getElementById('view-container');
                container.innerHTML = `<div style="text-align:center; margin-top:50px;"><h3 class="text-gold">${LangSys.get('loading')}</h3></div>`;
                try {
                    const lb = await StorageAPI.get('leaderboard-data', true) || { gold: [], crafts: [], kills: [] };
                    this.renderLeaderboard(container, lb, this.currentTab);
                } catch(e) { container.innerHTML = `<p class="text-secondary">Failed to load leaderboard.</p>`; }
            },

            renderLeaderboard(container, lb, tab) {
                this.currentTab = tab;
                const tabs = [
                    { key: 'gold',   labelKey: 'lb_gold',   suffix: '' },
                    { key: 'crafts', labelKey: 'lb_crafts', suffix: '' },
                    { key: 'kills',  labelKey: 'lb_kills',  suffix: '' }
                ];
                let tabHtml = `<div class="lb-tabs">`;
                tabs.forEach(t => { tabHtml += `<button class="lb-tab ${t.key===tab?'active':''}" onclick="LeaderboardSystem.renderLeaderboard(document.getElementById('view-container'), window._lbData, '${t.key}')">${t.suffix} ${LangSys.get(t.labelKey)}</button>`; });
                tabHtml += `</div>`;
                window._lbData = lb;
                const rows = lb[tab] || [];
                const myId = gameState.player ? gameState.player.id : '';
                let listHtml = rows.length === 0 ? `<p class="text-muted" style="text-align:center; padding:20px;">No data yet. Play more to appear here!</p>` : '';
                rows.forEach((entry, i) => {
                    const rankIcon = i === 0 ? '' : (i === 1 ? '' : (i === 2 ? '' : `${i+1}.`));
                    const isMe = entry.playerId === myId;
                    listHtml += `<div class="lb-row ${isMe?'me':''}"><span class="lb-rank">${rankIcon}</span><span style="flex:1">${entry.playerName}</span><strong class="text-gold">${UI.formatNumber(entry.value)}</strong></div>`;
                });
                container.innerHTML = `
                    <button style="margin-bottom:20px; background:var(--bg-tertiary); border:var(--border-subtle); color:var(--text-secondary); width:auto; padding:8px 15px;" onclick="BuildingSystem.renderMainView()"> Back to Town</button>
                    <div class="card" style="max-width:600px;">
                        <h3 class="text-gold" style="margin-bottom:15px;"> ${LangSys.get('leaderboard')}</h3>
                        ${tabHtml}
                        <div>${listHtml}</div>
                    </div>
                `;
            }
        };

        // --- INIT --- //
        window.addEventListener('DOMContentLoaded', () => {
            // Init Dev Mode first
            DevMode.init();
            
            StorageAPI.init((uid) => {
                PlayerSystem.init();
                // Apply Dev Mode settings after player loads
                setTimeout(() => DevMode.apply(), 1000);
            });
        });

    </script>
</body>
</html>
